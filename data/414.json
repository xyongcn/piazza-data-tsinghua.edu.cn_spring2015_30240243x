{"error": null, "result": {"nr": 414, "upvote_ids": [], "change_log": [{"type": "create", "when": "2015-05-11T06:24:56Z", "uid": "hdjonbiyfs62ie", "data": "i9ji8tpz27d6d2", "anon": "no"}, {"type": "followup", "to": "i9ji8tpx3pk6d1", "when": "2015-05-11T08:29:05Z", "uid": "i6t1w87gRBD", "anon": "no"}, {"to": "i9ji8tpx3pk6d1", "when": "2015-05-26T06:34:46Z", "anon": "stud", "type": "followup"}, {"to": "i9ji8tpx3pk6d1", "when": "2015-05-26T06:50:17Z", "anon": "stud", "type": "feedback"}, {"type": "feedback", "to": "i9ji8tpx3pk6d1", "when": "2015-05-28T15:32:41Z", "uid": "hdjonbiyfs62ie", "anon": "no"}], "q_edits": [], "i_edits": [], "unique_views": 76, "bookmarked": 4, "config": {}, "history": [{"subject": "银行家算法中的安全状态判断、死锁检测算法和安全序列判断的相似性和差异分析", "content": "<p>问题描述&#xff1a;</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/08-1-spoc-discussion.md#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B\">https://github.com/xuyongjiande/os_exercises/blob/master/all/08-1-spoc-discussion.md#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B</a></p>\n<p></p>\n<p>请参与课堂讨论的同学回复自己的回答和可能的疑惑。</p>", "created": "2015-05-11T06:24:56Z", "uid": "hdjonbiyfs62ie", "anon": "no"}], "data": {"embed_links": []}, "request_instructor_me": false, "folders": ["课堂问答"], "type": "note", "tag_good": [], "tag_good_arr": [], "created": "2015-05-11T06:24:56Z", "t": 1433500513056, "id": "i9ji8tpx3pk6d1", "status": "active", "default_anonymity": "no", "my_favorite": false, "bucket_order": 2, "is_bookmarked": false, "is_tag_good": false, "bucket_name": "Today", "no_answer_followup": 0, "children": [{"no_upvotes": 0, "uid": "i6t1w87gRBD", "bucket_name": "Week 5/10 - 5/16", "bucket_order": 7, "updated": "2015-05-11T08:29:05Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>计24 王昊 2012011341</p>\n<p>安全序列判断&#xff1a;根据当前所有进程的最大需求资源、已分配资源&#xff0c;暴力搜索一个进程执行序列&#xff0c;使得每个进程可以利用OS的空闲资源和之前已执行完的进程设防的资源完成。该判断需要程序在开始执行前给出他日后会申请的所有资源列表&#xff08;即最大申请资源&#xff09;。</p>\n<p></p>\n<p>安全状态判断&#xff1a;操作系统得到一个进程的资源请求时&#xff0c;假设分配给该进程&#xff0c;然后检查分配之后是否存在安全序列。他与安全序列判断的区别仅限于此。&#xff08;也可以认为安全序列判断是安全状态判断的一个子步骤&#xff09;</p>\n<p></p>\n<p>死锁检测算法&#xff1a;操作系统根据当前进程已分配的资源和正在申请的资源&#xff0c;检测是否存在死锁。也可理解成OS认为当前进程不会再申请其他资源&#xff0c;那么进程最大需求资源=已分配资源&#43;正在申请资源&#xff0c;然后执行安全序列判断。需要注意的是&#xff1a;该算法并不需要进程给出最大需求资源。</p>\n<p></p>\n<p>这里给出一个例子&#xff0c;已便解释的更清楚&#xff1a;</p>\n<p>进程A&#xff1a;申请资源1-&gt;run1-&gt;释放资源1-&gt;申请资源2-&gt;run2-&gt;释放资源2-&gt;申请资源3-&gt;run3-&gt;释放资源3-&gt;结束</p>\n<p>进程B&#xff1a;申请资源1-&gt;run1-&gt;申请资源2-&gt;释放资源1-&gt;run2-&gt;申请资源3-&gt;释放资源2-&gt;run3-&gt;释放资源3-&gt;结束</p>\n<p>                                                             </p>\n<p>进程C&#xff1a;申请资源1,2,3-&gt;run-&gt;释放资源1,2,3</p>\n<p></p>\n<p>以上进程最大需求资源皆为资源1,2,3各*1</p>\n<p></p>\n<p>系统拥有资源1*1&#xff0c;资源2*1&#xff0c;资源3*1</p>\n<p>进程A或B分配到资源1后执行至run1&#xff0c;进程C申请&#xff0c;若为银行家算法&#xff0c;此时会被判定为不安全&#xff0c;不会分配。</p>\n<p>但若只有死锁检测算法&#xff0c;假设进程A或B执行到run1&#xff0c;然后进程C申请资源1,2,3&#xff0c;得到资源2,3&#xff0c;等待资源1&#xff0c;此时检测会发现没有死锁。</p>\n<p>事实上若执行的是进程A&#xff0c;则不会发生死锁&#xff1b;但若执行的是进程B&#xff0c;当其完成run1后&#xff0c;申请资源2&#xff0c;进入等待&#xff0c;此时再检测就会发现死锁。</p>\n<p></p>", "children": [], "type": "followup", "no_answer": 0, "created": "2015-05-11T08:29:05Z", "id": "i9jmohal21i5id"}, {"no_upvotes": 0, "bucket_name": "This week", "bucket_order": 4, "updated": "2015-05-26T06:34:46Z", "config": {}, "anon": "stud", "data": {"embed_links": null}, "folders": [], "subject": "<p>疑惑&#xff1a;银行家算法的第三个步骤是否必要&#xff1f;如果第二个步骤判断某个线程需要的资源要小于现有可提供的资源&#xff0c;那么分配给他之后待其运行完毕回收&#xff0c;可用资源必定是增加的&#xff0c;那还需要在分配之前确定是否安全吗&#xff1f;</p>", "children": [{"folders": [], "bucket_order": 4, "updated": "2015-05-26T06:50:17Z", "config": {}, "anon": "stud", "data": {"embed_links": null}, "bucket_name": "This week", "subject": "<p>若银行家算法在第三部判断出不安全&#xff0c;那即使第二步情况满足&#xff08;即某个进程可以得到所需资源并执行完释放&#xff09;但整体达不到安全状态&#xff0c;系统依然不会把资源分配给该进程&#xff0c;以最大化利用资源&#xff0c;是这样吗&#xff1f;</p>", "children": [], "type": "feedback", "created": "2015-05-26T06:50:17Z", "id": "ia4yr6o9nbk5gy"}, {"uid": "hdjonbiyfs62ie", "bucket_name": "Today", "bucket_order": 2, "updated": "2015-05-28T15:32:41Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>是的。尽管都有最大资源数目已限制&#xff0c;但分配顺序不同&#xff0c;结果就可能由安全变成不安全了。</p>\n<p></p>\n<p>如果有兴趣&#xff0c;你可以尝试找一个这样的实例。并把你的结果回复在后面。</p>", "children": [], "type": "feedback", "created": "2015-05-28T15:32:41Z", "id": "ia8capdmi053pv"}], "type": "followup", "no_answer": 0, "created": "2015-05-26T06:34:46Z", "id": "ia4y78dris31sy"}], "request_instructor": 0, "tags": ["instructor-note", "课堂问答"], "s_edits": [], "num_favorites": 1}, "aid": "iajh6yw072c538"}