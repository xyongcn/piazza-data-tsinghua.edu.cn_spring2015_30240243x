{"aid": "j2pqkgxgxsi1o3", "result": {"status": "active", "unique_views": 92, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-04-01T13:31:51Z", "data": "j0zargqorc8782", "uid": "hcrrjuyequh4bt"}, {"type": "update", "anon": "no", "when": "2017-04-01T13:36:00Z", "data": "j0zawt4bu9c113", "uid": "hcrrjuyequh4bt"}, {"type": "update", "anon": "no", "when": "2017-04-30T14:58:22Z", "data": "j24tmfaxnq34gn", "uid": "hcrrjuyequh4bt"}, {"type": "update", "anon": "no", "when": "2017-04-30T15:01:20Z", "data": "j24tq8fo5a1682", "uid": "hcrrjuyequh4bt"}, {"type": "update", "anon": "no", "when": "2017-04-30T15:03:03Z", "data": "j24tsg3728l76i", "uid": "hcrrjuyequh4bt"}, {"type": "update", "anon": "no", "when": "2017-05-12T01:34:15Z", "data": "j2l66k5wusk5e5", "uid": "hcrrjuyequh4bt"}], "upvote_ids": [], "id": "j0zargqmph781", "bookmarked": 4, "tags": ["instructor-note", "lecture1", "lecture10", "lecture11", "lecture12", "lecture13", "lecture14", "lecture15", "lecture16", "lecture17", "lecture18", "lecture19", "lecture2", "lecture20", "lecture21", "lecture22", "lecture23", "lecture3", "lecture4", "lecture5", "lecture6", "lecture7", "lecture8", "lecture9", "pin"], "i_edits": [], "is_bookmarked": false, "children": [], "nr": 1030, "bucket_order": 0, "type": "note", "folders": ["lecture1", "lecture2", "lecture3", "lecture4", "lecture5", "lecture6", "lecture7", "lecture8", "lecture9", "lecture10", "lecture11", "lecture12", "lecture13", "lecture14", "lecture15", "lecture16", "lecture17", "lecture18", "lecture19", "lecture20", "lecture21", "lecture22", "lecture23"], "no_answer_followup": 0, "num_favorites": 0, "bucket_name": "Pinned", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2017-04-01T13:31:51Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1494828961972, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>lec21-23</p>\n<p>===============</p>\n<p>1 完成Simple File System的功能&#xff0c;支持应用程序的一般文件操作。具体帮助和要求信息请看sfs-homework &#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab8/sfs-homework.md&#xff09;<br /><br />2 &#xff08;不用提交&#xff09;理解文件访问的执行过程&#xff0c;即在ucore运行过程中通过cprintf函数来完整地展现出来读一个文件在ucore中的整个执行过程。可自行编程实现。<br /><br />3 (不用提交) ZFS、YAFFS这两种文件系统中选一种&#xff0c;分析它的文件卷结构、目录结构、文件分配方式&#xff0c;以及它的变种。<br /><br />4 &#xff08;不用提交&#xff09;理解下列磁盘调度算法的工作原理&#xff0c;并能够用下列算法进行推演<br /><br />    先进先出(FIFO)磁盘调度算法<br />    最短寻道时间优先(SSTF)磁盘调度算法<br />    扫描(SCAN)磁盘调度算法<br />    循环扫描(C-SCAN)磁盘调度算法<br />    C-LOOK磁盘调度算法<br />    N步扫描(N-step-SCAN)磁盘调度算法<br />    双队列扫描(FSCAN)磁盘调度算法<br /><br />5 完成磁盘访问与磁盘寻道算法的作业&#xff0c;具体帮助和要求信息请看disksim指导信息&#xff08;https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8/disksim-homework.md&#xff09;和disksim参考代码&#xff08;https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8/disksim-homework.py&#xff09;<br /><br />6 &#xff08;不用提交&#xff09;    磁盘缓存的作用是什么&#xff1f;<br />    请描述单缓存(Single Buffer Cache)的工作原理<br />    请描述双缓存(Double Buffer Cache)的工作原理<br />    请描述访问频率置换算法(Frequency-based Replacement)的基本原理</p>\n<p></p>\n<p>lec20</p>\n<p>===============</p>\n<p>1  用python实现银行家算法(https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab7/deadlock/bankers-homework.py)。大致输出可参考参考输出(https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab7/deadlock/example-output.txt)。除了YOUR CODE部分需要填写代码外&#xff0c;在算法的具体实现上&#xff0c;效率也不高&#xff0c;可进一步改进执行效率。<br /><br />2  描述signal, pipe的实现机制&#xff0c;描述signal的三种处理方式。编写一个Linux app&#xff1a;父进程创建了3个子进程&#xff0c;3个子进程通过pipe机制给父进程分别发送了3个128Byte的数据&#xff0c;父进程在收到这3个数据后&#xff0c;通过signal机制分别通知子进程&#xff0c;子进程/OS分别用signal的三种处理方式来响应。<br /><br />Linux的pipe, signal等相关编程/原理信息在网上有很多&#xff0c;下面是一些参考&#xff1a;<br />https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab7/ipc/signal-ex1.c<br />http://blog.csdn.net/vc0051127833/article/details/7658799<br />http://www.cnblogs.com/taobataoma/archive/2007/08/30/875743.html<br />https://www.hitoy.org/pipe-aplication-in-linux.html<br />http://ryanstutorials.net/linuxtutorial/piping.php</p>\n<p></p>\n<p>lec19</p>\n<p>===============</p>\n<p>请每人按时认真独立完成如下网页中的习题<br />https://github.com/chyyuu/os_course_exercises/blob/master/all/07-2-spoc-pv-problems.md<br /><br />下面是列出的题号和要独立完成的学生名单。要求用C语言&#xff0c;基于semaphore和monitor两种方式实现同步互斥问题&#xff0c;并提供测试用例和README&#xff0c;说明你实现的设计和结果分析<br />一个可以参考的实现例子请看 <a href=\"https://github.com/chyyuu/os_tutorial_lab/tree/master/knowledge_points/semaphore-vs-monitor\">https://github.com/chyyuu/os_tutorial_lab/tree/master/knowledge_points/semaphore-vs-monitor</a></p>\n<p></p>\n<p>lec18</p>\n<p>===============</p>\n<p>注意&#xff1a;下面的问题不需要提交&#xff0c;但需要认真理解和完成.<br /><br />1. 信号量在ucore中的具体实现与课程上的原理实现的差别在哪里&#xff1f;请给出差异性分析<br />2. 信号量在实现软件同步和软件互斥上的一般使用模式&#xff08;pattern&#xff09;是什么&#xff1f;<br />3. 管程的组成包括哪几部分&#xff1f;入口队列和条件变量等待队列的作用是什么&#xff1f;<br />4. 请描述管程条件变量的三种释放处理方式的区别是什么&#xff1f;条件判断中while和if是如何影响释放处理中的顺序的&#xff1f;<br />5. 请理解管程和信号量在实现生产者-消费者问题上的差异。<br />6. 对于 https://github.com/chyyuu/os_course_exercises/blob/master/all/07-2-spoc-pv-problems.md 中的同步互斥问题&#xff0c;使用C&#43;&#43;或python语言用信号量和管程两种手段分别实现。建议一个班的同学每人做两题&#xff0c;并组织讨论交流&#xff0c;这样班上同学可实现对这些问题的全覆盖。</p>\n<p></p>\n<p>lec17</p>\n<p>===============</p>\n<p>1  在报告中通过枚举和分类方法或反证法说明Peterson算法的正确性。<br /><br />参考&#xff1a;<br />https://en.wikipedia.org/wiki/Peterson%27s_algorithm<br />https://en.wikipedia.org/wiki/Dekker%27s_algorithm<br /><br />2  在报告中准确描述Eisenberg同步算法&#xff0c;并通过枚举和分类方法或反证法说明说明Eisenberg同步算法的正确性。用C或PYTHON实现Eisenberg同步算法和测试用例。在报告中给出测试结果简单描述。<br /><br />参考&#xff1a;<br />https://en.wikipedia.org/wiki/Eisenberg_%26_McGuire_algorithm<br />https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm<br />piazza.com的本课程网页中&#xff0c;搜索“Eisenberg”&#xff0c;可看到3个相关帖子集合<br /><br />下面的练习不用提交&#xff0c;但请通过个人或同学间讨论等形式认真完成&#xff1a;<br />https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-quiz.html<br />https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-spoc-discussion.html 中的“17.4 基于软件的同步方法”小节中的4~12题。</p>\n<p></p>\n<p></p>\n<p>lec16</p>\n<p>===============</p>\n<p>1  请描述stride调度算法的目标&#xff0c;思路和算法设计&#xff08;要求写出伪代码&#xff09;&#xff0c;并分析stride调度算法只采用整数运算是如何避免stride计算溢出问题的。<br />1. &#xff08;扩展&#xff0c;感兴趣的同学可试试&#xff09;分析/理解/运行/测试 https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep10-lottery.md https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep10-lottery.py 写出你的实验过程和你对其设计实现的理解。尝试实现stride.py并给出实现说明  <br /> <br />2(不用提交) 理解一个操作系统调度的时机有哪些。<br />3(不用提交) 理解课堂讲述的调度算法哪些是可抢占的&#xff0c;哪些是不可抢占的。<br />4(不用提交) 理解课堂讲述的调度算法哪些是动态调度算法&#xff0c;哪些是静态调度算法。<br />5(不用提交) 思考如何实现MLFQ&#xff1f;特别是如何动态调整进程优先级&#xff1f;<br />6(不用提交) FIFO调度算法的实现是否需要中断机制&#xff1f;其他调度算法呢&#xff1f;<br />7(不用提交) 理解在存在两个用户进程的情况下&#xff0c;ucore的调度时机和进程切换的完整过程<br />8(不用提交) 理解实时操作系统的特征&#xff0c;实时调度算法的基本思路&#xff0c;特点<br />9(不用提交) 理解优先级反置问题和解决方法。火星探路者碰到的类似问题是啥&#xff1f;如何发现和解决的&#xff1f;<br />10(不用提交)  理解ucore调度算法支撑框架的执行过程<br />11(不用提交) 理解SMP&#xff0c;AMP, MC的含义与区别</p>\n<p></p>\n<p></p>\n<p></p>\n<p>lec15</p>\n<p>===============</p>\n<p>1 请证明短进程优先算法具有最小平均周转时间。<br /> <br />2(不用提交) 通过观察FIFO、SJF和RR调度算法的模拟程序(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep8-scheduler.py)运行结果及其描述文档(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep8-scheduler.md)&#xff0c;理解其工作原理和算法特征。<br /><br />3(不用提交) 通过观察MLFQ调度算法的模拟程序(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep9-mlfq.py)运行结果及其描述文档(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep9-mlfq.md)&#xff0c;理解其工作原理和算法特征。</p>\n<p></p>\n<p></p>\n<p>lec13&amp;14</p>\n<p>===============</p>\n<p>https://github.com/chyyuu/os_course_exercises/blob/master/all/05-4-lab5-spoc-discussion.md<br />中的小组练习与思考题 第二题<br />(2)(spoc) 理解用户进程的生命周期。<br />需写练习报告和简单编码&#xff0c;完成后放到网络学堂<br />要求提供代码和报告</p>\n<p></p>\n<p></p>\n<p>lec12</p>\n<p>=============</p>\n<p>1&#xff08;不用回答&#xff09;理解 孤儿进程和僵死进程的含义<br />http://www.cnblogs.com/xiehongfeng100/p/4619913.html<br />http://www.cnblogs.com/Anker/p/3271773.html<br />https://piazza.com/class/i5j09fnsl7k5x0?cid=753<br /><br />2&#xff08;不用回答&#xff09;理解ucore进程控制块proc_struct数据结构内容和大致含义<br /><br />3&#xff08;不用回答&#xff09;理解fork和execv的实现机制<br /><br />4&#xff08;不用回答&#xff09;理解COW的实现机制<br />http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html <br /><br />5 请仔细阅读https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-2-spoc-discussion.html 中的小组思考题<br /><br />设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab5/process-cpuio-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容&#xff0e;</p>\n<p></p>\n<p></p>\n<p>lec10&amp;11</p>\n<p>=============</p>\n<p>1 以lab3为例&#xff0c;说明虚拟页与磁盘后备页面的对应关系是什么&#xff1f;<br />2 &#xff08;不用回答&#xff09;以lab4为例&#xff0c;理解保存现场和恢复现场&#xff1a; lab4/kern/process/switch.S <br />3 &#xff08;不用回答&#xff09;理解进程的各种状态和各种状态间的转换的起因。<br />4 由于何种原因&#xff0c;可出现进程的何种状态转到退出状态&#xff1f;<br />5 请设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容。<br />6 &#xff08;不用回答&#xff09;请了解实际操作系统Linux的各种状态和各种状态间的转换的起因。<br />7 (不用回答)请了解实际操作系统Linux的进程控制块PCB数据结构 task_struct</p>\n<p></p>\n<p>lec9</p>\n<p>=============</p>\n<p>1. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用最优置换算法的缺页次数为&#xff08;&#xff09;<br /><br />2. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用FIFO置换算法的缺页次数为&#xff08;&#xff09;<br /><br />3.物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用1个bit表示存在时间&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />4. 物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用2个关联&#xff0c;bit表示存在时间,可以表示4,&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />https://github.com/chyyuu/os_course_exercises/blob/master/all/04-2-spoc-discussion.md#小组思考题目<br />的第一和第二道题目<br /><br />5.&#xff08;spoc&#xff09;根据你的学号 mod 4的结果值&#xff0c;确定选择四种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff0c;2&#xff1a;工作集页置换算法&#xff0c;3&#xff1a;缺页率置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如python代码或独自实现。<br /><br />页置换算法实现的参考实例 &#xff08; https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab3/page-replacement-policy.py &#xff09;<br /><br />6. 请判断OPT、LRU、FIFO、Clock和LFU等各页面置换算法是否存在Belady现象&#xff1f;如果存在&#xff0c;给出实例&#xff1b;如果不存在&#xff0c;给出证明。<br /><br /></p>\n<p></p>\n<p>lec8</p>\n<p>=============<br />04-1-spoc-discussion.md <br />的个人思考题&#xff0c;小组思考题(1)(2)(3)</p>\n<p></p>\n<p></p>\n<p>#pin</p>", "anon": "no", "created": "2017-05-12T01:34:15Z", "uid": "hcrrjuyequh4bt", "subject": "课后练习"}, {"content": "<p>lec18</p>\n<p>===============</p>\n<p>注意&#xff1a;下面的问题不需要提交&#xff0c;但需要认真理解和完成.<br /><br />1. 信号量在ucore中的具体实现与课程上的原理实现的差别在哪里&#xff1f;请给出差异性分析<br />2. 信号量在实现软件同步和软件互斥上的一般使用模式&#xff08;pattern&#xff09;是什么&#xff1f;<br />3. 管程的组成包括哪几部分&#xff1f;入口队列和条件变量等待队列的作用是什么&#xff1f;<br />4. 请描述管程条件变量的三种释放处理方式的区别是什么&#xff1f;条件判断中while和if是如何影响释放处理中的顺序的&#xff1f;<br />5. 请理解管程和信号量在实现生产者-消费者问题上的差异。<br />6. 对于 https://github.com/chyyuu/os_course_exercises/blob/master/all/07-2-spoc-pv-problems.md 中的同步互斥问题&#xff0c;使用C&#43;&#43;或python语言用信号量和管程两种手段分别实现。建议一个班的同学每人做两题&#xff0c;并组织讨论交流&#xff0c;这样班上同学可实现对这些问题的全覆盖。</p>\n<p></p>\n<p>lec17</p>\n<p>===============</p>\n<p>1  在报告中通过枚举和分类方法或反证法说明Peterson算法的正确性。<br /><br />参考&#xff1a;<br />https://en.wikipedia.org/wiki/Peterson%27s_algorithm<br />https://en.wikipedia.org/wiki/Dekker%27s_algorithm<br /><br />2  在报告中准确描述Eisenberg同步算法&#xff0c;并通过枚举和分类方法或反证法说明说明Eisenberg同步算法的正确性。用C或PYTHON实现Eisenberg同步算法和测试用例。在报告中给出测试结果简单描述。<br /><br />参考&#xff1a;<br />https://en.wikipedia.org/wiki/Eisenberg_%26_McGuire_algorithm<br />https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm<br />piazza.com的本课程网页中&#xff0c;搜索“Eisenberg”&#xff0c;可看到3个相关帖子集合<br /><br />下面的练习不用提交&#xff0c;但请通过个人或同学间讨论等形式认真完成&#xff1a;<br />https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-quiz.html<br />https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-spoc-discussion.html 中的“17.4 基于软件的同步方法”小节中的4~12题。</p>\n<p></p>\n<p></p>\n<p>lec16</p>\n<p>===============</p>\n<p>1  请描述stride调度算法的目标&#xff0c;思路和算法设计&#xff08;要求写出伪代码&#xff09;&#xff0c;并分析stride调度算法只采用整数运算是如何避免stride计算溢出问题的。<br />1. &#xff08;扩展&#xff0c;感兴趣的同学可试试&#xff09;分析/理解/运行/测试 https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep10-lottery.md https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep10-lottery.py 写出你的实验过程和你对其设计实现的理解。尝试实现stride.py并给出实现说明  <br /> <br />2(不用提交) 理解一个操作系统调度的时机有哪些。<br />3(不用提交) 理解课堂讲述的调度算法哪些是可抢占的&#xff0c;哪些是不可抢占的。<br />4(不用提交) 理解课堂讲述的调度算法哪些是动态调度算法&#xff0c;哪些是静态调度算法。<br />5(不用提交) 思考如何实现MLFQ&#xff1f;特别是如何动态调整进程优先级&#xff1f;<br />6(不用提交) FIFO调度算法的实现是否需要中断机制&#xff1f;其他调度算法呢&#xff1f;<br />7(不用提交) 理解在存在两个用户进程的情况下&#xff0c;ucore的调度时机和进程切换的完整过程<br />8(不用提交) 理解实时操作系统的特征&#xff0c;实时调度算法的基本思路&#xff0c;特点<br />9(不用提交) 理解优先级反置问题和解决方法。火星探路者碰到的类似问题是啥&#xff1f;如何发现和解决的&#xff1f;<br />10(不用提交)  理解ucore调度算法支撑框架的执行过程<br />11(不用提交) 理解SMP&#xff0c;AMP, MC的含义与区别</p>\n<p></p>\n<p></p>\n<p></p>\n<p>lec15</p>\n<p>===============</p>\n<p>1 请证明短进程优先算法具有最小平均周转时间。<br /> <br />2(不用提交) 通过观察FIFO、SJF和RR调度算法的模拟程序(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep8-scheduler.py)运行结果及其描述文档(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep8-scheduler.md)&#xff0c;理解其工作原理和算法特征。<br /><br />3(不用提交) 通过观察MLFQ调度算法的模拟程序(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep9-mlfq.py)运行结果及其描述文档(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep9-mlfq.md)&#xff0c;理解其工作原理和算法特征。</p>\n<p></p>\n<p></p>\n<p>lec13&amp;14</p>\n<p>===============</p>\n<p>https://github.com/chyyuu/os_course_exercises/blob/master/all/05-4-lab5-spoc-discussion.md<br />中的小组练习与思考题 第二题<br />(2)(spoc) 理解用户进程的生命周期。<br />需写练习报告和简单编码&#xff0c;完成后放到网络学堂<br />要求提供代码和报告</p>\n<p></p>\n<p></p>\n<p>lec12</p>\n<p>=============</p>\n<p>1&#xff08;不用回答&#xff09;理解 孤儿进程和僵死进程的含义<br />http://www.cnblogs.com/xiehongfeng100/p/4619913.html<br />http://www.cnblogs.com/Anker/p/3271773.html<br />https://piazza.com/class/i5j09fnsl7k5x0?cid=753<br /><br />2&#xff08;不用回答&#xff09;理解ucore进程控制块proc_struct数据结构内容和大致含义<br /><br />3&#xff08;不用回答&#xff09;理解fork和execv的实现机制<br /><br />4&#xff08;不用回答&#xff09;理解COW的实现机制<br />http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html <br /><br />5 请仔细阅读https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-2-spoc-discussion.html 中的小组思考题<br /><br />设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab5/process-cpuio-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容&#xff0e;</p>\n<p></p>\n<p></p>\n<p>lec10&amp;11</p>\n<p>=============</p>\n<p>1 以lab3为例&#xff0c;说明虚拟页与磁盘后备页面的对应关系是什么&#xff1f;<br />2 &#xff08;不用回答&#xff09;以lab4为例&#xff0c;理解保存现场和恢复现场&#xff1a; lab4/kern/process/switch.S <br />3 &#xff08;不用回答&#xff09;理解进程的各种状态和各种状态间的转换的起因。<br />4 由于何种原因&#xff0c;可出现进程的何种状态转到退出状态&#xff1f;<br />5 请设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容。<br />6 &#xff08;不用回答&#xff09;请了解实际操作系统Linux的各种状态和各种状态间的转换的起因。<br />7 (不用回答)请了解实际操作系统Linux的进程控制块PCB数据结构 task_struct</p>\n<p></p>\n<p>lec9</p>\n<p>=============</p>\n<p>1. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用最优置换算法的缺页次数为&#xff08;&#xff09;<br /><br />2. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用FIFO置换算法的缺页次数为&#xff08;&#xff09;<br /><br />3.物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用1个bit表示存在时间&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />4. 物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用2个关联&#xff0c;bit表示存在时间,可以表示4,&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />https://github.com/chyyuu/os_course_exercises/blob/master/all/04-2-spoc-discussion.md#小组思考题目<br />的第一和第二道题目<br /><br />5.&#xff08;spoc&#xff09;根据你的学号 mod 4的结果值&#xff0c;确定选择四种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff0c;2&#xff1a;工作集页置换算法&#xff0c;3&#xff1a;缺页率置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如python代码或独自实现。<br /><br />页置换算法实现的参考实例 &#xff08; https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab3/page-replacement-policy.py &#xff09;<br /><br />6. 请判断OPT、LRU、FIFO、Clock和LFU等各页面置换算法是否存在Belady现象&#xff1f;如果存在&#xff0c;给出实例&#xff1b;如果不存在&#xff0c;给出证明。<br /><br /></p>\n<p></p>\n<p>lec8</p>\n<p>=============<br />04-1-spoc-discussion.md <br />的个人思考题&#xff0c;小组思考题(1)(2)(3)</p>\n<p></p>\n<p></p>\n<p>#pin</p>", "anon": "no", "created": "2017-04-30T15:03:03Z", "uid": "hcrrjuyequh4bt", "subject": "课后练习"}, {"content": "<p>lec18</p>\n<p>===============</p>\n<p>注意&#xff1a;下面的问题不需要提交&#xff0c;但需要认真理解和完成.<br /><br />1. 信号量在ucore中的具体实现与课程上的原理实现的差别在哪里&#xff1f;请给出差异性分析<br />2. 信号量在实现软件同步和软件互斥上的一般使用模式&#xff08;pattern&#xff09;是什么&#xff1f;<br />3. 管程的组成包括哪几部分&#xff1f;入口队列和条件变量等待队列的作用是什么&#xff1f;<br />4. 请描述管程条件变量的三种释放处理方式的区别是什么&#xff1f;条件判断中while和if是如何影响释放处理中的顺序的&#xff1f;<br />5. 请理解管程和信号量在实现生产者-消费者问题上的差异。<br />6. 对于 https://github.com/chyyuu/os_course_exercises/blob/master/all/07-2-spoc-pv-problems.md 中的同步互斥问题&#xff0c;使用C&#43;&#43;或python语言用信号量和管程两种手段分别实现。建议一个班的同学每人做两题&#xff0c;并组织讨论交流&#xff0c;这样班上同学可实现对这些问题的全覆盖。</p>\n<p></p>\n<p>lec17</p>\n<p>===============</p>\n<p>1  在报告中通过枚举和分类方法或反证法说明Peterson算法的正确性。<br /><br />参考&#xff1a;<br />https://en.wikipedia.org/wiki/Peterson%27s_algorithm<br />https://en.wikipedia.org/wiki/Dekker%27s_algorithm<br /><br />2  在报告中准确描述Eisenberg同步算法&#xff0c;并通过枚举和分类方法或反证法说明说明Eisenberg同步算法的正确性。用C或PYTHON实现Eisenberg同步算法和测试用例。在报告中给出测试结果简单描述。<br /><br />参考&#xff1a;<br />https://en.wikipedia.org/wiki/Eisenberg_%26_McGuire_algorithm<br />https://en.wikipedia.org/wiki/Lamport%27s_bakery_algorithm<br />piazza.com的本课程网页中&#xff0c;搜索“Eisenberg”&#xff0c;可看到3个相关帖子集合<br /><br />下面的练习不用提交&#xff0c;但请通过个人或同学间讨论等形式认真完成&#xff1a;<br />https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-quiz.html<br />https://chyyuu.gitbooks.io/os_course_exercises/content/all/07-1-spoc-discussion.html 中的“17.4 基于软件的同步方法”小节中的4~12题。</p>\n<p></p>\n<p></p>\n<p>lec16</p>\n<p>===============</p>\n<p>1  请描述stride调度算法的目标&#xff0c;思路和算法设计&#xff08;要求写出伪代码&#xff09;&#xff0c;并分析stride调度算法只采用整数运算是如何避免stride计算溢出问题的。<br />1. &#xff08;扩展&#xff0c;感兴趣的同学可试试&#xff09;分析/理解/运行/测试 https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep10-lottery.md https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep10-lottery.py 写出你的实验过程和你对其设计实现的理解。尝试实现stride.py并给出实现说明  <br /> <br />2(不用提交) 理解一个操作系统调度的时机有哪些。<br />3(不用提交) 理解课堂讲述的调度算法哪些是可抢占的&#xff0c;哪些是不可抢占的。<br />4(不用提交) 理解课堂讲述的调度算法哪些是动态调度算法&#xff0c;哪些是静态调度算法。<br />5(不用提交) 思考如何实现MLFQ&#xff1f;特别是如何动态调整进程优先级&#xff1f;<br />6(不用提交) FIFO调度算法的实现是否需要中断机制&#xff1f;其他调度算法呢&#xff1f;<br />7(不用提交) 理解在存在两个用户进程的情况下&#xff0c;ucore的调度时机和进程切换的完整过程<br />8(不用提交) 理解实时操作系统的特征&#xff0c;实时调度算法的基本思路&#xff0c;特点<br />9(不用提交) 理解优先级反置问题和解决方法。火星探路者碰到的类似问题是啥&#xff1f;如何发现和解决的&#xff1f;<br />10(不用提交)  理解ucore调度算法支撑框架的执行过程<br />11(不用提交) 理解SMP&#xff0c;AMP, MC的含义与区别</p>\n<p></p>\n<p></p>\n<p></p>\n<p>lec15</p>\n<p>===============</p>\n<p>1 请证明短进程优先算法具有最小平均周转时间。<br /> <br />2(不用提交) 通过观察FIFO、SJF和RR调度算法的模拟程序(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep8-scheduler.py)运行结果及其描述文档(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep8-scheduler.md)&#xff0c;理解其工作原理和算法特征。<br /><br />3(不用提交) 通过观察MLFQ调度算法的模拟程序(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep9-mlfq.py)运行结果及其描述文档(https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep9-mlfq.md)&#xff0c;理解其工作原理和算法特征。</p>\n<p></p>\n<p></p>\n<p>lec13&amp;14</p>\n<p>===============</p>\n<p>https://github.com/chyyuu/os_course_exercises/blob/master/all/05-4-lab5-spoc-discussion.md<br />中的小组练习与思考题 第二题<br />(2)(spoc) 理解用户进程的生命周期。<br />需写练习报告和简单编码&#xff0c;完成后放到网络学堂<br />要求提供代码和报告</p>\n<p></p>\n<p></p>\n<p>lec12</p>\n<p>=============</p>\n<p>1&#xff08;不用回答&#xff09;理解 孤儿进程和僵死进程的含义<br />http://www.cnblogs.com/xiehongfeng100/p/4619913.html<br />http://www.cnblogs.com/Anker/p/3271773.html<br />https://piazza.com/class/i5j09fnsl7k5x0?cid=753<br /><br />2&#xff08;不用回答&#xff09;理解ucore进程控制块proc_struct数据结构内容和大致含义<br /><br />3&#xff08;不用回答&#xff09;理解fork和execv的实现机制<br /><br />4&#xff08;不用回答&#xff09;理解COW的实现机制<br />http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html <br /><br />5 请仔细阅读https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-2-spoc-discussion.html 中的小组思考题<br /><br />设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab5/process-cpuio-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容&#xff0e;</p>\n<p></p>\n<p></p>\n<p>lec10&amp;11</p>\n<p>=============</p>\n<p>1 以lab3为例&#xff0c;说明虚拟页与磁盘后备页面的对应关系是什么&#xff1f;<br />2 &#xff08;不用回答&#xff09;以lab4为例&#xff0c;理解保存现场和恢复现场&#xff1a; lab4/kern/process/switch.S <br />3 &#xff08;不用回答&#xff09;理解进程的各种状态和各种状态间的转换的起因。<br />4 由于何种原因&#xff0c;可出现进程的何种状态转到退出状态&#xff1f;<br />5 请设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容。<br />6 &#xff08;不用回答&#xff09;请了解实际操作系统Linux的各种状态和各种状态间的转换的起因。<br />7 (不用回答)请了解实际操作系统Linux的进程控制块PCB数据结构 task_struct</p>\n<p></p>\n<p>lec9</p>\n<p>=============</p>\n<p>1. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用最优置换算法的缺页次数为&#xff08;&#xff09;<br /><br />2. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用FIFO置换算法的缺页次数为&#xff08;&#xff09;<br /><br />3.物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用1个bit表示存在时间&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />4. 物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用2个关联&#xff0c;bit表示存在时间,可以表示4,&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />https://github.com/chyyuu/os_course_exercises/blob/master/all/04-2-spoc-discussion.md#小组思考题目<br />的第一和第二道题目<br /><br />5.&#xff08;spoc&#xff09;根据你的学号 mod 4的结果值&#xff0c;确定选择四种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff0c;2&#xff1a;工作集页置换算法&#xff0c;3&#xff1a;缺页率置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如python代码或独自实现。<br /><br />页置换算法实现的参考实例 &#xff08; https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab3/page-replacement-policy.py &#xff09;<br /><br />6. 请判断OPT、LRU、FIFO、Clock和LFU等各页面置换算法是否存在Belady现象&#xff1f;如果存在&#xff0c;给出实例&#xff1b;如果不存在&#xff0c;给出证明。<br /><br /></p>\n<p></p>\n<p>lec8</p>\n<p>=============<br />04-1-spoc-discussion.md <br />的个人思考题&#xff0c;小组思考题(1)(2)(3)</p>\n<p></p>\n<p></p>\n<p>#pin</p>", "anon": "no", "created": "2017-04-30T15:01:20Z", "uid": "hcrrjuyequh4bt", "subject": "部分课后练习"}, {"content": "<p></p>\n<p>lec12</p>\n<p>=============</p>\n<p>1&#xff08;不用回答&#xff09;理解 孤儿进程和僵死进程的含义<br />http://www.cnblogs.com/xiehongfeng100/p/4619913.html<br />http://www.cnblogs.com/Anker/p/3271773.html<br />https://piazza.com/class/i5j09fnsl7k5x0?cid=753<br /><br />2&#xff08;不用回答&#xff09;理解ucore进程控制块proc_struct数据结构内容和大致含义<br /><br />3&#xff08;不用回答&#xff09;理解fork和execv的实现机制<br /><br />4&#xff08;不用回答&#xff09;理解COW的实现机制<br />http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html <br /><br />5 请仔细阅读https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-2-spoc-discussion.html 中的小组思考题<br /><br />设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab5/process-cpuio-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容&#xff0e;</p>\n<p></p>\n<p></p>\n<p>lec10&amp;11</p>\n<p>=============</p>\n<p>1 以lab3为例&#xff0c;说明虚拟页与磁盘后备页面的对应关系是什么&#xff1f;<br />2 &#xff08;不用回答&#xff09;以lab4为例&#xff0c;理解保存现场和恢复现场&#xff1a; lab4/kern/process/switch.S <br />3 &#xff08;不用回答&#xff09;理解进程的各种状态和各种状态间的转换的起因。<br />4 由于何种原因&#xff0c;可出现进程的何种状态转到退出状态&#xff1f;<br />5 请设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容。<br />6 &#xff08;不用回答&#xff09;请了解实际操作系统Linux的各种状态和各种状态间的转换的起因。<br />7 (不用回答)请了解实际操作系统Linux的进程控制块PCB数据结构 task_struct</p>\n<p></p>\n<p>lec9</p>\n<p>=============</p>\n<p>1. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用最优置换算法的缺页次数为&#xff08;&#xff09;<br /><br />2. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用FIFO置换算法的缺页次数为&#xff08;&#xff09;<br /><br />3.物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用1个bit表示存在时间&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />4. 物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用2个关联&#xff0c;bit表示存在时间,可以表示4,&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />https://github.com/chyyuu/os_course_exercises/blob/master/all/04-2-spoc-discussion.md#小组思考题目<br />的第一和第二道题目<br /><br />5.&#xff08;spoc&#xff09;根据你的学号 mod 4的结果值&#xff0c;确定选择四种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff0c;2&#xff1a;工作集页置换算法&#xff0c;3&#xff1a;缺页率置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如python代码或独自实现。<br /><br />页置换算法实现的参考实例 &#xff08; https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab3/page-replacement-policy.py &#xff09;<br /><br />6. 请判断OPT、LRU、FIFO、Clock和LFU等各页面置换算法是否存在Belady现象&#xff1f;如果存在&#xff0c;给出实例&#xff1b;如果不存在&#xff0c;给出证明。<br /><br /></p>\n<p></p>\n<p>lec8</p>\n<p>=============<br />04-1-spoc-discussion.md <br />的个人思考题&#xff0c;小组思考题(1)(2)(3)</p>\n<p></p>\n<p></p>\n<p>#pin</p>", "anon": "no", "created": "2017-04-30T14:58:22Z", "uid": "hcrrjuyequh4bt", "subject": "部分课后练习"}, {"content": "<p>lec12</p>\n<p>=============</p>\n<p>1&#xff08;不用回答&#xff09;理解 孤儿进程和僵死进程的含义<br />http://www.cnblogs.com/xiehongfeng100/p/4619913.html<br />http://www.cnblogs.com/Anker/p/3271773.html<br />https://piazza.com/class/i5j09fnsl7k5x0?cid=753<br /><br />2&#xff08;不用回答&#xff09;理解ucore进程控制块proc_struct数据结构内容和大致含义<br /><br />3&#xff08;不用回答&#xff09;理解fork和execv的实现机制<br /><br />4&#xff08;不用回答&#xff09;理解COW的实现机制<br />http://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html <br /><br />5 请仔细阅读https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-2-spoc-discussion.html 中的小组思考题<br /><br />设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab5/process-cpuio-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容&#xff0e;</p>\n<p></p>\n<p></p>\n<p>lec10&amp;11</p>\n<p>=============</p>\n<p>1 以lab3为例&#xff0c;说明虚拟页与磁盘后备页面的对应关系是什么&#xff1f;<br />2 &#xff08;不用回答&#xff09;以lab4为例&#xff0c;理解保存现场和恢复现场&#xff1a; lab4/kern/process/switch.S <br />3 &#xff08;不用回答&#xff09;理解进程的各种状态和各种状态间的转换的起因。<br />4 由于何种原因&#xff0c;可出现进程的何种状态转到退出状态&#xff1f;<br />5 请设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容。<br />6 &#xff08;不用回答&#xff09;请了解实际操作系统Linux的各种状态和各种状态间的转换的起因。<br />7 (不用回答)请了解实际操作系统Linux的进程控制块PCB数据结构 task_struct</p>\n<p></p>\n<p>lec9</p>\n<p>=============</p>\n<p>1. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用最优置换算法的缺页次数为&#xff08;&#xff09;<br /><br />2. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用FIFO置换算法的缺页次数为&#xff08;&#xff09;<br /><br />3.物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用1个bit表示存在时间&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />4. 物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用2个关联&#xff0c;bit表示存在时间,可以表示4,&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />https://github.com/chyyuu/os_course_exercises/blob/master/all/04-2-spoc-discussion.md#小组思考题目<br />的第一和第二道题目<br /><br />5.&#xff08;spoc&#xff09;根据你的学号 mod 4的结果值&#xff0c;确定选择四种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff0c;2&#xff1a;工作集页置换算法&#xff0c;3&#xff1a;缺页率置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如python代码或独自实现。<br /><br />页置换算法实现的参考实例 &#xff08; https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab3/page-replacement-policy.py &#xff09;<br /><br />6. 请判断OPT、LRU、FIFO、Clock和LFU等各页面置换算法是否存在Belady现象&#xff1f;如果存在&#xff0c;给出实例&#xff1b;如果不存在&#xff0c;给出证明。<br /><br /></p>\n<p></p>\n<p>lec8</p>\n<p>=============<br />04-1-spoc-discussion.md <br />的个人思考题&#xff0c;小组思考题(1)(2)(3)</p>", "anon": "no", "created": "2017-04-01T13:36:00Z", "uid": "hcrrjuyequh4bt", "subject": "部分课后练习"}, {"content": "<p>lec12</p>\n<p>=============</p>\n<p>1&#xff08;不用回答&#xff09;理解 孤儿进程和僵死进程的含义<br />http://www.cnblogs.com/xiehongfeng100/p/4619913.html<br />http://www.cnblogs.com/Anker/p/3271773.html<br />https://piazza.com/class/i5j09fnsl7k5x0?cid=753<br /><br />2&#xff08;不用回答&#xff09;理解ucore进程控制块proc_struct数据结构内容和大致含义<br /><br />3&#xff08;不用回答&#xff09;理解fork和execv的实现机制<br /><br />4 请仔细阅读https://chyyuu.gitbooks.io/os_course_exercises/content/all/05-2-spoc-discussion.html 中的小组思考题<br /><br />设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab5/process-cpuio-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容&#xff0e;</p>\n<p></p>\n<p></p>\n<p>lec10&amp;11</p>\n<p>=============</p>\n<p>1 以lab3为例&#xff0c;说明虚拟页与磁盘后备页面的对应关系是什么&#xff1f;<br />2 &#xff08;不用回答&#xff09;以lab4为例&#xff0c;理解保存现场和恢复现场&#xff1a; lab4/kern/process/switch.S <br />3 &#xff08;不用回答&#xff09;理解进程的各种状态和各种状态间的转换的起因。<br />4 由于何种原因&#xff0c;可出现进程的何种状态转到退出状态&#xff1f;<br />5 请设计一个简化的进程管理子系统&#xff0c;可以管理并调度如下简化进程.给出了参考代码&#xff08;https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab4/process-concept-homework.py&#xff09;&#xff0c;请理解代码&#xff0c;并完成&#xff02;YOUR CODE&#34;部分的内容。<br />6 &#xff08;不用回答&#xff09;请了解实际操作系统Linux的各种状态和各种状态间的转换的起因。<br />7 (不用回答)请了解实际操作系统Linux的进程控制块PCB数据结构 task_struct </p>\n<p></p>\n<p>lec9</p>\n<p>=============</p>\n<p>1. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用最优置换算法的缺页次数为&#xff08;&#xff09;<br /><br />2. 物理页帧数量为3&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,1,2,0,1,3,0,3,1,0,3&#xff0c;请问采用FIFO置换算法的缺页次数为&#xff08;&#xff09;<br /><br />3.物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用1个bit表示存在时间&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />4. 物理页帧数量为4&#xff0c;且初始时没有对应的虚拟页。虚拟页访问序列为 0,3,2,0,1,3,4,3,1,0,3,2,1,3,4 &#xff0c;请问采用CLOCK置换算法&#xff08;用2个关联&#xff0c;bit表示存在时间,可以表示4,&#xff09;的缺页次数为&#xff08;&#xff09;<br /><br />https://github.com/chyyuu/os_course_exercises/blob/master/all/04-2-spoc-discussion.md#小组思考题目<br />的第一和第二道题目<br /><br />5.&#xff08;spoc&#xff09;根据你的学号 mod 4的结果值&#xff0c;确定选择四种页面置换算法&#xff08;0&#xff1a;LRU置换算法&#xff0c;1:改进的clock 页置换算法&#xff0c;2&#xff1a;工作集页置换算法&#xff0c;3&#xff1a;缺页率置换算法&#xff09;中的一种来设计一个应用程序&#xff08;可基于python, ruby, C, C&#43;&#43;&#xff0c;LISP等&#xff09;模拟实现&#xff0c;并给出测试用例和测试结果。请参考如python代码或独自实现。<br /><br />页置换算法实现的参考实例 &#xff08; https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab3/page-replacement-policy.py &#xff09;<br /><br />6. 请判断OPT、LRU、FIFO、Clock和LFU等各页面置换算法是否存在Belady现象&#xff1f;如果存在&#xff0c;给出实例&#xff1b;如果不存在&#xff0c;给出证明。<br /><br /></p>\n<p></p>\n<p>lec8</p>\n<p>=============<br />04-1-spoc-discussion.md <br />的个人思考题&#xff0c;小组思考题(1)(2)(3)</p>", "anon": "no", "created": "2017-04-01T13:31:51Z", "uid": "hcrrjuyequh4bt", "subject": "部分课后练习"}]}, "error": null}