{"aid": "iltktuoogx92mx", "result": {"folders": ["lab2"], "unique_views": 59, "no_answer": 0, "change_log": [{"data": "ilqm4isolei7ir", "anon": "full", "when": "2016-03-13T13:44:25Z", "type": "create"}, {"uid": "i76z9sx78G8", "data": "ilr86tq1iss1zx", "when": "2016-03-14T00:02:04Z", "to": "ilqm4ism6d7iq", "anon": "no", "type": "i_answer"}, {"uid": "i0ayxqk6wry734", "data": "ilrdqs5vybf57m", "when": "2016-03-14T02:37:34Z", "to": "ilqm4ism6d7iq", "anon": "no", "type": "s_answer"}, {"to": "ilqm4ism6d7iq", "anon": "full", "when": "2016-03-14T03:39:07Z", "type": "followup"}, {"data": "ilrlcb2144j516", "anon": "no", "when": "2016-03-14T06:10:15Z", "uid": "i0ayxqk6wry734", "type": "s_answer_update"}, {"to": "ilqm4ism6d7iq", "anon": "no", "when": "2016-03-15T01:07:02Z", "uid": "i0dvatlio3g3ju", "type": "followup"}], "upvote_ids": [], "id": "ilqm4ism6d7iq", "bookmarked": 7, "no_answer_followup": 1, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-03-14T00:02:04Z", "config": {}, "tag_endorse_arr": [], "children": [], "bucket_name": "Today", "type": "i_answer", "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "id": "ilr86tpwj8i1zw", "history": [{"content": "<p>在Ucore中&#xff0c;内存以页为管理的基本单位。在页的基础上进行更多更复杂的管理操作。</p>", "anon": "no", "subject": "", "uid": "i76z9sx78G8", "created": "2016-03-14T00:02:04Z"}]}, {"folders": [], "is_tag_endorse": false, "created": "2016-03-14T02:37:34Z", "config": {}, "tag_endorse_arr": [], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "id": "ilrdqs5tp757l", "history": [{"content": "<p>好吧一开始没有看懂你的问题&#xff08;这部分没有仔细看过答案&#xff09;。。确实答案的分配是基于所有页的</p>\n<p>这很不科学&#xff0c;效率不知低到哪里去了。。其实原先clean的lab2里默认实现还是有点参考价值的</p>\n<p>===========================更新分割线===============================================</p>\n<p>这个过程其实分两步<strong>, </strong>第一步比较粗犷&#xff0c;就是ucore定义了一个可用的物理空间0x0~0x38000000&#xff0c;然后把这个范围里的所有物理页都分配了一个Page的结构体来管理&#xff0c;并把这些Page放在一个连续的物理内存中&#xff0c;其实就相当于一个Page数组&#xff0c;对于连续的物理页其实你都不需要链表了&#xff0c;知道Page数组的其实地址&#xff0c;再知道物理地址&#xff0c;直接一算就成了。</p>\n<p>第二步是探测可用内存的时候&#xff0c;把所有可用空闲块都串成了一条链&#xff08;注意可能有多页&#xff09;&#xff0c;这个链表由free_area来管理&#xff0c;这里面的元素其实还是Page结构体&#xff0c;但每个在里面的Page都是一块连续空间块的起始页。</p>\n<p></p>\n<p></p>", "anon": "no", "subject": "", "uid": "i0ayxqk6wry734", "created": "2016-03-14T06:10:15Z"}, {"content": "<p>这个过程其实分两步<strong>, </strong>第一步比较粗犷&#xff0c;就是ucore定义了一个可用的物理空间0x0~0x38000000&#xff0c;然后把这个范围里的所有物理页都分配了一个Page的结构体来管理&#xff0c;并把这些Page放在一个连续的物理内存中&#xff0c;其实就相当于一个Page数组&#xff0c;对于连续的物理页其实你都不需要链表了&#xff0c;知道Page数组的其实地址&#xff0c;再知道物理地址&#xff0c;直接一算就成了。</p>\n<p>第二步是探测可用内存的时候&#xff0c;把所有可用空闲块都串成了一条链&#xff08;注意可能有多页&#xff09;&#xff0c;这个链表由free_area来管理&#xff0c;这里面的元素其实还是Page结构体&#xff0c;但每个在里面的Page都是一块连续空间块的起始页。</p>\n<p>不知道我说明白没有</p>", "anon": "no", "subject": "", "uid": "i0ayxqk6wry734", "created": "2016-03-14T02:37:34Z"}]}, {"folders": [], "updated": "2016-03-14T03:39:07Z", "no_upvotes": 0, "created": "2016-03-14T03:39:07Z", "type": "followup", "d-bucket": "Yesterday", "id": "ilrfxy0laso48v", "anon": "full", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>其实我觉得这是不是就是自己的实现和答案实现的区别啊&#xff1f;感觉lab2初始的代码&#xff0c;就是只把块的第一页加到list里边&#xff0c;不管是init&#xff0c;alloc都是这样处理的&#xff1b;而lab2_answer就会把所有页都加进去...</p>\n<p>参见下面default_init_memmap函数两实现的区别。</p>\n<p>===== lab2 =====</p>\n<pre>static void\ndefault_init_memmap(struct Page *base, size_t n) {\n    assert(n &gt; 0);\n    struct Page *p = base;\n    for (; p != base &#43; n; p &#43;&#43;) {\n        assert(PageReserved(p));\n        p-&gt;flags = p-&gt;property = 0;\n        set_page_ref(p, 0);\n    }\n    base-&gt;property = n;\n    SetPageProperty(base);\n    nr_free &#43;= n;\n    list_add(&amp;free_list, &amp;(base-&gt;page_link));\n}</pre>\n<p>===== lab2_answer =====</p>\n<pre>static void\ndefault_init_memmap(struct Page *base, size_t n) {\n    assert(n &gt; 0);\n    struct Page *p = base;\n    for (; p != base &#43; n; p &#43;&#43;) {\n        assert(PageReserved(p));\n        p-&gt;flags = 0;\n        SetPageProperty(p);\n        p-&gt;property = 0;\n        set_page_ref(p, 0);\n        list_add_before(&amp;free_list, &amp;(p-&gt;page_link));\n    }\n    nr_free &#43;= n;\n    //first block\n    base-&gt;property = n;\n}</pre>\n<p>所以&#xff0c;我觉得只加块的第一页也是可以的&#xff0c;至少目前看来&#xff0c;我们并没有把所有页都加进去的需求和必要。</p>"}, {"folders": [], "updated": "2016-03-15T01:07:02Z", "no_upvotes": 0, "uid": "i0dvatlio3g3ju", "created": "2016-03-15T01:07:02Z", "type": "followup", "no_answer": 0, "id": "ilspy8044bgem", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>我感觉以页为单位管理也没必要把每个页都装进链表啊&#xff0c;我感觉答案有问题吧。不用答案那种方法完全是没问题的</p>"}], "request_instructor_me": false, "nr": 686, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lab2", "student"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-03-13T13:44:25Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1458055887000, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>为什么要把所有page连起来呢&#xff1f;难道不是按块来管理吗&#xff1f;</p>\n<p></p>\n<pre>参考答案的代码&#xff1a;<br />static void\ndefault_init_memmap(struct Page *base, size_t n) {\n    assert(n &gt; 0);\n    struct Page *p = base;\n    for (; p != base &#43; n; p &#43;&#43;) {\n        assert(PageReserved(p));\n        p-&gt;flags = 0;\n        SetPageProperty(p);\n        p-&gt;property = 0;\n        set_page_ref(p, 0);\n        list_add_before(&amp;free_list, &amp;(p-&gt;page_link));\n    }\n    nr_free &#43;= n;\n    //first block\n    base-&gt;property = n;\n}<br /><br />我所认为的代码&#xff1a;<br />static void\ndefault_init_memmap(struct Page *base, size_t n) {\n    assert(n &gt; 0);\n    struct Page *p = base;\n    for (; p != base &#43; n; p &#43;&#43;) {\n        // 检查预留位\n        assert(PageReserved(p));\n        // 清空标志位flags=0&#xff0c;设置为非块property=0\n        p-&gt;flags = p-&gt;property = 0;\n        // 设置引用计数为0\n        set_page_ref(p, 0);\n    }\n    // 设置property标志位&#xff0c;使得base-&gt;property有效&#xff0c;表示base为块\n    SetPageProperty(base);\n    base-&gt;property = n;\n    nr_free &#43;= n;\n}</pre>\n<p></p>\n<p>包括参考答案中的alloc和free&#xff0c;也都在分配或回收内存块时&#xff0c;对块内所有的页进行链表操作。</p>\n<p>如此看来&#xff0c;<strong>ucore管理页帧的链表&#xff0c;不是内存块的链表&#xff0c;而是页的链表</strong>。是吗&#xff1f;</p>\n<p>我的理解是&#xff0c;页帧按块管理&#xff0c;即链表中只有页块。分配和回收时&#xff0c;会有对页标志位的操作&#xff0c;但每次分配和回收&#xff0c;链表只可能有1~2个节点的波动&#xff0c;而不是像lab2_ans那样一大串链表操作。我猜想是否ucore某些框架部分可能用到&#xff0c;但在lab2这里还未体现&#xff1f;</p>\n<p></p>", "anon": "full", "subject": "关于lab2的default_init_memmap的Page管理", "created": "2016-03-13T13:44:25Z"}]}, "error": null}