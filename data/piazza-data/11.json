{"error": null, "result": {"nr": 11, "upvote_ids": [], "change_log": [{"type": "create", "when": "2015-03-02T15:03:39Z", "uid": "i6ry30g7v1z", "data": "i6rzy937ftj21t", "anon": "no"}, {"type": "update", "when": "2015-03-02T15:14:03Z", "uid": "i6ry30g7v1z", "data": "i6s0bmtzoi2583", "anon": "no"}, {"type": "update", "when": "2015-03-02T15:15:21Z", "uid": "i6ry30g7v1z", "data": "i6s0db0w7sd1gv", "anon": "no"}, {"type": "update", "when": "2015-03-02T15:17:18Z", "uid": "i6ry30g7v1z", "data": "i6s0ftk9k5s2te", "anon": "no"}, {"uid": "hdjoucuyb836fq", "to": "i6rzy934ta721s", "when": "2015-03-03T01:26:34Z", "anon": "no", "data": "i6sm7c17q2n2r5", "type": "i_answer"}, {"type": "followup", "to": "i6rzy934ta721s", "when": "2015-03-03T03:05:12Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"type": "followup", "to": "i6rzy934ta721s", "when": "2015-03-03T03:21:30Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"type": "feedback", "to": "i6rzy934ta721s", "when": "2015-03-03T03:28:53Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"type": "update", "when": "2015-03-03T04:08:45Z", "uid": "i6ry30g7v1z", "data": "i6srzwv6qh02o8", "anon": "no"}, {"type": "update", "when": "2015-03-03T04:10:32Z", "uid": "i6ry30g7v1z", "data": "i6ss26x5sif3kd", "anon": "no"}, {"type": "feedback", "to": "i6rzy934ta721s", "when": "2015-03-03T06:21:28Z", "uid": "hdjoucuyb836fq", "anon": "no"}, {"type": "update", "when": "2015-03-03T13:03:37Z", "uid": "i6ry30g7v1z", "data": "i6tb3rawm4fi5", "anon": "no"}, {"type": "update", "when": "2015-03-04T00:03:57Z", "uid": "i6ry30g7v1z", "data": "i6tyoy19pg4be", "anon": "no"}], "q_edits": [], "i_edits": [], "unique_views": 145, "bookmarked": 2, "config": {}, "history": [{"subject": "buddy system 初始化时,传入的空闲物理内存起始地址是否要以4M(2^10*4096)大小向上对齐?", "content": "<p>从ucoreplus提取出来经过简化去掉NUMA架构的buddy system&#xff0c;check不通过。</p>\n<p>下面是结果&#xff1a;</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srxr1sxug9/QQ图片20150303115742.png\" /></p>\n<p>check函数中的&#xff1a;</p>\n<pre>assert((page2idx(p0) &amp; 7) == 0);</pre>\n<p>无法通过。</p>\n<p>原因是在对原来代码修改的过程中对page2idx()理解错误&#xff1a;</p>\n<pre>static inline ppn_t page2idx(struct Page *page)\n{\n return page - pages;\n}\n\nstatic inline struct Page *idx2page(ppn_t idx)\n{\n return pages &#43; idx;\n}</pre>\n<p>pages为页结构数组的首地址。</p>\n<p>实际上是需要以空闲物理内存起始页为起点的&#xff0c;也就是上面的416000这个物理地址</p>\n<p>正确的代码:</p>\n<pre>static inline ppn_t page2idx(struct Page *page)\n{\n return page - free_mem_begin;\n}\n\nstatic inline struct Page *idx2page(ppn_t idx)\n{\n return free_mem_begin &#43; idx;\n}</pre>\n<p>非常感谢<a href=\"https://www.piazza.com/class/i5j09fnsl7k5x0?cid=11\"><strong><span style=\"color:#333333\">Junjie Mao</span></strong></a> 明确、清晰的回答。</p>", "created": "2015-03-04T00:03:57Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"subject": "buddy system 初始化时,传入的空闲物理内存起始地址是否要以4M(2^10*4096)大小向上对齐?", "content": "<p>从ucoreplus提取出来经过简化去掉NUMA架构的buddy system&#xff0c;check不通过。</p>\n<p>下面是结果&#xff1a;</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srxr1sxug9/QQ图片20150303115742.png\" /></p>\n<p>check函数中的&#xff1a;</p>\n<pre>assert((page2idx(p0) &amp; 7) == 0);</pre>\n<p>无法通过。</p>\n<p>原因是在对原来代码修改的过程中对page2idx()理解错误&#xff1a;</p>\n<pre>static inline ppn_t page2idx(struct Page *page)<br />{<br /> return page - pages;<br />}<br /><br />static inline struct Page *idx2page(ppn_t idx)<br />{<br /> return pages &#43; idx;<br />}</pre>\n<p>pages为页结构数组的首地址。</p>\n<p>实际上是需要以空闲物理内存起始页为起点的&#xff0c;也就是上面的416000这个物理地址</p>\n<p>正确的代码:</p>\n<pre>static inline ppn_t page2idx(struct Page *page)<br />{<br /> return page - free_mem_begin;<br />}<br /><br />static inline struct Page *idx2page(ppn_t idx)<br />{<br /> return free_mem_begin &#43; idx;<br />}</pre>\n<p>非常感谢<a href=\"/class/i5j09fnsl7k5x0?cid=11\"><strong><span style=\"color:#333333\">Junjie Mao</span></strong></a>的回答。</p>", "created": "2015-03-03T13:03:37Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"subject": "buddy system 初始化时,传入的空闲物理内存起始地址是否要以4M(2^10*4096)大小向上对齐?", "content": "<p>看一个代码片段&#xff1a;</p>\n<p>   </p>\n<pre>   // kernel 的结束位置\n    extern char end[];\n    npage = maxpa / PGSIZE;\n    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);\n    // 所有物理内存页全部保留 init_memmap中会把可用的物理内存页清除保留位\n    for (i = 0; i &lt; npage; i &#43;&#43;) {\n        SetPageReserved(pages &#43; i);\n    }\n    uintptr_t freemem = PADDR((uintptr_t)pages &#43; sizeof(struct Page) * npage);\n    for (i = 0; i &lt; memmap-&gt;nr_map; i &#43;&#43;) {\n        uint64_t begin = memmap-&gt;map[i].addr, end = begin &#43; memmap-&gt;map[i].size;\n        if (memmap-&gt;map[i].type == E820_ARM) {\n            if (begin &lt; freemem) {\n                begin = freemem;\n            }\n            if (end &gt; KMEMSIZE) {\n                end = KMEMSIZE;\n            }\n            if (begin &lt; end) {\n                begin = ROUNDUP(begin, PGSIZE);\n                end = ROUNDDOWN(end, PGSIZE);\n                if (begin &lt; end) {\n                    cprintf(&#34;begin = %016llx,end = %016llx,count = %d\\n&#34;,begin,end,(end - begin) / PGSIZE);\n                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);\n                }\n            }\n        }\n    }</pre>\n<p>   </p>\n<pre>//init_memmap - call pmm-&gt;init_memmap to build Page struct for free memory  \nstatic void\ninit_memmap(struct Page *base, size_t n) {\n    // 此处调用buddy_init_memmap\n    pmm_manager-&gt;init_memmap(base, n);\n}</pre>\n<p>上面的代码片段是为了管理空闲物理内存。</p>\n<p>如果使用buddy system</p>\n<p>是否必须满足此条件&#xff1a;每个块的第一个页框的物理地址是该块大小的整数倍。例如&#xff0c;大小为16 个页框的块&#xff0c;其起始地址是16 × 2<sup>12</sup>&#xff08;2<sup>12</sup> &#xff1d; 4096&#xff0c;这是一个常规页的大小&#xff09;的倍数。</p>\n<p>buddy 算法空闲物理内存需要从最大阶(也就是10)开始加入空闲链表&#xff1a;</p>\n<pre> p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }</pre>\n<p></p>\n<p>2^10 = 1024</p>\n<p>1024个Page是4MB大小</p>\n<p>那么是不是必须要求&#xff1a;空闲物理内存初始地址是4M大小的倍数</p>\n<p>也就是&#xff1a;</p>\n<pre>base = pa2page(ROUNDUP(page2pa(base),0x400000));</pre>\n<p>但是这样会损失一大部分内存空间&#xff0c;极端情况接近4MB</p>\n<p>所以有没有什么方法能避免&#xff0c;或者说是不是我理解错了。</p>\n<pre>// {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}\n// from 2^0 ~ 2^10\n#define MAX_ORDER 10\nstatic free_area_t free_area[MAX_ORDER &#43; 1];\n\n//x from 0 ~ MAX_ORDER\n#define free_list(x) (free_area[x].free_list)\n#define nr_free(x) (free_area[x].nr_free)\n//buddy_init - init the free_list(0 ~ MAX_ORDER) &amp; reset nr_free(0 ~ MAX_ORDER)\nstatic void buddy_init(void)\n{\n int i, n;\n for (i = 0; i &lt;= MAX_ORDER; i&#43;&#43;) {\n  list_init(&amp;free_list(i));\n  nr_free(i) = 0;\n }\n}\n\n//buddy_init_memmap - build free_list for Page base follow  n continuing pages.\nstatic void buddy_init_memmap(struct Page *base,size_t n)\n{\n\n //计算可用内存的结束地址\n uint64_t end = n*PGSIZE &#43; page2pa(base);\n\n //每个块的第一个页框的物理地址是该块大小的整数倍。\n cprintf(&#34;page2pa(base) = %016llx\\n&#34;,page2pa(base));\n \n cprintf(&#34;ROUNDUP(page2pa(base),4M) = %016llx\\n&#34;,ROUNDUP(page2pa(base),0x400000)); \n // 地址对齐  可能会损失接近4MB的内存空间\n // 有没有方法能够避免&#xff1f; 或者是我理解错误&#xff1f;\n base = pa2page(ROUNDUP(page2pa(base),0x400000));\n \n //重新计算n\n uint64_t begin = page2pa(base);\n n = (end - begin) / PGSIZE;\n cprintf(&#34;n = %d\\n&#34;,n);\n\n struct Page *p = base;\n for (; p != base &#43; n; p&#43;&#43;) {\n  assert(PageReserved(p));\n  // 传进来的都是可用物理内存页 所以这些页的保留位清零 \n  p-&gt;flags = p-&gt;property = 0;\n  set_page_ref(p, 0);\n }\n\n p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }\n \n cprintf(&#34;buddy_init_memmap() end.\\n&#34;);\n}</pre>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6sroxg05f1i/QQ图片20150303114219.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srpxgq1fdg/QQ图片20150303114355.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srqzh8fouj/QQ图片20150303114934.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srro6t7so5/QQ图片20150303115024.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srsj07vkp5/QQ图片20150303115059.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srtkb97ax7/QQ图片20150303115231.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6sruh109js9/QQ图片20150303115313.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srvieybnrn/QQ图片20150303115340.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srwauq7cwk/QQ图片20150303115532.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srx0ua2uyu/QQ图片20150303115611.png\" /></p>\n<p>250行代码注释掉之后是如下结果&#xff1a;</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srxr1sxug9/QQ图片20150303115742.png\" /></p>\n<p></p>", "created": "2015-03-03T04:10:32Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"subject": "buddy system 初始化时,传入的空闲物理内存起始地址是否要以4M(2^10*4096)大小向上对齐?", "content": "<p>看一个代码片段&#xff1a;</p>\n<p>   </p>\n<pre>   // kernel 的结束位置\n    extern char end[];\n    npage = maxpa / PGSIZE;\n    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);\n    // 所有物理内存页全部保留 init_memmap中会把可用的物理内存页清除保留位\n    for (i = 0; i &lt; npage; i &#43;&#43;) {\n        SetPageReserved(pages &#43; i);\n    }\n    uintptr_t freemem = PADDR((uintptr_t)pages &#43; sizeof(struct Page) * npage);\n    for (i = 0; i &lt; memmap-&gt;nr_map; i &#43;&#43;) {\n        uint64_t begin = memmap-&gt;map[i].addr, end = begin &#43; memmap-&gt;map[i].size;\n        if (memmap-&gt;map[i].type == E820_ARM) {\n            if (begin &lt; freemem) {\n                begin = freemem;\n            }\n            if (end &gt; KMEMSIZE) {\n                end = KMEMSIZE;\n            }\n            if (begin &lt; end) {\n                begin = ROUNDUP(begin, PGSIZE);\n                end = ROUNDDOWN(end, PGSIZE);\n                if (begin &lt; end) {\n                    cprintf(&#34;begin = %016llx,end = %016llx,count = %d\\n&#34;,begin,end,(end - begin) / PGSIZE);\n                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);\n                }\n            }\n        }\n    }</pre>\n<p>   </p>\n<pre>//init_memmap - call pmm-&gt;init_memmap to build Page struct for free memory  \nstatic void\ninit_memmap(struct Page *base, size_t n) {\n    // 此处调用buddy_init_memmap\n    pmm_manager-&gt;init_memmap(base, n);\n}</pre>\n<p>上面的代码片段是为了管理空闲物理内存。</p>\n<p>如果使用buddy system</p>\n<p>是否必须满足此条件&#xff1a;每个块的第一个页框的物理地址是该块大小的整数倍。例如&#xff0c;大小为16 个页框的块&#xff0c;其起始地址是16 × 2<sup>12</sup>&#xff08;2<sup>12</sup> &#xff1d; 4096&#xff0c;这是一个常规页的大小&#xff09;的倍数。</p>\n<p>buddy 算法空闲物理内存需要从最大阶(也就是10)开始加入空闲链表&#xff1a;</p>\n<pre> p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }</pre>\n<p></p>\n<p>2^10 = 1024</p>\n<p>1024个Page是4MB大小</p>\n<p>那么是不是必须要求&#xff1a;空闲物理内存初始地址是4M大小的倍数</p>\n<p>也就是&#xff1a;</p>\n<pre>base = pa2page(ROUNDUP(page2pa(base),0x400000));</pre>\n<p>但是这样会损失一大部分内存空间&#xff0c;极端情况接近4MB</p>\n<p>所以有没有什么方法能避免&#xff0c;或者说是不是我理解错了。</p>\n<pre>// {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}\n// from 2^0 ~ 2^10\n#define MAX_ORDER 10\nstatic free_area_t free_area[MAX_ORDER &#43; 1];\n\n//x from 0 ~ MAX_ORDER\n#define free_list(x) (free_area[x].free_list)\n#define nr_free(x) (free_area[x].nr_free)\n//buddy_init - init the free_list(0 ~ MAX_ORDER) &amp; reset nr_free(0 ~ MAX_ORDER)\nstatic void buddy_init(void)\n{\n int i, n;\n for (i = 0; i &lt;= MAX_ORDER; i&#43;&#43;) {\n  list_init(&amp;free_list(i));\n  nr_free(i) = 0;\n }\n}\n\n//buddy_init_memmap - build free_list for Page base follow  n continuing pages.\nstatic void buddy_init_memmap(struct Page *base,size_t n)\n{\n\n //计算可用内存的结束地址\n uint64_t end = n*PGSIZE &#43; page2pa(base);\n\n //每个块的第一个页框的物理地址是该块大小的整数倍。\n cprintf(&#34;page2pa(base) = %016llx\\n&#34;,page2pa(base));\n \n cprintf(&#34;ROUNDUP(page2pa(base),4M) = %016llx\\n&#34;,ROUNDUP(page2pa(base),0x400000)); \n // 地址对齐  可能会损失接近4MB的内存空间\n // 有没有方法能够避免&#xff1f; 或者是我理解错误&#xff1f;\n base = pa2page(ROUNDUP(page2pa(base),0x400000));\n \n //重新计算n\n uint64_t begin = page2pa(base);\n n = (end - begin) / PGSIZE;\n cprintf(&#34;n = %d\\n&#34;,n);\n\n struct Page *p = base;\n for (; p != base &#43; n; p&#43;&#43;) {\n  assert(PageReserved(p));\n  // 传进来的都是可用物理内存页 所以这些页的保留位清零 \n  p-&gt;flags = p-&gt;property = 0;\n  set_page_ref(p, 0);\n }\n\n p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }\n \n cprintf(&#34;buddy_init_memmap() end.\\n&#34;);\n}</pre>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6sroxg05f1i/QQ图片20150303114219.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srpxgq1fdg/QQ图片20150303114355.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srqzh8fouj/QQ图片20150303114934.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srro6t7so5/QQ图片20150303115024.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srsj07vkp5/QQ图片20150303115059.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srtkb97ax7/QQ图片20150303115231.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6sruh109js9/QQ图片20150303115313.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srvieybnrn/QQ图片20150303115340.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srwauq7cwk/QQ图片20150303115532.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srx0ua2uyu/QQ图片20150303115611.png\" /></p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i6ry30g7v1z/i6srxr1sxug9/QQ图片20150303115742.png\" /></p>\n<p></p>", "created": "2015-03-03T04:08:45Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"subject": "buddy system 初始化时,传入的空闲物理内存起始地址是否要以4M(2^10*4096)大小向上对齐?", "content": "<p>看一个代码片段&#xff1a;</p>\n<p>   </p>\n<pre>   // kernel 的结束位置\n    extern char end[];\n    npage = maxpa / PGSIZE;\n    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);\n    // 所有物理内存页全部保留 init_memmap中会把可用的物理内存页清除保留位\n    for (i = 0; i &lt; npage; i &#43;&#43;) {\n        SetPageReserved(pages &#43; i);\n    }\n    uintptr_t freemem = PADDR((uintptr_t)pages &#43; sizeof(struct Page) * npage);\n    for (i = 0; i &lt; memmap-&gt;nr_map; i &#43;&#43;) {\n        uint64_t begin = memmap-&gt;map[i].addr, end = begin &#43; memmap-&gt;map[i].size;\n        if (memmap-&gt;map[i].type == E820_ARM) {\n            if (begin &lt; freemem) {\n                begin = freemem;\n            }\n            if (end &gt; KMEMSIZE) {\n                end = KMEMSIZE;\n            }\n            if (begin &lt; end) {\n                begin = ROUNDUP(begin, PGSIZE);\n                end = ROUNDDOWN(end, PGSIZE);\n                if (begin &lt; end) {\n                    cprintf(&#34;begin = %016llx,end = %016llx,count = %d\\n&#34;,begin,end,(end - begin) / PGSIZE);\n                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);\n                }\n            }\n        }\n    }</pre>\n<p>   </p>\n<pre>//init_memmap - call pmm-&gt;init_memmap to build Page struct for free memory  \nstatic void\ninit_memmap(struct Page *base, size_t n) {\n    // 此处调用buddy_init_memmap\n    pmm_manager-&gt;init_memmap(base, n);\n}</pre>\n<p>上面的代码片段是为了管理空闲物理内存。</p>\n<p>如果使用buddy system</p>\n<p>是否必须满足此条件&#xff1a;每个块的第一个页框的物理地址是该块大小的整数倍。例如&#xff0c;大小为16 个页框的块&#xff0c;其起始地址是16 × 2<sup>12</sup>&#xff08;2<sup>12</sup> &#xff1d; 4096&#xff0c;这是一个常规页的大小&#xff09;的倍数。</p>\n<p>buddy 算法空闲物理内存需要从最大阶(也就是10)开始加入空闲链表&#xff1a;</p>\n<pre> p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }</pre>\n<p></p>\n<p>2^10 = 1024</p>\n<p>1024个Page是4MB大小</p>\n<p>那么是不是必须要求&#xff1a;空闲物理内存初始地址是4M大小的倍数</p>\n<p>也就是&#xff1a;</p>\n<pre>base = pa2page(ROUNDUP(page2pa(base),0x400000));</pre>\n<p>但是这样会损失一大部分内存空间&#xff0c;极端情况接近4MB</p>\n<p>所以有没有什么方法能避免&#xff0c;或者说是不是我理解错了。</p>\n<pre>// {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}\n// from 2^0 ~ 2^10\n#define MAX_ORDER 10\nstatic free_area_t free_area[MAX_ORDER &#43; 1];\n\n//x from 0 ~ MAX_ORDER\n#define free_list(x) (free_area[x].free_list)\n#define nr_free(x) (free_area[x].nr_free)\n//buddy_init - init the free_list(0 ~ MAX_ORDER) &amp; reset nr_free(0 ~ MAX_ORDER)\nstatic void buddy_init(void)\n{\n int i, n;\n for (i = 0; i &lt;= MAX_ORDER; i&#43;&#43;) {\n  list_init(&amp;free_list(i));\n  nr_free(i) = 0;\n }\n}\n\n//buddy_init_memmap - build free_list for Page base follow  n continuing pages.\nstatic void buddy_init_memmap(struct Page *base,size_t n)\n{\n\n //计算可用内存的结束地址\n uint64_t end = n*PGSIZE &#43; page2pa(base);\n\n //每个块的第一个页框的物理地址是该块大小的整数倍。\n cprintf(&#34;page2pa(base) = %016llx\\n&#34;,page2pa(base));\n \n cprintf(&#34;ROUNDUP(page2pa(base),4M) = %016llx\\n&#34;,ROUNDUP(page2pa(base),0x400000)); \n // 地址对齐  可能会损失接近4MB的内存空间\n // 有没有方法能够避免&#xff1f; 或者是我理解错误&#xff1f;\n base = pa2page(ROUNDUP(page2pa(base),0x400000));\n \n //重新计算n\n uint64_t begin = page2pa(base);\n n = (end - begin) / PGSIZE;\n cprintf(&#34;n = %d\\n&#34;,n);\n\n struct Page *p = base;\n for (; p != base &#43; n; p&#43;&#43;) {\n  assert(PageReserved(p));\n  // 传进来的都是可用物理内存页 所以这些页的保留位清零 \n  p-&gt;flags = p-&gt;property = 0;\n  set_page_ref(p, 0);\n }\n\n p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }\n \n cprintf(&#34;buddy_init_memmap() end.\\n&#34;);\n}</pre>", "created": "2015-03-02T15:17:18Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"subject": "buddy system 初始化时,传入的空闲物理内存起始地址是否要以4M(2^10*4096)大小向上对齐?", "content": "<p>看一个代码片段&#xff1a;<tt>&lt;br /&gt;</tt></p>\n<p>   </p>\n<pre>&lt;tt&gt;    // kernel 的结束位置\n    extern char end[];\n    npage = maxpa / PGSIZE;\n    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);\n    // 所有物理内存页全部保留 init_memmap中会把可用的物理内存页清除保留位\n    for (i = 0; i &lt; npage; i &#43;&#43;) {\n        SetPageReserved(pages &#43; i);\n    }\n    uintptr_t freemem = PADDR((uintptr_t)pages &#43; sizeof(struct Page) * npage);\n    for (i = 0; i &lt; memmap-&gt;nr_map; i &#43;&#43;) {\n        uint64_t begin = memmap-&gt;map[i].addr, end = begin &#43; memmap-&gt;map[i].size;\n        if (memmap-&gt;map[i].type == E820_ARM) {\n            if (begin &lt; freemem) {\n                begin = freemem;\n            }\n            if (end &gt; KMEMSIZE) {\n                end = KMEMSIZE;\n            }\n            if (begin &lt; end) {\n                begin = ROUNDUP(begin, PGSIZE);\n                end = ROUNDDOWN(end, PGSIZE);\n                if (begin &lt; end) {\n                    cprintf(&#34;begin = %016llx,end = %016llx,count = %d\\n&#34;,begin,end,(end - begin) / PGSIZE);\n                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);\n                }\n            }\n        }\n    }&lt;/tt&gt;</pre>\n<p>   </p>\n<pre>//init_memmap - call pmm-&gt;init_memmap to build Page struct for free memory  \nstatic void\ninit_memmap(struct Page *base, size_t n) {\n    // 此处调用buddy_init_memmap\n    pmm_manager-&gt;init_memmap(base, n);\n}</pre>\n<p>上面的代码片段是为了管理空闲物理内存。</p>\n<p>如果使用buddy system</p>\n<p>是否必须满足此条件&#xff1a;每个块的第一个页框的物理地址是该块大小的整数倍。例如&#xff0c;大小为16 个页框的块&#xff0c;其起始地址是16 × 2<sup>12</sup>&#xff08;2<sup>12</sup> &#xff1d; 4096&#xff0c;这是一个常规页的大小&#xff09;的倍数。</p>\n<p>buddy 算法空闲物理内存需要从最大阶(也就是10)开始加入空闲链表&#xff1a;</p>\n<pre> p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }</pre>\n<p></p>\n<p>2^10 = 1024</p>\n<p>1024个Page是4MB大小</p>\n<p>那么是不是必须要求&#xff1a;空闲物理内存初始地址是4M大小的倍数</p>\n<p>也就是&#xff1a;</p>\n<pre>base = pa2page(ROUNDUP(page2pa(base),0x400000));</pre>\n<p>但是这样会损失一大部分内存空间&#xff0c;极端情况接近4MB</p>\n<p>所以有没有什么方法能避免&#xff0c;或者说是不是我理解错了。</p>\n<pre>// {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}\n// from 2^0 ~ 2^10\n#define MAX_ORDER 10\nstatic free_area_t free_area[MAX_ORDER &#43; 1];\n\n//x from 0 ~ MAX_ORDER\n#define free_list(x) (free_area[x].free_list)\n#define nr_free(x) (free_area[x].nr_free)\n//buddy_init - init the free_list(0 ~ MAX_ORDER) &amp; reset nr_free(0 ~ MAX_ORDER)\nstatic void buddy_init(void)\n{\n int i, n;\n for (i = 0; i &lt;= MAX_ORDER; i&#43;&#43;) {\n  list_init(&amp;free_list(i));\n  nr_free(i) = 0;\n }\n}\n\n//buddy_init_memmap - build free_list for Page base follow  n continuing pages.\nstatic void buddy_init_memmap(struct Page *base,size_t n)\n{\n\n //计算可用内存的结束地址\n uint64_t end = n*PGSIZE &#43; page2pa(base);\n\n //每个块的第一个页框的物理地址是该块大小的整数倍。\n cprintf(&#34;page2pa(base) = %016llx\\n&#34;,page2pa(base));\n \n cprintf(&#34;ROUNDUP(page2pa(base),4M) = %016llx\\n&#34;,ROUNDUP(page2pa(base),0x400000)); \n // 地址对齐  可能会损失接近4Mb的内存空间\n // 有没有方法能够避免&#xff1f; 或者是我理解错误&#xff1f;\n base = pa2page(ROUNDUP(page2pa(base),0x400000));\n \n //重新计算n\n uint64_t begin = page2pa(base);\n n = (end - begin) / PGSIZE;\n cprintf(&#34;n = %d\\n&#34;,n);\n\n struct Page *p = base;\n for (; p != base &#43; n; p&#43;&#43;) {\n  assert(PageReserved(p));\n  // 传进来的都是可用物理内存页 所以这些页的保留位清零 \n  p-&gt;flags = p-&gt;property = 0;\n  set_page_ref(p, 0);\n }\n\n p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }\n \n cprintf(&#34;buddy_init_memmap() end.\\n&#34;);\n}</pre>", "created": "2015-03-02T15:15:21Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"subject": "buddy system 初始化时&#xff0c;传入的空闲起始地址是否要以4M(2^10*4096)大小向上对齐&#xff1f;", "content": "<p>看一个代码片段&#xff1a;<tt>&lt;br /&gt;</tt></p>\n<p>   </p>\n<pre>&lt;tt&gt;    // kernel 的结束位置\n    extern char end[];\n    npage = maxpa / PGSIZE;\n    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);\n    // 所有物理内存页全部保留 init_memmap中会把可用的物理内存页清除保留位\n    for (i = 0; i &lt; npage; i &#43;&#43;) {\n        SetPageReserved(pages &#43; i);\n    }\n    uintptr_t freemem = PADDR((uintptr_t)pages &#43; sizeof(struct Page) * npage);\n    for (i = 0; i &lt; memmap-&gt;nr_map; i &#43;&#43;) {\n        uint64_t begin = memmap-&gt;map[i].addr, end = begin &#43; memmap-&gt;map[i].size;\n        if (memmap-&gt;map[i].type == E820_ARM) {\n            if (begin &lt; freemem) {\n                begin = freemem;\n            }\n            if (end &gt; KMEMSIZE) {\n                end = KMEMSIZE;\n            }\n            if (begin &lt; end) {\n                begin = ROUNDUP(begin, PGSIZE);\n                end = ROUNDDOWN(end, PGSIZE);\n                if (begin &lt; end) {\n                    cprintf(&#34;begin = %016llx,end = %016llx,count = %d\\n&#34;,begin,end,(end - begin) / PGSIZE);\n                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);\n                }\n            }\n        }\n    }&lt;/tt&gt;</pre>\n<p>   </p>\n<pre>//init_memmap - call pmm-&gt;init_memmap to build Page struct for free memory  \nstatic void\ninit_memmap(struct Page *base, size_t n) {\n    // 此处调用buddy_init_memmap\n    pmm_manager-&gt;init_memmap(base, n);\n}</pre>\n<p>上面的代码片段是为了管理空闲物理内存。</p>\n<p>如果使用buddy system</p>\n<p>是否必须满足此条件&#xff1a;每个块的第一个页框的物理地址是该块大小的整数倍。例如&#xff0c;大小为16 个页框的块&#xff0c;其起始地址是16 × 2<sup>12</sup>&#xff08;2<sup>12</sup> &#xff1d; 4096&#xff0c;这是一个常规页的大小&#xff09;的倍数。</p>\n<p>buddy 算法空闲物理内存需要从最大阶(也就是10)开始加入空闲链表&#xff1a;</p>\n<pre> p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }</pre>\n<p></p>\n<p>2^10 = 1024</p>\n<p>1024个Page是4MB大小</p>\n<p>那么是不是必须要求&#xff1a;空闲物理内存初始地址是4M大小的倍数</p>\n<p>也就是&#xff1a;</p>\n<pre>base = pa2page(ROUNDUP(page2pa(base),0x400000));</pre>\n<p>但是这样会损失一大部分内存空间&#xff0c;极端情况接近4MB</p>\n<p>所以有没有什么方法能避免&#xff0c;或者说是不是我理解错了。</p>\n<pre>// {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}\n// from 2^0 ~ 2^10\n#define MAX_ORDER 10\nstatic free_area_t free_area[MAX_ORDER &#43; 1];\n\n//x from 0 ~ MAX_ORDER\n#define free_list(x) (free_area[x].free_list)\n#define nr_free(x) (free_area[x].nr_free)\n//buddy_init - init the free_list(0 ~ MAX_ORDER) &amp; reset nr_free(0 ~ MAX_ORDER)\nstatic void buddy_init(void)\n{\n int i, n;\n for (i = 0; i &lt;= MAX_ORDER; i&#43;&#43;) {\n  list_init(&amp;free_list(i));\n  nr_free(i) = 0;\n }\n}\n\n//buddy_init_memmap - build free_list for Page base follow  n continuing pages.\nstatic void buddy_init_memmap(struct Page *base,size_t n)\n{\n\n //计算可用内存的结束地址\n uint64_t end = n*PGSIZE &#43; page2pa(base);\n\n //每个块的第一个页框的物理地址是该块大小的整数倍。\n cprintf(&#34;page2pa(base) = %016llx\\n&#34;,page2pa(base));\n \n cprintf(&#34;ROUNDUP(page2pa(base),4M) = %016llx\\n&#34;,ROUNDUP(page2pa(base),0x400000)); \n // 地址对齐  可能会损失接近4Mb的内存空间\n // 有没有方法能够避免&#xff1f; 或者是我理解错误&#xff1f;\n base = pa2page(ROUNDUP(page2pa(base),0x400000));\n \n //重新计算n\n uint64_t begin = page2pa(base);\n n = (end - begin) / PGSIZE;\n cprintf(&#34;n = %d\\n&#34;,n);\n\n struct Page *p = base;\n for (; p != base &#43; n; p&#43;&#43;) {\n  assert(PageReserved(p));\n  // 传进来的都是可用物理内存页 所以这些页的保留位清零 \n  p-&gt;flags = p-&gt;property = 0;\n  set_page_ref(p, 0);\n }\n\n p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }\n \n cprintf(&#34;buddy_init_memmap() end.\\n&#34;);\n}</pre>", "created": "2015-03-02T15:14:03Z", "uid": "i6ry30g7v1z", "anon": "no"}, {"subject": "buddy lab2 align", "content": "<p>看一个代码片段&#xff1a;<tt><br /></tt></p>\n<p>   </p>\n<pre><tt>    // kernel 的结束位置<br />    extern char end[];<br />    npage = maxpa / PGSIZE;<br />    pages = (struct Page *)ROUNDUP((void *)end, PGSIZE);<br />    // 所有物理内存页全部保留 init_memmap中会把可用的物理内存页清除保留位<br />    for (i = 0; i &lt; npage; i &#43;&#43;) {<br />        SetPageReserved(pages &#43; i);<br />    }<br />    uintptr_t freemem = PADDR((uintptr_t)pages &#43; sizeof(struct Page) * npage);<br />    for (i = 0; i &lt; memmap-&gt;nr_map; i &#43;&#43;) {<br />        uint64_t begin = memmap-&gt;map[i].addr, end = begin &#43; memmap-&gt;map[i].size;<br />        if (memmap-&gt;map[i].type == E820_ARM) {<br />            if (begin &lt; freemem) {<br />                begin = freemem;<br />            }<br />            if (end &gt; KMEMSIZE) {<br />                end = KMEMSIZE;<br />            }<br />            if (begin &lt; end) {<br />                begin = ROUNDUP(begin, PGSIZE);<br />                end = ROUNDDOWN(end, PGSIZE);<br />                if (begin &lt; end) {<br />                    cprintf(&#34;begin = %016llx,end = %016llx,count = %d\\n&#34;,begin,end,(end - begin) / PGSIZE);<br />                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);<br />                }<br />            }<br />        }<br />    }</tt></pre>\n<p>   </p>\n<pre>//init_memmap - call pmm-&gt;init_memmap to build Page struct for free memory  <br />static void<br />init_memmap(struct Page *base, size_t n) {<br />    // 此处调用buddy_init_memmap<br />    pmm_manager-&gt;init_memmap(base, n);<br />}</pre>\n<p>上面的代码片段是为了管理空闲物理内存。</p>\n<p>如果使用buddy system</p>\n<p>是否必须满足此条件&#xff1a;每个块的第一个页框的物理地址是该块大小的整数倍。例如&#xff0c;大小为16 个页框的块&#xff0c;其起始地址是16 × 2<sup>12</sup>&#xff08;2<sup>12</sup> &#xff1d; 4096&#xff0c;这是一个常规页的大小&#xff09;的倍数。</p>\n<p>buddy 算法空闲物理内存需要从最大阶(也就是10)开始加入空闲链表&#xff1a;</p>\n<pre> p = base;<br /> size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);<br /> while (n != 0) {<br />  while (n &gt;= order_size) {<br />  //下面两句是加入到空闲链表中的前置条件<br />   p-&gt;property = order;<br />   SetPageProperty(p);<br />   // 连接到order阶上<br />   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));<br />   n -= order_size, p &#43;= order_size;<br />   // order阶上的块个数&#43;1<br />   nr_free(order)&#43;&#43;;<br />  }<br />  order--;<br />  order_size &gt;&gt;= 1;<br /> }</pre>\n<p></p>\n<p>2^10 = 1024</p>\n<p>1024个Page是4MB大小</p>\n<p>那么是不是必须要求&#xff1a;空闲物理内存初始地址是4M大小的倍数</p>\n<p>也就是&#xff1a;</p>\n<pre>base = pa2page(ROUNDUP(page2pa(base),0x400000));</pre>\n<p>但是这样会损失一大部分内存空间&#xff0c;极端情况接近4MB</p>\n<p>所以有没有什么方法能避免&#xff0c;或者说是不是我理解错了。</p>\n<pre>// {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}\n// from 2^0 ~ 2^10\n#define MAX_ORDER 10\nstatic free_area_t free_area[MAX_ORDER &#43; 1];\n\n//x from 0 ~ MAX_ORDER\n#define free_list(x) (free_area[x].free_list)\n#define nr_free(x) (free_area[x].nr_free)\n//buddy_init - init the free_list(0 ~ MAX_ORDER) &amp; reset nr_free(0 ~ MAX_ORDER)\nstatic void buddy_init(void)\n{\n int i, n;\n for (i = 0; i &lt;= MAX_ORDER; i&#43;&#43;) {\n  list_init(&amp;free_list(i));\n  nr_free(i) = 0;\n }\n}\n<br />//buddy_init_memmap - build free_list for Page base follow  n continuing pages.\nstatic void buddy_init_memmap(struct Page *base,size_t n)\n{\n\n //计算可用内存的结束地址\n uint64_t end = n*PGSIZE &#43; page2pa(base);\n\n //每个块的第一个页框的物理地址是该块大小的整数倍。\n cprintf(&#34;page2pa(base) = %016llx\\n&#34;,page2pa(base));\n \n cprintf(&#34;ROUNDUP(page2pa(base),4M) = %016llx\\n&#34;,ROUNDUP(page2pa(base),0x400000)); \n // 地址对齐  可能会损失接近4Mb的内存空间\n // 有没有方法能够避免&#xff1f; 或者是我理解错误&#xff1f;\n base = pa2page(ROUNDUP(page2pa(base),0x400000));\n \n //重新计算n\n uint64_t begin = page2pa(base);\n n = (end - begin) / PGSIZE;\n cprintf(&#34;n = %d\\n&#34;,n);\n\n struct Page *p = base;\n for (; p != base &#43; n; p&#43;&#43;) {\n  assert(PageReserved(p));\n  // 传进来的都是可用物理内存页 所以这些页的保留位清零 \n  p-&gt;flags = p-&gt;property = 0;\n  set_page_ref(p, 0);\n }\n\n p = base;\n size_t order = MAX_ORDER, order_size = (1 &lt;&lt; order);\n while (n != 0) {\n  while (n &gt;= order_size) {\n  //下面两句是加入到空闲链表中的前置条件\n   p-&gt;property = order;\n   SetPageProperty(p);\n   // 连接到order阶上\n   list_add(&amp;free_list(order), &amp;(p-&gt;page_link));\n   n -= order_size, p &#43;= order_size;\n   // order阶上的块个数&#43;1\n   nr_free(order)&#43;&#43;;\n  }\n  order--;\n  order_size &gt;&gt;= 1;\n }\n \n cprintf(&#34;buddy_init_memmap() end.\\n&#34;);\n}</pre>", "created": "2015-03-02T15:03:39Z", "uid": "i6ry30g7v1z", "anon": "no"}], "data": {"embed_links": []}, "request_instructor_me": false, "folders": ["quiz3", "lab2"], "type": "question", "tag_good": [], "no_answer": 0, "created": "2015-03-02T15:03:39Z", "t": 1433499916658, "id": "i6rzy934ta721s", "status": "active", "tag_good_arr": [], "default_anonymity": "no", "my_favorite": false, "bucket_order": 2, "is_bookmarked": false, "is_tag_good": false, "bucket_name": "Today", "no_answer_followup": 0, "children": [{"folders": [], "bucket_order": 2, "config": {}, "history": [{"subject": "", "content": "<p>ucore的buddy system的实现没有假设块地址按块大小对齐&#xff0c;所以不对base进行ROUNDUP也是可以的。</p>\n<p></p>\n<p>这份代码的来源是&#xff1f;</p>", "created": "2015-03-03T01:26:34Z", "uid": "hdjoucuyb836fq", "anon": "no"}], "data": {"embed_links": []}, "bucket_name": "Today", "is_tag_endorse": false, "children": [], "tag_endorse": [{"admin": false, "role": "student", "facebook_id": null, "us": false, "name": "再度燃烧", "id": "i6ry30g7v1z", "photo": "1425340926_35.png"}], "tag_endorse_arr": ["i6ry30g7v1z"], "created": "2015-03-03T01:26:34Z", "id": "i6sm7c05cih2r4", "type": "i_answer"}, {"no_upvotes": 0, "uid": "i6ry30g7v1z", "bucket_name": "Yesterday", "bucket_order": 3, "updated": "2015-03-03T03:05:12Z", "config": {}, "d-bucket": "Yesterday", "data": {"embed_links": null}, "anon": "no", "folders": [], "subject": "<p>重新整理&#xff0c;放到顶楼。</p>", "children": [], "type": "followup", "no_answer": 0, "created": "2015-03-03T03:05:12Z", "id": "i6spq6lizu2y9"}, {"no_upvotes": 0, "uid": "i6ry30g7v1z", "bucket_name": "Yesterday", "bucket_order": 3, "updated": "2015-03-03T03:21:30Z", "config": {}, "d-bucket": "Yesterday", "data": {"embed_links": null}, "anon": "no", "folders": [], "subject": "<p>重新整理&#xff0c;放到顶楼。</p>", "children": [{"d-bucket": "Yesterday", "uid": "i6ry30g7v1z", "bucket_name": "Yesterday", "bucket_order": 3, "updated": "2015-03-03T03:28:53Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>重新整理&#xff0c;放到顶楼。</p>", "children": [], "type": "feedback", "created": "2015-03-03T03:28:53Z", "id": "i6sqkmncjhv2ke"}, {"d-bucket": "Yesterday", "uid": "hdjoucuyb836fq", "bucket_name": "Yesterday", "bucket_order": 3, "updated": "2015-03-03T06:21:28Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>1. ucore plus amd64版本的assert是支持输出assert的源代码位置的。实际上输出源代码位置的原理并不依赖调试信息&#xff0c;只是利用编译器预定义的__FILE__、__FUNC__和__LINE__三个宏获得&#xff0c;与体系结构没有关系。<br /><br />2. page2idx(p0) &amp; 7检查的是page2idx(p0)是否满足对齐要求&#xff0c;page2idx(p0)是p0在其所属的zone里的页序号&#xff0c;例如一个zone的范围是[0xaa0000, 0xcc0000]&#xff0c;那位于0xbb0000的页&#xff0c;其page2idx的结果是(0xbb0000 - 0xaa0000) / PGSIZE = 0x110。由于buddy_init_memmap中&#xff0c;内存块的划分是最高阶开始&#xff0c;所以任何一个order阶内存块的page2idx应该是按照1 &lt;&lt; order对齐的&#xff08;可以用数学归纳法证明&#xff09;。<br /><br />在刚初始化好的buddy system中第一次分配的连续8页&#xff0c;要么直接获得第一个order=3的块&#xff0c;要么得到一个order&gt;3的块的前8个页&#xff08;参见__buddy_alloc_pages_numa的代码&#xff09;。无论是哪种情况&#xff0c;分配到的Page的page2idx都按照0x1 &lt;&lt; 3 = 0x8对齐&#xff08;这个Page对应的内存页的物理地址不一定按照0x8000对齐&#xff09;&#xff0c;所以page2idx(p0) &amp; 7应该成立。<br /><br />3. 你在简化过程中的问题应该是对page2idx的理解有偏差。在你的输出中&#xff1a;</p>\n<p><br /><tt>   begin = 0000000000416000,end = 000000000fffe000,count = 64488</tt><br /><tt>   -------------buddy_init_memmap()-----------</tt><br /><tt>   page2pa(base) = 0000000000416000</tt><br /><tt>   page2idx(base) = 1046</tt><br /><br />既然是从0x416000开始的zone&#xff0c;那么page2idx(base)的值应该是相对于0x416000的idx&#xff0c;也就是0。<br /><br />P.S. 建议贴代码时略去不想关的部分&#xff0c;这样其它同学在阅读时能更容易定位关键部分&#xff0c;谢谢&#xff01;</p>", "children": [], "type": "feedback", "created": "2015-03-03T06:21:28Z", "id": "i6swqkvbuteql"}], "type": "followup", "no_answer": 0, "created": "2015-03-03T03:21:30Z", "id": "i6sqb4ybnpa4ye"}], "request_instructor": 0, "tags": ["lab2", "quiz3", "student"], "s_edits": [], "num_favorites": 1}, "aid": "iajgu6peck826v"}