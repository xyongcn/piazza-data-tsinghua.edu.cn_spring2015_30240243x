{"aid": "j2pql4gm8yk1uu", "result": {"status": "active", "unique_views": 33, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-05-06T14:47:56Z", "data": "j2ddw434mc24ei", "uid": "ikjdo9jtz0e2jq"}, {"type": "update", "anon": "no", "when": "2017-05-06T14:49:10Z", "data": "j2ddxp946fp4tl", "uid": "ikjdo9jtz0e2jq"}, {"to": "j2ddw43190u4eh", "anon": "no", "when": "2017-05-06T15:22:06Z", "type": "followup", "uid": "i5g31e12hcr27s"}, {"type": "update", "anon": "no", "when": "2017-05-07T06:12:55Z", "data": "j2eaxnekcfb4ei", "uid": "ikjdo9jtz0e2jq"}, {"to": "j2ddw43190u4eh", "anon": "no", "when": "2017-05-08T13:55:11Z", "type": "followup", "uid": "izb0cbqbyzd6wf"}, {"type": "update", "anon": "no", "when": "2017-05-12T05:49:21Z", "data": "j2lfaltfshs4pw", "uid": "ikjdo9jtz0e2jq"}], "upvote_ids": [], "id": "j2ddw43190u4eh", "bookmarked": 4, "tags": ["lecture18", "student"], "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2017-05-06T15:22:06Z", "no_upvotes": 0, "uid": "i5g31e12hcr27s", "created": "2017-05-06T15:22:06Z", "type": "followup", "no_answer": 0, "id": "j2df429qerv2rf", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p><a href=\"https://gist.github.com/mengcz13/c032ef918cf8ceb34761cc207c9a80ed\">https://gist.github.com/mengcz13/c032ef918cf8ceb34761cc207c9a80ed</a></p>\n<p></p>\n<pre>Barber is sleeping...\n1 customer entered, and 0 customers are waiting...\n1 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n1\t0\t0\t0\nBarber starts working...\n2 customer entered, and 0 customers are waiting...\n2 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n2\t0\t0\t1\n3 customer entered, and 1 customers are waiting...\n3 customer sits at 1!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n2\t3\t0\t1\nCustomer 1 has just had his hair cut!\nBarber starts working...\nCustomer 2 has just had his hair cut!\nBarber starts working...\nCustomer 3 has just had his hair cut!\nBarber is sleeping...\n4 customer entered, and 0 customers are waiting...\n4 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n4\t0\t0\t0\nBarber starts working...\n5 customer entered, and 0 customers are waiting...\n5 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n5\t0\t0\t4\n6 customer entered, and 1 customers are waiting...\n6 customer sits at 1!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n5\t6\t0\t4\nCustomer 4 has just had his hair cut!\nBarber starts working...\n7 customer entered, and 1 customers are waiting...\n7 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n7\t6\t0\t5\n8 customer entered, and 2 customers are waiting...\n8 customer sits at 2!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n7\t6\t8\t5\nCustomer 5 has just had his hair cut!\nBarber starts working...\nCustomer 6 has just had his hair cut!\nBarber starts working...\n9 customer entered, and 1 customers are waiting...\n9 customer sits at 0!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n9\t0\t8\t7\n10 customer entered, and 2 customers are waiting...\n10 customer sits at 1!\nSEAT0\tSEAT1\tSEAT2\tBARBERSEAT\n9\t10\t8\t7\nCustomer 7 has just had his hair cut!\nBarber starts working...\nCustomer 8 has just had his hair cut!\nBarber starts working...\nCustomer 9 has just had his hair cut!\nBarber starts working...\nCustomer 10 has just had his hair cut!\nBarber is sleeping...</pre>\n<p></p>"}, {"folders": [], "updated": "2017-05-08T13:55:11Z", "no_upvotes": 0, "uid": "izb0cbqbyzd6wf", "created": "2017-05-08T13:55:11Z", "type": "followup", "no_answer": 1, "id": "j2g6vzs5en76uk", "anon": "no", "bucket_name": "This week", "config": {}, "bucket_order": 4, "data": null, "children": [], "subject": "<p>我使用 nodejs 重新实现了一下这个问题.</p>\n<p></p>\n<p>nodejs 的好处在于原生支持异步, 但是实际上是单线程执行, 一个函数执行过程中不会因为时钟中断而挂起, 相当于每个函数自带了锁. 所以更方便研究同步问题. </p>\n<p></p>\n<p>我使用了 sempahore 这个库的信号量. 然后先写了一个能正常输出的版本.</p>\n<p></p>\n<pre>const chairs = 5;\nconst barbers = 1;\nconst comeTime = [ 1, 2, 3, 5, 5, 5, 5, 25 ];\nconst costTime = [ 1, 1, 1, 1, 1, 1, 4, 7 ];\n\nvar Semaphore = require(&#39;semaphore&#39;);\nvar waitingQue = new Semaphore(1);\nvar waitingCount = 0;\nvar barber = new Semaphore(barbers);\n\nvar beginTime = Date.now();\n\nvar clock = function() {\n    return Date.now() - beginTime;\n};\n\nvar customerCome = function(timeConsume, callback) {\n    if (waitingCount &gt;= chairs) {\n        return callback(0, clock());\n    }\n    &#43;&#43; waitingCount;\n    callback(-1, clock());\n    waitingQue.take(function() {\n        barber.take(function() {\n            waitingQue.leave();\n            callback(1, clock());\n            -- waitingCount;\n            setTimeout(function() {\n                barber.leave();\n                callback(2, clock());\n            }, timeConsume);\n        });\n    });\n};\n\n(function() {\n    var customers = {};\n    var actmap = {\n        &#39;-2&#39;: &#39; &#39;,\n        &#39;-1&#39;: &#39;.&#39;,\n        &#39;0&#39;: &#39; &#39;,\n        &#39;1&#39;: &#39;|&#39;,\n        &#39;2&#39;: &#39; &#39;\n    };\n    var formated = [];\n    var endMark = new Semaphore(1);\n    var n = comeTime.length;\n    for (var i = 0; i &lt; n; &#43;&#43; i) {\n        customers[i] = -2;\n        endMark.take(function() {});\n        (function(i) {\n            setTimeout(function() {\n                customerCome(costTime[i], function(stat, time) {\n                    customers[i] = stat;\n                    var line = [];\n                    for (var j = 0; j &lt; n; &#43;&#43; j) {\n                        line.push(actmap[customers[j]]);\n                    }\n                    var action = &#39;unknown&#39;;\n                    if (stat === -1) {\n                        action = &#39;starts waiting&#39;;\n                    } else if (stat === 0) {\n                        action = &#39;left with anger&#39;;\n                        line[i] = &#39;g&#39;;\n                    } else if (stat === 1) {\n                        action = &#39;starts being served&#39;;\n                        line[i] = &#39;v&#39;;\n                    } else if (stat === 2) {\n                        action = &#39;finishes his barber&#39;;\n                        line[i] = &#39;^&#39;;\n                    }\n                    console.log(&#39;Customer &#39; &#43; i &#43; &#39; &#39; &#43; action &#43; &#39; at &#39; &#43; time);\n                    formated.push(line.join(&#39; &#39;));\n                    if (stat === 0 || stat === 2) {\n                        endMark.leave();\n                    }\n                });\n            }, comeTime[i]);\n        })(i);\n    }\n    endMark.take(function() {\n        console.log(formated.join(&#39;\\n&#39;));\n    });\n})();</pre>\n<p></p>\n<p>这里可以在程序开头位置自定义测试用例. 经过各种例子的测试感觉没有问题.</p>\n<p></p>\n<p>其中我用了一个初值为 1 的信号量 waitingQueue. 它的第一个可以称作 &#34;活跃顾客&#34;, 这个人会作为唯一一个正在等理发师的顾客. 而另外几个人会乖乖坐在椅子上.</p>\n<p></p>\n<p>然后我发现没有必要为 &#34;椅子&#34; (即等待队列) 单独开一个信号量. 因为 &#34;理发师&#34; 这个信号量自带了一个队列, 如果不用或者像上面一样只放一个元素, 那就浪费了. 所以直接将 &#34;理发师&#34; 这个信号量的等待队列视作 5 把椅子, 只保留 waitingCount 就可以了.</p>\n<p></p>\n<p>新的 customerCome 代码如下.</p>\n<p></p>\n<pre>var customerCome = function(timeConsume, callback) {\n    if (waitingCount &gt;= chairs) {\n        return callback(0, clock());\n    }\n    &#43;&#43; waitingCount;\n    callback(-1, clock());\n    barber.take(function() {\n        callback(1, clock());\n        -- waitingCount;\n        setTimeout(function() {\n            barber.leave();\n            callback(2, clock());\n        }, timeConsume);\n    });\n};</pre>\n<p></p>\n<p>可能这样的逻辑没有使用两个信号量清楚, 但是实现的功能是完全一样的. 更进一步, 我认为原题作者就是想让我们用 &#34;理发师&#34; 和 &#34;椅子&#34; 来更加充分地理解信号量调度同步互斥进程的过程.</p>"}], "nr": 1069, "bucket_order": 2, "type": "note", "folders": ["lecture18"], "no_answer_followup": 1, "num_favorites": 1, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2017-05-06T14:47:56Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1494828992470, "tag_good": [{"name": "Yong XIANG", "admin": true, "photo": null, "us": false, "id": "hdjonbiyfs62ie", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "email": "xyong@tsinghua.edu.cn", "admin_permission": 10}], "tag_good_arr": ["hdjonbiyfs62ie"], "history": [{"content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>之前的解法存在问题&#xff0c;因为试图获得一个信号量的等待队列在linux中是不太理智的行为&#xff0c;麻烦很大&#xff0c;所以我放弃了这一尝试。</p>\n<p>目前解法&#xff0c;设置顾客15名&#xff0c;在15秒内分散来到&#xff0c;理发时间3秒&#xff0c;测试用例已完善。</p>\n<pre>#include &lt;pthread.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;unistd.h&gt; <br />#include &lt;stdlib.h&gt;<br />#include &lt;semaphore.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;assert.h&gt;<br />#define N 15<br />typedef struct{<br />int num;<br />int time;<br />}arg;<br />int b[]={1,10,3,9,4,8,5,6,7,6,4,6,7,8};<br />//信号量和控制量定义<br />sem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务<br />sem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请<br />sem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客<br />sem_t mutex;<br />int current=-1;<br />int numofseats=5;//共5个空位<br />//理发师线程<br />void*barber(){<br />\twhile(1){<br />\t\tsem_wait(&amp;custready);//等待顾客到来<br />\t\tsem_wait(&amp;accessseats);//进入临界区<br />\t\tnumofseats&#43;=1;//座位增加<br />\t\tsem_post(&amp;barbeready);//理发师做好准备<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tsem_wait(&amp;mutex);<br />\t\tprintf(&#34;barber is serving %d\\n&#34;,current);//一个顾客接受服务<br />\t\tsleep(3);//3秒钟理发时间<br />\t\tprintf(&#34;%d over\\n&#34;,current);<br />\t}<br />\treturn NULL;<br />}<br />void*customer(void*args){<br />\tint*arg=(int*)args;<br />\tif(arg[0]%3==0)sleep(0);<br />\telse if(arg[0]%3==1)sleep(10);<br />\telse sleep(arg[1]);<br />\tsem_wait(&amp;accessseats);//进入临界区<br />\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\tprintf(&#34;come\\n&#34;,arg[0]);//宣告到来<br />\tif(numofseats&gt;0){//判断是否有空位<br />\t\tnumofseats-=1;<br />\t\tsem_post(&amp;custready);//宣告顾客到来<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;waiting\\n&#34;,arg[0]);<br />\t\tsem_wait(&amp;barbeready);//等待理发师准备<br />\t\tcurrent=arg[0];<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;served\\n&#34;,arg[0]);<br />\t\tsem_post(&amp;mutex);<br />\t}<br />\telse{<br />\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;leave\\n&#34;,arg[0]);<br />\t}<br />\treturn NULL;<br />}<br />int main(){<br />\t//以下对信号量进行初始化<br />\tsem_init(&amp;barbeready,0,0);<br />\tsem_init(&amp;accessseats,0,1);<br />\tsem_init(&amp;custready,0,0);<br />\tsem_init(&amp;mutex,0,0);<br />\tprintf(&#34;barber\\t&#34;);<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)printf(&#34;%d\\t&#34;,i);<br />\tprintf(&#34;\\n&#34;);<br />\t//创建1个理发师和N个顾客线程<br />\tpthread_t*barberid=malloc(sizeof(pthread_t));<br />\tpthread_create(barberid,NULL,barber,NULL);<br />\targ*a=malloc(N*sizeof(arg));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;){<br />\t\ta[i].num=i;<br />\t\ta[i].time=b[i];<br />\t}<br />\tpthread_t*customerid=malloc(N*sizeof(pthread_t));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(a[i]));<br />\tsleep(36);<br />\treturn 0;<br />}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>barber\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t11\t12\t13\t14\t<br />\tcome<br />\twaiting<br />\t\t\t\tcome<br />\t\t\t\twaiting<br />\tserved<br />barber is serving 0<br />\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />\t\t\tcome<br />\t\t\twaiting<br />0 over<br />\t\t\t\tserved<br />barber is serving 3<br />\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />3 over<br />\t\t\t\t\t\t\tserved<br />barber is serving 6<br />\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\tcome<br />\t\t\t\t\t\tleave<br />6 over<br />\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 9<br />\t\t\t\t\tcome<br />\t\t\t\t\twaiting<br />\t\tcome<br />\t\tleave<br />\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave<br />\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave<br />9 over<br />\t\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 12<br />12 over<br />\t\t\tserved<br />barber is serving 2<br />2 over<br />\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 11<br />11 over<br />\t\t\t\t\t\t\t\t\tserved<br />barber is serving 8<br />8 over<br />\t\t\t\t\tserved<br />barber is serving 4<br />4 over</pre>", "anon": "no", "created": "2017-05-12T05:49:21Z", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题"}, {"content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>之前的解法存在问题&#xff0c;因为试图获得一个信号量的等待队列在linux中是不太理智的行为&#xff0c;麻烦很大&#xff0c;所以我放弃了这一尝试。</p>\n<p>目前解法&#xff0c;设置顾客15名&#xff0c;在15秒内分散来到&#xff0c;理发时间3秒。&#xff08;测试用例待完善&#xff0c;目前测试是有5名顾客在第0秒到来&#xff0c;5名顾客在第10秒到来&#xff0c;其他顾客随机到来&#xff09;</p>\n<pre>#include &lt;pthread.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;unistd.h&gt; <br />#include &lt;stdlib.h&gt;<br />#include &lt;semaphore.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;assert.h&gt;<br />#define N 15<br />//信号量和控制量定义<br />sem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务<br />sem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请<br />sem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客<br />sem_t mutex;<br />int current=-1;<br />int numofseats=5;//共5个空位<br />//理发师线程<br />void*barber(){<br />\twhile(1){<br />\t\tsem_wait(&amp;custready);//等待顾客到来<br />\t\tsem_wait(&amp;accessseats);//进入临界区<br />\t\tnumofseats&#43;=1;//座位增加<br />\t\tsem_post(&amp;barbeready);//理发师做好准备<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tsem_wait(&amp;mutex);<br />\t\tprintf(&#34;barber is serving %d\\n&#34;,current);//一个顾客接受服务<br />\t\tsleep(3);//3秒钟理发时间<br />\t\tprintf(&#34;%d over\\n&#34;,current);<br />\t}<br />\treturn NULL;<br />}<br />void*customer(void*args){<br />\tint*arg=(int*)args;<br />\tif(arg[0]%3==0)sleep(0);<br />\telse if(arg[0]%3==1)sleep(10);<br />\telse sleep(rand()%N);<br />\tsem_wait(&amp;accessseats);//进入临界区<br />\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\tprintf(&#34;come\\n&#34;,arg[0]);//宣告到来<br />\tif(numofseats&gt;0){//判断是否有空位<br />\t\tnumofseats-=1;<br />\t\tsem_post(&amp;custready);//宣告顾客到来<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;waiting\\n&#34;,arg[0]);<br />\t\tsem_wait(&amp;barbeready);//等待理发师准备<br />\t\tcurrent=arg[0];<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;served\\n&#34;,arg[0]);<br />\t\tsem_post(&amp;mutex);<br />\t}<br />\telse{<br />\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区<br />\t\tfor(int i=0;i&lt;=arg[0];i&#43;&#43;)printf(&#34;\\t&#34;);<br />\t\tprintf(&#34;leave\\n&#34;,arg[0]);<br />\t}<br />\treturn NULL;<br />}<br />int main(){<br />\t//以下对信号量进行初始化<br />\tsem_init(&amp;barbeready,0,0);<br />\tsem_init(&amp;accessseats,0,1);<br />\tsem_init(&amp;custready,0,0);<br />\tsem_init(&amp;mutex,0,0);<br />\tprintf(&#34;barber\\t&#34;);<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)printf(&#34;%d\\t&#34;,i);<br />\tprintf(&#34;\\n&#34;);<br />\t//创建1个理发师和N个顾客线程<br />\tpthread_t*barberid=malloc(sizeof(pthread_t));<br />\tpthread_create(barberid,NULL,barber,NULL);<br />\tint*num=malloc(N*sizeof(int));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)num[i]=i;<br />\tpthread_t*customerid=malloc(N*sizeof(pthread_t));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(num[i]));<br />\tsleep(36);<br />\treturn 0;<br />}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>barber\t0\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10\t11\t12\t13\t14\t<br />\tcome<br />\twaiting<br />\t\t\t\tcome<br />\t\t\t\twaiting<br />\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />\tserved<br />barber is serving 0<br />\t\t\t\t\t\tcome<br />\t\t\t\t\t\twaiting<br />0 over<br />\t\t\t\tserved<br />barber is serving 3<br />3 over<br />\t\t\t\t\t\t\tserved<br />barber is serving 6<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twaiting<br />6 over<br />\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 9<br />\t\tcome<br />\t\twaiting<br />\t\t\t\t\tcome<br />\t\t\t\t\twaiting<br />\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\tleave<br />\t\t\t\t\t\t\t\t\tcome<br />\t\t\t\t\t\t\t\t\tleave<br />9 over<br />\t\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 12<br />\t\t\tcome<br />\t\t\twaiting<br />12 over<br />\t\t\t\t\t\tserved<br />barber is serving 5<br />5 over<br />\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tserved<br />barber is serving 14<br />14 over<br />\t\tserved<br />barber is serving 1<br />1 over<br />\t\t\t\t\tserved<br />barber is serving 4<br />4 over<br />\t\t\tserved<br />barber is serving 2<br />2 over</pre>", "anon": "no", "created": "2017-05-07T06:12:55Z", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题"}, {"content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>Linux解法&#xff0c;设置顾客100名&#xff0c;在100秒内分散来到&#xff0c;理发时间3秒。</p>\n<pre>#include &lt;pthread.h&gt; \n#include &lt;stdio.h&gt; \n#include &lt;unistd.h&gt; \n#include &lt;stdlib.h&gt;\n#include &lt;semaphore.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;assert.h&gt;\n#define N 100\n//链表操作\ntypedef struct n{\n\tstruct n*next;\n\tstruct n*prev;\n\tint i;\n}node;\nnode*header,*trailer;\nint dequeue(){\n\tnode*d=header-&gt;next;\n\tassert(d!=trailer);\n\td-&gt;prev-&gt;next=d-&gt;next;\n\td-&gt;next-&gt;prev=d-&gt;prev;\n\tint result=d-&gt;i;\n\tfree(d);\n\treturn result;\n}\nvoid enqueue(int result){\n\tnode*d=malloc(sizeof(node));\n\td-&gt;i=result;\n\td-&gt;next=trailer;\n\td-&gt;prev=trailer-&gt;prev;\n\ttrailer-&gt;prev=d;\n\td-&gt;prev-&gt;next=d;\n}\n//输出链表信息\nvoid printwaiting(){\n\tprintf(&#34;waiting: &#34;);\n\tfor(node*n=header-&gt;next;n!=trailer;n=n-&gt;next)printf(&#34;%d\\t&#34;,n-&gt;i);\n\tprintf(&#34;\\n&#34;);\n}\n//信号量和控制量定义\nsem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务\nsem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请\nsem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客\nint numofseats=5;//共5个空位\n//理发师线程\nvoid*barber(){\n\twhile(1){\n\t\tsem_wait(&amp;custready);//等待顾客到来\n\t\tsem_wait(&amp;accessseats);//进入临界区\n\t\tnumofseats&#43;=1;//座位增加\n\t\tsem_post(&amp;barbeready);//理发师做好准备\n\t\tsem_post(&amp;accessseats);//离开临界区\n\t\tprintwaiting();\n\t\tprintf(&#34;%d is served\\n&#34;,dequeue());//队首接受服务\n\t\tsleep(3);//3秒钟理发时间\n\t}\n\treturn NULL;\n}\nvoid*customer(void*args){\n\tint*arg=(int*)args;\n\tsleep(rand()%N);\n\tsem_wait(&amp;accessseats);//进入临界区\n\tprintf(&#34;%d comes\\n&#34;,arg[0]);//宣告到来\n\tif(numofseats&gt;0){//判断是否有空位\n\t\tnumofseats-=1;\n\t\tenqueue(arg[0]);//自己入队\n\t\tsem_post(&amp;custready);//宣告顾客到来\n\t\tsem_post(&amp;accessseats);//离开临界区\n\t\tsem_wait(&amp;barbeready);//等待理发师准备;不可以和上一句颠倒&#xff0c;否则理发师进程虽然可以得到barbeready信号量做好准备&#xff0c;但不能进入临界区&#xff0c;造成死锁。\n\t}\n\telse{\n\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区\n\t\tprintf(&#34;%d leave\\n&#34;,arg[0]);\n\t}\n\treturn NULL;\n}\nint main(){\n\t//以下对链表进行初始化\n\theader=malloc(sizeof(node));\n\ttrailer=malloc(sizeof(node));\n\theader-&gt;prev=trailer-&gt;next=NULL;\n\theader-&gt;i=trailer-&gt;i=-1;\n\theader-&gt;next=trailer;\n\ttrailer-&gt;prev=header;\n\t//以下对信号量进行初始化\n\tsem_init(&amp;barbeready,0,0);\n\tsem_init(&amp;accessseats,0,1);\n\tsem_init(&amp;custready,0,0);\n\t//创建1个理发师和N个顾客线程\n\tpthread_t*barberid=malloc(sizeof(pthread_t));\n\tpthread_create(barberid,NULL,barber,NULL);\n\tint*num=malloc(N*sizeof(int));\n\tfor(int i=0;i&lt;N;i&#43;&#43;)num[i]=i;\n\tpthread_t*customerid=malloc(N*sizeof(pthread_t));\n\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(num[i]));\n\tsleep(110);\n\treturn 0;\n}\n</pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>31 comes\nwaiting: 31\t\n31 is served\n86 comes\nwaiting: 86\t\n86 is served\n60 comes\n65 comes\nwaiting: 60\t65\t\n60 is served\n81 comes\n20 comes\n38 comes\nwaiting: 65\t81\t20\t38\t\n65 is served\n95 comes\n50 comes\n68 comes\n68 leave\nwaiting: 81\t20\t38\t95\t50\t\n81 is served\n74 comes\n4 comes\n4 leave\n48 comes\n48 leave\nwaiting: 20\t38\t95\t50\t74\t\n20 is served\n43 comes\nwaiting: 38\t95\t50\t74\t43\t\n38 is served\n9 comes\n42 comes\n42 leave\n32 comes\n32 leave\n27 comes\n27 leave\nwaiting: 95\t50\t74\t43\t9\t\n95 is served\n47 comes\n70 comes\n70 leave\n61 comes\n61 leave\n15 comes\n15 leave\n17 comes\n17 leave\n51 comes\n51 leave\nwaiting: 50\t74\t43\t9\t47\t\n50 is served\n96 comes\n11 comes\n11 leave\n63 comes\n63 leave\n23 comes\n23 leave\n30 comes\n30 leave\n40 comes\n40 leave\n67 comes\n67 leave\nwaiting: 74\t43\t9\t47\t96\t\n74 is served\n25 comes\n90 comes\n90 leave\nwaiting: 43\t9\t47\t96\t25\t\n43 is served\n76 comes</pre>\n<p></p>", "anon": "no", "created": "2017-05-06T14:49:10Z", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题"}, {"content": "<p> 理发师问题&#xff1a;理发店理有一位理发师、一把理发椅和5把供等候理发的顾客坐的椅子。如果没有顾客&#xff0c;理发师便在理发椅上睡觉。一个顾客到来时&#xff0c;它必须叫醒理发师&#xff0c;如果理发师正在理发时又有顾客来到&#xff0c;则如果有空椅子可坐&#xff0c;就坐下来等待&#xff0c;否则就离开。</p>\n<p>Linux解法&#xff1a;</p>\n<pre>#include &lt;pthread.h&gt; <br />#include &lt;stdio.h&gt; <br />#include &lt;unistd.h&gt; <br />#include &lt;stdlib.h&gt;<br />#include &lt;semaphore.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;assert.h&gt;<br />#define N 100<br />//链表操作<br />typedef struct n{<br />\tstruct n*next;<br />\tstruct n*prev;<br />\tint i;<br />}node;<br />node*header,*trailer;<br />int dequeue(){<br />\tnode*d=header-&gt;next;<br />\tassert(d!=trailer);<br />\td-&gt;prev-&gt;next=d-&gt;next;<br />\td-&gt;next-&gt;prev=d-&gt;prev;<br />\tint result=d-&gt;i;<br />\tfree(d);<br />\treturn result;<br />}<br />void enqueue(int result){<br />\tnode*d=malloc(sizeof(node));<br />\td-&gt;i=result;<br />\td-&gt;next=trailer;<br />\td-&gt;prev=trailer-&gt;prev;<br />\ttrailer-&gt;prev=d;<br />\td-&gt;prev-&gt;next=d;<br />}<br />//输出链表信息<br />void printwaiting(){<br />\tprintf(&#34;waiting: &#34;);<br />\tfor(node*n=header-&gt;next;n!=trailer;n=n-&gt;next)printf(&#34;%d\\t&#34;,n-&gt;i);<br />\tprintf(&#34;\\n&#34;);<br />}<br />//信号量和控制量定义<br />sem_t barbeready;//为0表示理发师未准备好&#xff0c;顾客需等待;为1表示可以服务<br />sem_t accessseats;//每一个线程都需要在开头申请&#xff0c;在结尾释放&#xff0c;与临界区类似&#xff0c;为1表示可以申请<br />sem_t custready;//为0表示没有顾客&#xff0c;理发师睡觉;不为0表示有顾客<br />int numofseats=5;//共5个空位<br />//理发师线程<br />void*barber(){<br />\twhile(1){<br />\t\tsem_wait(&amp;custready);//等待顾客到来<br />\t\tsem_wait(&amp;accessseats);//进入临界区<br />\t\tnumofseats&#43;=1;//座位增加<br />\t\tsem_post(&amp;barbeready);//理发师做好准备<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tprintwaiting();<br />\t\tprintf(&#34;%d is served\\n&#34;,dequeue());//队首接受服务<br />\t\tsleep(3);//3秒钟理发时间<br />\t}<br />\treturn NULL;<br />}<br />void*customer(void*args){<br />\tint*arg=(int*)args;<br />\tsleep(rand()%N);<br />\tsem_wait(&amp;accessseats);//进入临界区<br />\tprintf(&#34;%d comes\\n&#34;,arg[0]);//宣告到来<br />\tif(numofseats&gt;0){//判断是否有空位<br />\t\tnumofseats-=1;<br />\t\tenqueue(arg[0]);//自己入队<br />\t\tsem_post(&amp;custready);//宣告顾客到来<br />\t\tsem_post(&amp;accessseats);//离开临界区<br />\t\tsem_wait(&amp;barbeready);//等待理发师准备;不可以和上一句颠倒&#xff0c;否则理发师进程虽然可以得到barbeready信号量做好准备&#xff0c;但不能进入临界区&#xff0c;造成死锁。<br />\t}<br />\telse{<br />\t\tsem_post(&amp;accessseats);//没有座位&#xff0c;直接离开临界区<br />\t\tprintf(&#34;%d leave\\n&#34;,arg[0]);<br />\t}<br />\treturn NULL;<br />}<br />int main(){<br />\t//以下对链表进行初始化<br />\theader=malloc(sizeof(node));<br />\ttrailer=malloc(sizeof(node));<br />\theader-&gt;prev=trailer-&gt;next=NULL;<br />\theader-&gt;i=trailer-&gt;i=-1;<br />\theader-&gt;next=trailer;<br />\ttrailer-&gt;prev=header;<br />\t//以下对信号量进行初始化<br />\tsem_init(&amp;barbeready,0,0);<br />\tsem_init(&amp;accessseats,0,1);<br />\tsem_init(&amp;custready,0,0);<br />\t//创建1个理发师和N个顾客线程<br />\tpthread_t*barberid=malloc(sizeof(pthread_t));<br />\tpthread_create(barberid,NULL,barber,NULL);<br />\tint*num=malloc(N*sizeof(int));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)num[i]=i;<br />\tpthread_t*customerid=malloc(N*sizeof(pthread_t));<br />\tfor(int i=0;i&lt;N;i&#43;&#43;)pthread_create(&amp;customerid[i],NULL,customer,&amp;(num[i]));<br />\tsleep(110);<br />\treturn 0;<br />}<br /></pre>\n<p>参考了https://en.wikipedia.org/wiki/Sleeping_barber_problem。部分输出如下&#xff1a;</p>\n<pre>31 comes<br />waiting: 31\t<br />31 is served<br />86 comes<br />waiting: 86\t<br />86 is served<br />60 comes<br />65 comes<br />waiting: 60\t65\t<br />60 is served<br />81 comes<br />20 comes<br />38 comes<br />waiting: 65\t81\t20\t38\t<br />65 is served<br />95 comes<br />50 comes<br />68 comes<br />68 leave<br />waiting: 81\t20\t38\t95\t50\t<br />81 is served<br />74 comes<br />4 comes<br />4 leave<br />48 comes<br />48 leave<br />waiting: 20\t38\t95\t50\t74\t<br />20 is served<br />43 comes<br />waiting: 38\t95\t50\t74\t43\t<br />38 is served<br />9 comes<br />42 comes<br />42 leave<br />32 comes<br />32 leave<br />27 comes<br />27 leave<br />waiting: 95\t50\t74\t43\t9\t<br />95 is served<br />47 comes<br />70 comes<br />70 leave<br />61 comes<br />61 leave<br />15 comes<br />15 leave<br />17 comes<br />17 leave<br />51 comes<br />51 leave<br />waiting: 50\t74\t43\t9\t47\t<br />50 is served<br />96 comes<br />11 comes<br />11 leave<br />63 comes<br />63 leave<br />23 comes<br />23 leave<br />30 comes<br />30 leave<br />40 comes<br />40 leave<br />67 comes<br />67 leave<br />waiting: 74\t43\t9\t47\t96\t<br />74 is served<br />25 comes<br />90 comes<br />90 leave<br />waiting: 43\t9\t47\t96\t25\t<br />43 is served<br />76 comes</pre>\n<p></p>", "anon": "no", "created": "2017-05-06T14:47:56Z", "uid": "ikjdo9jtz0e2jq", "subject": "理发师问题"}]}, "error": null}