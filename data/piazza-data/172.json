{"aid": "igkp91wfutt5tl", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 5, "request_instructor": 0, "history": [{"uid": "i72xyao1QhO", "anon": "no", "created": "2015-03-24T14:22:22Z", "content": "<p>1. 做lab2的第二个实验的时候,老是出问题,一直没能通过,后来对比下答案,发现答案里面在中间<br />        memset(KADDR(pa), 0, PGSIZE);</p>\n<p>的时候就用到了KADDR, 将内核的虚拟地址提高了0xC0000000, 找了下memset的实现发现其就是一字节一字节的拷贝, 可能是在cpu内部做了地址转换,在init中发现,在页目录还没挂在boot_cr3上前就用到了,如下:</p>\n<p>    boot_pgdir = boot_alloc_page();<br />    memset(boot_pgdir, 0, PGSIZE);<br />    boot_cr3 = PADDR(boot_pgdir);</p>\n<p>这种转换,在windows下面貌似是内核态和用户态2G对分,但linux是1:3对分,这种设置在代码中没见着,硬件是怎么区分的?</p>\n<p>2. 另外: boot_pgdir = boot_alloc_page();  而boot_alloc_page -&gt; page2kva得到的,其实现代码如下:</p>\n<p>static inline void *<br />page2kva(struct Page *page) {<br />    return KADDR(page2pa(page));<br />}</p>\n<p>这段中在找位置的时候加了个KADDR,难道不会超过4G?当然在系统初始化的时候可以肯定不会超过,但是在系统运行以后,内存占用的多了,后面系统自己在alloc的时候,说不定位置就比较靠后了,那么此时的KADDR(page2pa(page)很有可能超过4G啊,对于指针来说怎么寻址?我没看懂..</p>", "subject": "关于内核地址(lab2的第二个实验)"}, {"uid": "i72xyao1QhO", "anon": "no", "created": "2015-03-24T14:12:24Z", "content": "<p>1. 做lab2的第二个实验的时候,老是出问题,一直没能通过,后来对比下答案,发现答案里面在中间<br />        memset(KADDR(pa), 0, PGSIZE);</p>\n<p>的时候就用到了KADDR, 将内核的虚拟地址提高了0xC0000000, 找了下memset的实现发现其就是一字节一字节的拷贝, 可能是在cpu内部做了地址转换,在init中发现,在页目录还没挂在boot_cr3上前就用到了,如下:</p>\n<p>    boot_pgdir = boot_alloc_page();<br />    memset(boot_pgdir, 0, PGSIZE);<br />    boot_cr3 = PADDR(boot_pgdir);</p>\n<p>这种转换,在windows下面貌似是内核态和用户态2G对分,但linux是1:3对分,这种设置在代码中没见着,硬件是怎么区分的?</p>\n<p>2. 另外: boot_pgdir = boot_alloc_page();  而boot_alloc_page -&gt; page2kva得到的,其实现代码如下:</p>\n<p>static inline void *<br />page2kva(struct Page *page) {<br />    return KADDR(page2pa(page));<br />}</p>\n<p>这段中在找位置的时候加了个KADDR,难道不会超过4G?当然在系统初始化的时候可以肯定不会超过,但是在系统运行以后,内存占用的多了,后面系统自己在alloc的时候,说不定位置就比较靠后了,那么此时的KADDR(page2pa(page)很有可能超过4G啊,对于指针来说怎么寻址?我没看懂..</p>\n<p>3. 最后索引pde数组的时候还是用的KADDR, 额......这个索引不能理解.....如下:</p>\n<p>        &amp;((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</p>\n<p>三个问题都是一个:内核地址转换.....</p>", "subject": "关于内核地址(lab2的第二个实验)"}, {"uid": "i72xyao1QhO", "anon": "no", "created": "2015-03-24T14:11:36Z", "content": "<p>1. 做lab2的第二个实验的时候,老是出问题,一直没能通过,后来对比下答案,发现答案里面在中间<br />        memset(KADDR(pa), 0, PGSIZE);</p>\n<p>的时候就用到了KADDR, 将内核的虚拟地址提高了0xC0000000, 找了下memset的实现发现其就是一字节一字节的拷贝, 可能是在cpu内部做了地址转换,在init中发现,在页目录还没挂在boot_cr3上前就用到了,如下:</p>\n<p>    boot_pgdir = boot_alloc_page();<br />    memset(boot_pgdir, 0, PGSIZE);<br />    boot_cr3 = PADDR(boot_pgdir);</p>\n<p>这种转换,在windows下面貌似是内核态和用户态2G对分,但linux是1:3对分,这种设置在代码中没见着,硬件是怎么区分的?</p>\n<p>2. 另外: boot_pgdir = boot_alloc_page();  而boot_alloc_page -&gt; page2kva得到的,其实现代码如下:</p>\n<p>static inline void *<br />page2kva(struct Page *page) {<br />    return KADDR(page2pa(page));<br />}</p>\n<p>这段中在找位置的时候加了个KADDR,难道不会超过4G?当然在系统初始化的时候可以肯定不会超过,但是在系统运行以后,内存占用的多了,后面系统自己在alloc的时候,说不定位置就比较靠后了,那么此时的KADDR(page2pa(page)很有可能超过4G啊,对于指针来说怎么寻址?我没看懂..</p>\n<p>3. 最后索引pde数组的时候还是用的KADDR, 如下:</p>\n<p>        &amp;((pte_t *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</p>\n<p> 真是不能理解了!</p>\n<p>三个问题都是一个:内核地址转换.....</p>", "subject": "关于内核地址(lab2的第二个实验)"}, {"uid": "i72xyao1QhO", "anon": "no", "created": "2015-03-24T13:48:56Z", "content": "<p>1. 做lab2的第二个实验的时候,老是出问题,一直没能通过,后来对比下答案,发现答案里面在中间<br />        memset(KADDR(pa), 0, PGSIZE);</p>\n<p>的时候就用到了KADDR, 将内核的虚拟地址提高了0xC0000000, 找了下memset的实现发现其就是一字节一字节的拷贝, 可能是在cpu内部做了地址转换,在init中发现,在页目录还没挂在boot_cr3上前就用到了,如下:</p>\n<p>    boot_pgdir = boot_alloc_page();<br />    memset(boot_pgdir, 0, PGSIZE);<br />    boot_cr3 = PADDR(boot_pgdir);</p>\n<p>这种转换,在windows下面貌似是内核态和用户态2G对分,但linux是1:3对分,这种设置在代码中没见着,硬件是怎么区分的?</p>\n<p>2. 另外: boot_pgdir = boot_alloc_page();  而boot_alloc_page -&gt; page2kva得到的,其实现代码如下:</p>\n<p>static inline void *<br />page2kva(struct Page *page) {<br />    return KADDR(page2pa(page));<br />}</p>\n<p>这段中在找位置的时候加了个KADDR,难道不会超过4G?当然在系统初始化的时候可以肯定不会超过,但是在系统运行以后,内存占用的多了,后面系统自己在alloc的时候,说不定位置就比较靠后了,那么此时的KADDR(page2pa(page)很有可能超过4G啊,对于指针来说怎么寻址?我没看懂..</p>", "subject": "关于内核地址(lab2的第二个实验)"}], "s_edits": [], "is_bookmarked": false, "tag_good_arr": [], "request_instructor_me": false, "my_favorite": false, "t": 1446635207391, "children": [{"is_tag_endorse": false, "created": "2015-03-25T00:14:58Z", "id": "i7nzc08w6fu7j1", "tag_endorse": [{"name": "pxx199181", "id": "i72xyao1QhO", "role": "student", "facebook_id": null, "photo": null, "admin": false, "us": false}], "folders": [], "history": [{"uid": "hdjoucuyb836fq", "anon": "no", "created": "2015-03-25T00:14:58Z", "content": "<p>1. lab2里指令和数据的访问已经使用高位地址&#xff08;0xC0000000以上&#xff09;&#xff0c;在页表使能前是依靠段表进行转换的&#xff0c;相关代码可以参考系统启动之初所加载的GDT。</p>\n<p></p>\n<p>2. 内核态和用户态空间的划分完全是操作系统自己定义&#xff0c;然后以页表的形式告诉CPU的&#xff08;具体可参考页表项中权限管理相关的位&#xff0c;可在Intel Software Developer&#39;s Manual的Paging一章中找到&#xff09;&#xff0c;代码中体现为如何对boot_pgdir进行初始化。</p>\n<p></p>\n<p>3. 这与32位系统所能管理的物理内存大小有关&#xff0c;ucore中还有一个KERNTOP限制内存映射的上限&#xff08;可参考memlayout.h里的映射图&#xff09;&#xff0c;换句话说&#xff0c;ucore最多只能管理896M内存&#xff0c;这也保证即使加了0xC0000000也不会超出4G的范围&#xff08;实际上不会超出KERNTOP&#xff09;。同样的问题在Linux中也存在&#xff0c;Linux用了更复杂的方法保证1G以上的内存也可以正常访问&#xff0c;具体技术已经超出本课程的要求了&#xff0c;有兴趣的话可以查找相关资料。</p>", "subject": ""}], "config": {}, "data": {"embed_links": []}, "bucket_order": 2, "bucket_name": "Today", "tag_endorse_arr": ["i72xyao1QhO"], "children": [], "type": "i_answer"}, {"no_answer": 0, "created": "2015-03-25T00:32:41Z", "id": "i7nzysd3cv4ey", "updated": "2015-03-25T00:32:41Z", "subject": "<p>哦,对,此时还用的段表进行转换,代码如下:</p>\n<p>__gdt:<br />    SEG_NULL<br />    SEG_ASM(STA_X | STA_R, - KERNBASE, 0xFFFFFFFF)      # code segment<br />    SEG_ASM(STA_W, - KERNBASE, 0xFFFFFFFF)              # data segment</p>\n<p>加载的时候,基址设置的是-KERNBASE,一加刚好为物理地址,</p>\n<p>老师说的第三点的意思难道是说ucore确实存在这样的隐患吧?最多能管理896M内存确实可以消除这种..</p>", "anon": "stud", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [{"created": "2015-03-25T00:34:35Z", "id": "i7o018d83ej4we", "updated": "2015-03-25T00:34:35Z", "subject": "<p>说错了,加起来不是物理地址,是一加刚好消除</p>", "anon": "stud", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "children": [], "type": "feedback"}, {"uid": "hdjoucuyb836fq", "created": "2015-03-25T00:39:26Z", "id": "i7o07gwrem47a5", "updated": "2015-03-25T00:39:26Z", "subject": "<p>这是限制内核只占用1G虚拟地址空间&#xff0c;还要用一一映射把物理地址映射到内核虚拟地址空间之后无法回避的问题。现在的ucore通过限制可管理内存大小&#xff0c;简单粗暴地避免地址发生混乱&#xff0c;应该说并没有访问超过4G的地址的隐患&#xff0c;但是在管理硬件的能力上打了折扣。</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "children": [], "type": "feedback"}, {"created": "2015-03-25T00:47:38Z", "id": "i7o0i07rvu871m", "updated": "2015-03-25T00:47:38Z", "subject": "<p>谢谢!</p>", "anon": "stud", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "children": [], "type": "feedback"}], "type": "followup"}], "type": "question", "unique_views": 73, "created": "2015-03-24T13:48:56Z", "id": "i7ncyx79dss1lx", "no_answer": 0, "nr": 172, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {}, "folders": ["lab2"], "bucket_order": 2, "change_log": [{"uid": "i72xyao1QhO", "when": "2015-03-24T13:48:56Z", "data": "i7ncyx7dk7h1ly", "anon": "no", "type": "create"}, {"uid": "i72xyao1QhO", "when": "2015-03-24T14:11:36Z", "data": "i7nds2b9smc79v", "anon": "no", "type": "update"}, {"uid": "i72xyao1QhO", "when": "2015-03-24T14:12:24Z", "data": "i7ndt3c57it5hu", "anon": "no", "type": "update"}, {"uid": "i72xyao1QhO", "when": "2015-03-24T14:22:22Z", "data": "i7ne5wkmta45q3", "anon": "no", "type": "update"}, {"uid": "hdjoucuyb836fq", "when": "2015-03-25T00:14:58Z", "data": "i7nzc0935zi7j2", "to": "i7ncyx79dss1lx", "anon": "no", "type": "i_answer"}, {"when": "2015-03-25T00:32:41Z", "to": "i7ncyx79dss1lx", "anon": "stud", "type": "followup"}, {"when": "2015-03-25T00:34:35Z", "to": "i7ncyx79dss1lx", "anon": "stud", "type": "feedback"}, {"uid": "hdjoucuyb836fq", "when": "2015-03-25T00:39:26Z", "to": "i7ncyx79dss1lx", "anon": "no", "type": "feedback"}, {"when": "2015-03-25T00:47:38Z", "to": "i7ncyx79dss1lx", "anon": "stud", "type": "feedback"}], "bucket_name": "Today", "tags": ["lab2", "student"], "no_answer_followup": 0, "num_favorites": 0, "tag_good": []}}