{"aid": "im50bwzek7e59p", "result": {"folders": ["lecture10", "课堂问答"], "unique_views": 112, "request_instructor_me": false, "change_log": [{"data": "im4lad9vug77a9", "anon": "no", "when": "2016-03-23T08:29:45Z", "uid": "hdjonbiyfs62ie", "type": "create"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:31:47Z", "uid": "i0f9pvv0uxm6ko", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:36:01Z", "uid": "i6vjwdpfniF", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:37:26Z", "uid": "i0nuu5yhgno5tv", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:38:39Z", "uid": "i0dlq4m0wjn5eo", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:42:26Z", "uid": "i0zaci5voig5h", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:47:29Z", "uid": "i0eqqq6jvng408", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:47:35Z", "uid": "i0ayxqk6wry734", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:48:05Z", "uid": "i0c1nsm3911wc", "type": "feedback"}, {"data": "im4m20sz21l75v", "anon": "no", "when": "2016-03-23T08:51:15Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:55:48Z", "uid": "i6uayuoumpw5ah", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:57:22Z", "uid": "i0f24oie8102cr", "type": "feedback"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:57:46Z", "uid": "ikvcvqz0jx17m1", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T08:58:15Z", "uid": "i6ub5at2geM", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T09:27:12Z", "uid": "ierwkwbinsj2t8", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T09:41:01Z", "uid": "ikx8y1dzPrM", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T10:02:30Z", "uid": "i0ccfx63sir1e", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T10:13:14Z", "uid": "i0brpl1lbyui6", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T10:21:49Z", "uid": "i6w84pnmjCQ", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T10:51:07Z", "uid": "i0ccqbaxwdz75c", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:00:13Z", "uid": "i0gkdbms5ie20o", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:04:44Z", "uid": "ikx8y1dzPrM", "type": "feedback"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:12:25Z", "uid": "i0hjdkesg9c5z7", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:21:50Z", "uid": "i242q8ug7vw40x", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:24:14Z", "uid": "ikvcvmzbvlf7i6", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:24:17Z", "uid": "i0evrfcnckf5dt", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:28:17Z", "uid": "i6ub7i4hdcc", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:40:19Z", "uid": "i28t9sj8bas79c", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:44:58Z", "uid": "ikvcvp62fcm7ka", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:48:41Z", "uid": "i11v1az5sf83l2", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:49:41Z", "uid": "i6u94pk3j2C", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:53:07Z", "uid": "i11dx198ive25r", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:54:59Z", "uid": "i0i7rzz9iau2gd", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T11:58:35Z", "uid": "ikwht0mda9v4iu", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T12:09:26Z", "uid": "i0b7d04pl3y6c0", "type": "feedback"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T12:31:51Z", "uid": "i1569mw0xp954u", "type": "followup"}, {"to": "im4lad9rwr67a8", "anon": "no", "when": "2016-03-23T12:33:58Z", "uid": "i0f7v0qgfm61s6", "type": "followup"}], "upvote_ids": [], "id": "im4lad9rwr67a8", "bookmarked": 37, "no_answer_followup": 31, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2016-03-23T08:31:47Z", "no_upvotes": 0, "uid": "i0f9pvv0uxm6ko", "created": "2016-03-23T08:31:47Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4lcz9vqm42ne", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>李宇轩 2013011349</p>\n<p>实现方案&#xff1a;</p>\n<p>  大部分和FIFO算法的实现一致&#xff0c;可使用同样的swap_manager模板&#xff0c;仅说明不同之处&#xff1a;<br />  主要需要写两个函数&#xff1a;<br />  map_swappable将可交换的页顺便放入mm-&gt;sm_priv双向链表&#xff08;这个链表作为时钟算法的链表&#xff09;的一个位置&#xff0c;在页面换入内存的时候调用&#xff1b;和FIFO算法不同&#xff0c;不需要考虑放入的位置&#xff0c;因为时钟算法对此不敏感</p>\n<p>  swap_out_victim按照时钟算法扫描双向链表&#xff0c;根据特征决定换出的页。关键是需要知道访问信息&#xff0c;需要操作access bit&#xff0c;这个和x86架构有关&#xff0c;方法如下&#xff1a;</p>\n<p>  访问&#xff1a;利用page-&gt;pra_vaddr可以得到物理页对应的线性地址la&#xff0c;再通过get_pte(mm-&gt;pgdir,la,0)可以得到pte页表项&#xff0c;*pte可以得到页表项的内容&#xff0c;*pte &amp; PTE_A便可得到该物理页是否被访问&#xff1b;</p>\n<p>  修改&#xff1a;类似访问&#xff0c;得到pte以后&#xff0c;修改PTE_A位&#xff0c;并无效现在的TLB&#xff0c;因为TLB中保存有错误的PTE_A信息</p>\n<p>性能差异性&#xff1a;</p>\n<p>  在缺页率方面&#xff0c;clock并没有用到所有过去的信息&#xff0c;较LRU算法较差。而之后会提到&#xff0c;LRU的实现开销过大&#xff0c;所以总性能上clock算法相比LRU算法优秀不少。</p>\n<p>LRU方案&#xff1a;</p>\n<p>  基本没有实现的价值。硬件对于LRU算法没有相应的支持&#xff0c;需要操作系统在每次访存以后都维护由软件操作的一个栈&#xff08;或别的数据结构&#xff09;。考虑到指令至少有一次访存&#xff0c;至多有六次访存&#xff0c;这个维护栈的复杂度是无法接受的。除非硬件提供相应的机制&#xff0c;不然难以接受。</p>\n<p></p>"}, {"folders": [], "updated": "2016-03-23T08:36:01Z", "no_upvotes": 0, "uid": "i6vjwdpfniF", "created": "2016-03-23T08:36:01Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4lif0qex42kv", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2012012139 高博 2012011383 赵涵</p>\n<p></p>\n<p>实现代码类似于FIFO&#xff0c;但是要维护一个保存访问bit的链表。</p>\n<p>在swap_out_victim和map_swappable的时候&#xff0c;需要在链表中找到最前面的访问bit最小的页&#xff0c;然后修改扫描指针经过的页的访问bit</p>\n<p><br />当访问序列不随机的时候&#xff0c;比如某一个页面访问明显多于其他页面的时候&#xff0c;clock的性能会比LRU差很多。这是因为clock只记录一个页是否出现过</p>\n<p><br />不能实现&#xff0c;LRU需要记录内存访问的时间&#xff0c;我们的cpu没有这个功能</p>"}, {"folders": [], "updated": "2016-03-23T08:37:26Z", "no_upvotes": 0, "uid": "i0nuu5yhgno5tv", "created": "2016-03-23T08:37:26Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4lk8lvyo54fp", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2013011402 钱迪晨 2013011413 高思达</p>\n<p>在FIFO里面可以看一下Page里面存的用来维护的信息。</p>\n<pre>struct Page {\n    int ref;                        // page frame&#39;s reference counter\n    uint32_t flags;                 // array of flags that describe the status of the page frame\n    unsigned int property;          // the num of free block, used in first fit pm manager\n    list_entry_t page_link;         // free list link\n    list_entry_t pra_page_link;     // used for pra (page replace algorithm)\n    uintptr_t pra_vaddr;            // used for pra (page replace algorithm)\n};</pre>\n<p>这里用了pra_vaddr来记录这个页在mm_struct里面对应的线性地址&#xff0c;也就是进程的线性地址。</p>\n<p>由于lab3里面只有一个进程&#xff0c;所以应该在Page里面加入</p>\n<pre>struct Page {\n    int ref;                        // page frame&#39;s reference counter\n    uint32_t flags;                 // array of flags that describe the status of the page frame\n    unsigned int property;          // the num of free block, used in first fit pm manager\n    list_entry_t page_link;         // free list link\n    list_entry_t pra_page_link;     // used for pra (page replace algorithm)\n    uintptr_t pra_vaddr;            // used for pra (page replace algorithm)\n    mm_struct *pra_mm;\n};</pre>\n<p>然后swap_manager可以根据Page的信息获得对应的la和mm。这样子就可以获得页表的内容&#xff0c;根据页表里面的脏位和修改位&#xff0c;就可以实现clock算法。</p>\n<p>具体实现的时候&#xff0c;每次查看页表的脏位和修改为&#xff0c;进行修改&#xff0c;如果必要也需要修改tlb。</p>\n<p></p>\n<p>对于map_swappable&#xff0c;只需要和fifo一样&#xff0c;加入当前链表的tail即可。</p>\n<p>对于set_unswappable&#xff0c;只需要扫描链表删除即可。</p>\n<p>对于swap_out_victim&#xff0c;采用不停循环&#xff0c;根据上面描述的方法&#xff0c;可以找到该页的修改位和脏位&#xff0c;进行修改&#xff0c;以及扫描。</p>\n<p></p>\n<p>LRU算法的复杂过高&#xff0c;一条指令最多有6次访存操作&#xff0c;每次维护的代价过大。</p>\n<p>但是由于lab3里面是单进程&#xff0c;空间局部性非常好&#xff0c;所以是可取的&#xff0c;性能上不一定会差。</p>"}, {"folders": [], "updated": "2016-03-23T08:38:39Z", "no_upvotes": 0, "uid": "i0dlq4m0wjn5eo", "created": "2016-03-23T08:38:39Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4lltfuqcb2ov", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2013011389 郑兆衡&#xff0c; 2013011416 张浩天&#xff0c; 2012011366 尚智伟</p>\n<p><br /><a href=\"https://github.com/ZhengZhaoHeng/os_2016/blob/master/lec10/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF.md\" target=\"_blank\">设计思路</a></p>"}, {"folders": [], "updated": "2016-03-23T08:42:26Z", "no_upvotes": 0, "uid": "i0zaci5voig5h", "created": "2016-03-23T08:42:26Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4lqo9liyw3s3", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-03-23T08:48:05Z", "uid": "i0c1nsm3911wc", "created": "2016-03-23T08:48:05Z", "type": "feedback", "d-bucket": "Yesterday", "id": "im4lxxw5ct678s", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>关于缺页率&#xff1a;Clock比LRU要差&#xff0c;因为只用到了一小部分历史信息&#xff0c;没有考虑到访问次数的多少。而Extended Clock比Clock的缺页率要低一些&#xff0c;因为Extended Clock可以把多次页写回合并到一次。性能一般来说和算法的复杂度相关&#xff0c;越简单的性能越好。实际系统实现时需要做tradeoff。</p>"}], "subject": "<p>2012011894 朱俸民 2013011411朱新瑞</p>\n<p>参照swap_fifo.c的实现进行</p>\n<p>首先封装一个数据结构pageH</p>\n<p>内含一个page和一个访问位</p>\n<p>init不变</p>\n<p>swappable是插入函数&#xff0c;插入基本不变&#xff0c;唯一的变动是我们需要在函数中把Page包装成PageH&#xff0c;标记访问位为0</p>\n<p>swap_out_victim是找出一页删除掉&#xff0c;这里我们改成扫描环形链表&#xff0c;以以下规则进行</p>\n<p>访问位为0&#xff0c;则选择该页删掉</p>\n<p>访问位为1&#xff0c;则置为0&#xff0c;继续找</p>\n<p>然后进行访问&#xff08;读&#xff0f;写&#xff09;的时候&#xff0c;要把相应的访问位变为1&#xff0c;这一步应该不只在manager上做&#xff0c;需要在硬件或软件上其他地方处理</p>"}, {"folders": [], "updated": "2016-03-23T08:47:29Z", "no_upvotes": 0, "uid": "i0eqqq6jvng408", "created": "2016-03-23T08:47:29Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4lx6bpy79si", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2013011376龚拓宇 2013011379姚炫容</p>\n<p>概要设计&#xff1a;<br />参考swap_fifo.c的实现&#xff0c;在其基础上进行修改。需要修改的主要为两处&#xff1a;<br />map_swappable和swap_out_victim<br />FIFO维护单向链表要改为维护循环链表&#xff0c;要把头和尾连接起来<br />对于struct Page&#xff0c;需要加一个成员变量来表示访问位<br />在swap_out_victim中遍历链表&#xff0c;查看访问位&#xff0c;并决定是否换出<br />性能分析&#xff1a;FIFO在某些情况下性能非常差&#xff0c;对访问信息的利用非常有限。<br />LRU的理论上的时间开销小&#xff0c;但在没有硬件专门支持的情况下&#xff0c;实际时间开销非常大&#xff0c;实现也比较复杂。<br />而clock算法实现较为简单&#xff0c;性能也比较好&#xff0c;因为每次读操作只需要修改标志位&#xff0c;多次写操作才回写回一次&#xff0c;每次缺页不会转太多。<br />LRU的性能较差&#xff0c;但是可能缺页率会比Clock更好。</p>"}, {"folders": [], "updated": "2016-03-23T08:47:35Z", "no_upvotes": 0, "uid": "i0ayxqk6wry734", "created": "2016-03-23T08:47:35Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4lxb68st04yu", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-03-23T08:57:22Z", "uid": "i0f24oie8102cr", "created": "2016-03-23T08:57:22Z", "type": "feedback", "d-bucket": "Yesterday", "id": "im4m9w2d96q216", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>性能分析&#xff1a;FIFO在某些情况下性能非常差&#xff0c;因为可能和访问时候的特征相悖。LRU的时间开销非常大&#xff0c;实现也比较复杂。而clock算法实现较为简单&#xff0c;性能也比较好&#xff0c;因为每次读操作只需要修改标志位&#xff08;由硬件完成&#xff09;&#xff0c;多次写操作才回写回一次&#xff0c;每次缺页不会转太多&#xff08;因为每次访问最多&#43;1&#xff0c;每转一格-1&#xff0c;这样转的格数不会超过访问次数&#xff09;。LRU的性能较差&#xff0c;但是可能缺页率会比Clock更好。因为每次访问需要修改链表的结构。</p>"}], "subject": "<p>2013011371 沈哲言 2013011404 叶子鹏</p>\n<p>可以重用一部分FIFO的框架&#xff0c;主要修改的部分为swap_manager这个数据结构</p>\n<p>修改的函数为</p>\n<pre>int (*map_swappable)   (struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in);\nint (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, int in_tick);</pre>\n<p>&#xff08;1&#xff09;FIFO在维护可交换页面的时候采用了单向的链表&#xff0c;在map_swappable里维护了这个链表</p>\n<p>CLOCK算法需要维护一个循环链表&#xff0c;故需要把头结点和尾结点连在一起&#xff0c;可以调用list_entry提供的宏</p>\n<p>&#xff08;2&#xff09;页面换出的算法&#xff0c;即swap_out_victim需要修改</p>\n<p>原先的数据结构修改了Page结构</p>\n<pre>struct Page {\n    int ref;                        // page frame&#39;s reference counter\n    uint32_t flags;                 // array of flags that describe the status of the page frame\n    unsigned int property;          // the num of free block, used in first fit pm manager\n    list_entry_t page_link;         // free list link\n    list_entry_t pra_page_link;     // used for pra (page replace algorithm)\n    uintptr_t pra_vaddr;            // used for pra (page replace algorithm)\n};</pre>\n<p>我认为这里Page还需要加一个域来表示访问位&#xff0c;这个位可以由硬件来记录&#xff08;在页表上记录&#xff09;</p>\n<p>然后Page里加入一个宏来映射这个访问位&#xff0c;在swap_out_victim中遍历链表&#xff0c;查看访问位&#xff0c;并决定是否换出</p>"}, {"folders": [], "updated": "2016-03-23T08:55:48Z", "no_upvotes": 0, "uid": "i6uayuoumpw5ah", "created": "2016-03-23T08:55:48Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4m7vmpkmn2hh", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p><p>2012011308 陆喆&#xff0c;2012080060 甄显安</p>\n<p></p>\n<p>可以基于已经实现的FIFO算法&#xff0c;进行修改&#xff0c;得到Clock算法实现。</p>\n<p></p>\n<p>1. </p>\n<p>swap.c line 41:</p>\n<p>sm = &amp;swap_manager_fifo;</p>\n<p></p>\n<p>引用了FIFO算法的Swap管理器&#xff1b;实现Clock算法之后在此处替换即可。</p>\n<p></p>\n<p>2. </p>\n<p>swap_fifo.c line 45:</p>\n<p>init_mm函数中&#xff0c;初始化链表时应该首尾相接构造环形链表&#xff0c;并且加上一个指针指向最先调入的页面。</p>\n<p></p>\n<p>3. </p>\n<p>每一个页表项加上一个访问位&#xff0c;初始置0&#xff0c;访问时可以用比特AND得到或修改访问位的值。</p>\n<p></p>\n<p>4.</p>\n<p>swap_out_victim中&#xff0c;从指针当前位置顺序检查环形链表&#xff1b;若访问位是0&#xff0c;则置换该页&#xff0c;<i>指针移动到下一项&#xff1b;若访问位是1&#xff0c;则把访问位置0&#xff0c;指针移动到下一项&#xff0c;重复这个过程直到找到可以置换的页面。</i></p>\n<p><i></i></p>\n<p>性能&#xff1a;</p>\n<p>Clock是LRU和FIFO的折衷&#xff0c;会考虑过去访问情况&#xff0c;但是不很详细&#xff0c;而且它不动态调整页面在链表中的顺序&#xff0c;只做标记。所以它的开销一般比LRU要小&#xff0c;因为LRU详细记录开销太大。对于未被访问的页面&#xff0c;Clock退化为LRU&#xff0c;表现一样好&#xff0c;而对于被访问过的页面&#xff0c;Clock不记录准确访问顺序&#xff0c;表现比LRU差但是比FIFO好。</p>"}, {"folders": [], "updated": "2016-03-23T08:57:46Z", "no_upvotes": 0, "uid": "ikvcvqz0jx17m1", "created": "2016-03-23T08:57:46Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4maeeedju361", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2012011333 俞寒轩</p>\n<p></p>\n<p><strong>一、设计方案</strong></p>\n<p>由于CLOCK算法需要访问位&#xff08;修改的CLOCK还需要修改位&#xff09;&#xff0c;因此我们首先需要在page结构里增加一个访问位。</p>\n<p>然后我们需要修改swap_fifo.c&#xff1a;</p>\n<p></p>\n<p>1 _fifo_init_mm</p>\n<p>对于初始化函数&#xff0c;LRU构造的是普通单向链表&#xff0c;我们需要构造循环链表。这里的链表指针其实可以直接用作我们CLOCK算法中需要用到的指针。</p>\n<p></p>\n<p>2 _fifo_map_swappable</p>\n<p>对于换入函数&#xff0c;由于CLOCK机制扫描后替换出的页正好在指针之前&#xff0c;此处我们仍加入循环链表尾端&#xff0c;注意访问位置为0。</p>\n<p></p>\n<p>3 _fifo_swap_out_victim</p>\n<p>对于换出函数&#xff0c;指针循环遍历链表。如果访问位为1&#xff0c;则置0&#xff0c;并移动到下一项。如果访问位为0&#xff0c;则换出该页。</p>\n<p></p>\n<p>最后&#xff0c;访问位在读写时也是需要修改的&#xff0c;比如我们在alloc_page()里增加一项&#xff0c;使每次访问时将对应位置访问位置为1。</p>\n<p></p>\n<p><strong>二、算法比较</strong></p>\n<p>在正常运行的情况下LRU算法的缺页率较低&#xff0c;因为很好地考虑了时间局部性。但是实现比较复杂&#xff0c;而且每次访问都需要修改链表&#xff0c;使得访问效率也不高。在硬件支持的情况下是不错的&#xff0c;软件编写的话反而降低效率。考虑到我们的实验没有这样的硬件支持&#xff0c;因此不适合用LRU。</p>"}, {"folders": [], "updated": "2016-03-23T08:58:15Z", "no_upvotes": 0, "uid": "i6ub5at2geM", "created": "2016-03-23T08:58:15Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4mb0mfcyz29e", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>1. 小组思考题(1)&#xff1a;请思考如何在lab3_results中实现clock算法&#xff0c;给出你的概要设计方案。要求说明你的方案中clock算法与LRU算法上相比&#xff0c;潜在的性能差异性。进而说明在lab3的LRU算法实现的可能性评价。</p>\n<p></p>\n<p>在FIFO的基础上容易实现&#xff0c;只需要修改lab3中需要实现的2个函数&#xff1a;换出和插入。FIFO虽然是单向的列表&#xff0c;但由于list本身的特性&#xff0c;很容易改为双向的&#xff08;本身就是&#xff1f;&#xff09;。mm-&gt;sm_priv在FIFO中用于记录head&#xff0c;在clock中可以用于记录指针位置&#xff1b;再通过设置一位计数&#xff08;比如从PG_AVAILABLE中&#xff09;&#xff0c;再改变两个函数即可。</p>\n<p></p>\n<p>LRU的实现需要在访问的时候也有一个可实现接口&#xff0c;来维护pra_list_head。效率上clock肯定不如LRU&#xff0c;但肯定优于FIFO。</p>\n<p></p>\n<p>金嘉宇 2012080059</p>\n<p>章晔 2012011321</p>"}, {"folders": [], "updated": "2016-03-23T09:27:12Z", "no_upvotes": 0, "uid": "ierwkwbinsj2t8", "created": "2016-03-23T09:27:12Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4nc8vra1u1gq", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>和FIFO不同的地方主要在于swap_out_victim函数需要实现clock的算法逻辑&#xff0c;同时需要利用PTE当中存储的该页是否被访问过的信息&#xff08;这需要利用page-&gt;pra_vaddr去找到PTE&#xff09;.。链表本身就是环状的&#xff0c;因此在链表的维护和访问上并不需要太大的改动。</p>\n<p></p>\n<p>这和LRU的性能差距已经在MOOC的课当中说得比较清楚了&#xff0c;因为用的信息比较少&#xff0c;因此不能提供很好的页面未来使用情况的估计。但LRU在lab3当中实现是不现实的&#xff0c;因为没有硬件的支持&#xff0c;开销会大得难以接受而失去意义。</p>"}, {"folders": [], "updated": "2016-03-23T09:41:01Z", "no_upvotes": 0, "uid": "ikx8y1dzPrM", "created": "2016-03-23T09:41:01Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4nu0kia362i", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-03-23T11:04:44Z", "uid": "ikx8y1dzPrM", "created": "2016-03-23T11:04:44Z", "type": "feedback", "d-bucket": "Yesterday", "id": "im4qto89hei3n9", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>krajna 2014010527</p>\n<p></p>\n<p>在lab3中不需要对FIFO机制做太大修改即可完成基于clock的swap机制。</p>\n<p></p>\n<p>在淘汰算法swap_out_victim函数中设置一个指针循环扫描有页中的pra_list</p>\n<p>组成的链表&#xff08;链表不需要修改&#xff0c;和FIFO机制中的一样都是双向循环链表&#xff09;。</p>\n<p>每次访问结点的时候都需要找到对应的struct Page,然后取出pra_vaddr,接着</p>\n<p>由虚拟地址获得PTE的值&#xff0c;判断其中的访问位是否为1&#xff0c;如果是则clear&#xff0c;否则</p>\n<p>可以淘汰出去。另外&#xff0c;在页换入的时候要清零访问位。</p>\n<p></p>\n<p>LRU和clock都是通过对过去内存访问情况作出对未来的统计推断&#xff0c;clock由于</p>\n<p>统计信息少&#xff0c;性能显然低于LRU算法。</p>\n<p></p>\n<p>但是在ucore中用软件实现LRU不太可能&#xff0c;因为在没有硬件支持的情况下软件</p>\n<p>维护LRU的数据结构开销太大。</p>\n<p></p>\n<p></p>\n<p></p>"}], "subject": "<p></p>"}, {"folders": [], "updated": "2016-03-23T10:02:30Z", "no_upvotes": 0, "uid": "i0ccfx63sir1e", "created": "2016-03-23T10:02:30Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4olmxyc1n57c", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-03-23T12:09:26Z", "uid": "i0b7d04pl3y6c0", "created": "2016-03-23T12:09:26Z", "type": "feedback", "id": "im4t4vkc8f129u", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>补充&#xff1a;</p>\n<p>1. 在Clock算法中与历史信息记录有关的数据有两处。</p>\n<p>    一是在swap_out_victim()中&#xff0c;我们需要定义一个静态指针变量。内存中储存的页的信息构成了一个环状链表&#xff0c;指针在这个链表中轮转。</p>\n<p>    二是pte中的访问位PTE_A&#xff0c;当某一页被读或写时&#xff0c;访问位被置为1。当内存置换时&#xff0c;静态指针指向的页会被优先换出&#xff0c;然后指针指向链表中的下一页。访问位为1的页可以免除一次的被换出&#xff0c;然后将访问位置为0。</p>\n<p>    若采用改进的clock算法&#xff0c;则需要对链表中的每一项额外增加一位信息。</p>\n<p>2. 与LRU的性能比较</p>\n<p>    从记录的信息来看&#xff0c;clock算法可以记录在最近的一段时间内哪些页曾经被访问过。而LRU可以记录被访问的顺序信息。故后者的预测更为精确。</p>\n<p>    当页换出时&#xff0c;LRU只需换出链表中尾端一项&#xff0c;而clock算法最差情况下要循环两圈。</p>\n<p>    对于历史信息的维护&#xff0c;clock算法只需将pte中对应位置为1&#xff0c;而LRU还要改变链表中的顺序。</p>\n<p>    然而&#xff0c;页换出在整个访问中所占比例较小&#xff0c;故LRU要花更多的时间维护链表。个人认为使用LRU得不偿失。</p>\n<p>    </p>"}], "subject": "<p>刘晓鸿 2013010949 杨晓成 2013011383</p>\n<p>1、页置换管理接口</p>\n<pre>struct swap_manager\n{\n     const char *name;\n     int (*init)            (void);\n     int (*init_mm)         (struct mm_struct *mm);\n     int (*tick_event)      (struct mm_struct *mm);\n     int (*map_swappable)   (struct mm_struct *mm, uintptr_t addr\n                         , struct Page *page, int swap_in);\n     int (*set_unswappable) (struct mm_struct *mm, uintptr_t addr);\n     int (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, int in_tick);\n     int (*check_swap)(void);     \n};\n主要通过修改以下接口&#xff0c;从而实现不同策略的页替换。\n     init 初始化\n     swap_out_victim 挑选出要换出的页\n根据需要&#xff0c;用一些接口加以辅助实现\n     tick_event 时钟事件\n     map_swappable 完成替换后&#xff0c;建立页的基本信息\n     set_unswappable 根据算法&#xff0c;在需要的地方页可被替换的标记。</pre>\n<p>2、页替换过程</p>\n<pre>指令触发缺页异常&#xff0c;如果该页是有效且不在内存中&#xff0c;则产生页替换。\nucore页替换过程大体如下&#xff1a;\n在异常处理do_pgfault中\n     swap_in 将硬盘中的页面放入内存\n          alloc_page 尝试申请内存&#xff0c;如果内存不够&#xff0c;则swap_out换出页面。\n               swap_out调用swap_out_victim&#xff0c;挑选出合适的页面&#xff0c;然后换出\n                    swap_out_victim (*)不同替换算法实现不同\n     swap_map_swappable 建立算法策略的基本属性&#xff0c;如页访问属性、关系</pre>\n<p>3、硬件支持</p>\n<pre>TLB记录页面是否被访问过的信息。该信息需要能读取和修改&#xff0c;否则clock算法中的访问位无法维护。\n&#xff08;不知道x86CPU是否支持&#xff0c;这里假定支持&#xff0c;否则clock算法无法实现&#xff09;</pre>\n<p>4、clock页替换设计</p>\n<pre>由以上对ucore页替换管理、页替换过程、CPU的硬件支持的基本了解&#xff0c;我们设计clock页替换算法在ucore上的实现。\ninit\n     建立循环链表&#xff0c;链表每项有clock算法所需的访问位\nswap_out_victim\n     读取TLB&#xff0c;将访问位更新&#xff0c;即被访问过的页的访问位&#43;&#43;&#xff0c;清零TLB上的该标记。\n     时钟算法TODO&#xff0c;找到合适的页\n     返回页\nmap_swappable\n     将新的页加入链表&#xff0c;访问位0&#43;&#43;\ntick_event 用不着\nset_unswappable 用不着</pre>\n<p></p>"}, {"folders": [], "updated": "2016-03-23T10:13:14Z", "no_upvotes": 0, "uid": "i0brpl1lbyui6", "created": "2016-03-23T10:13:14Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4ozg4r9rcjm", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>杨明 2013011412 谢琛睿 2013011406 马志明 2013011395 王启圣 2013011409</p>\n<p>在kern/mm/swap.h中定义了一个通用的struct&#xff0c;即swap_manager&#xff0c;可以通过自定义一个swap_clock.c文件实例化之。</p>\n<p>具体做法就是</p>\n<p>1. 定义一个基于list.h的循环链表clock_list&#xff0c;用来记录导入内存的物理页&#xff1b;</p>\n<p>2. 参照fifo的写法&#xff0c;主要改写swappable和swap_out两个函数&#xff1b;</p>\n<p>3. swappable将clock_list加入mm_struct中的sm_priv这一私有数据&#xff1b;</p>\n<p>4. swap_out中依次查找clock_list的每一项&#xff0c;具体操作为&#xff1a;先将链表转化为Page&#xff0c;再调用Page-&gt;pra_vaddr&#xff0c;得到相应的线性地址&#xff0c;再用线性地址得到页表项&#xff0c;在页表项中查看修改位&#xff0c;如果为0就可以换出。期望&#xff1a;需要页表项中预留修改位&#xff0c;外部程序进行正常访问时&#xff0c;硬件能对此位置位。</p>\n<p>5. 在swap_clock.c文件末</p>\n<p>struct swap_manager swap_manager_clock =<br />{<br />     .name            = &#34;clock swap manager&#34;,<br />     .init            = &amp;_clock_init,<br />     .init_mm         = &amp;_clock_init_mm,<br />     .tick_event      = &amp;_clock_tick_event,<br />     .map_swappable   = &amp;_clock_map_swappable,<br />     .set_unswappable = &amp;_clock_set_unswappable,<br />     .swap_out_victim = &amp;_clock_swap_out_victim,<br />     .check_swap      = &amp;_clock_check_swap,<br />};</p>\n<p>clock算法虽然在理论上会出现belady现象&#xff0c;但是在工程实践中并不要紧&#xff0c;因为实际系统中的逻辑页面数是固定的。相反&#xff0c;由于LRU算法不仅开销大&#xff08;最坏情况6次访存&#xff09;&#xff0c;而且算法要求即使每次正常访问&#xff0c;也必须调用系统处理&#xff0c;所以too expensive。相较而言&#xff0c;clock近似算法&#xff0c;仅在缺页中断时调用且维护操作较少&#xff0c;所以performance 很好&#xff0c;性价比高。</p>"}, {"folders": [], "updated": "2016-03-23T10:21:49Z", "no_upvotes": 0, "uid": "i6w84pnmjCQ", "created": "2016-03-23T10:21:49Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4pahi1scg7c3", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p><a href=\"http://172.16.13.236/wzm_andy/ucore_lab\">http://172.16.13.236/wzm_andy/ucore_lab</a></p>\n<p></p>\n<p>我们写了代码。思路就是实现<tt>swap.h</tt>里面的<tt>swap_manager</tt>结构体。具体见</p>\n<pre>lab3_result/kern/mm/swap_clock.c\nlab3_result/kern/mm/swap_clock.h</pre>\n<p><tt>make qemu</tt>执行即可看到结果。更改<tt>_clock_check_swap函数可以测试不同的输入。我们曾经遇到一个问题&#xff0c;就是有的时候访问页面相应的PTE_A位不会置1&#xff0c;原因经查找是TLB没有更新&#xff0c;经查阅可通过invlpg指令无效某一虚拟地址的TLB项。现在是正确的。</tt></p>\n<p>我们的方案利用了<tt>x86</tt>修改<tt>PTE_A</tt>位的特性&#xff0c;而<tt>LRU</tt>算法并没有硬件支持&#xff0c;因此性能上会高很多。因此对于<tt>x86</tt>来说&#xff0c;实现<tt>LRU</tt>是得不偿失的。</p>\n<p></p>\n<p>2012011355 王智默</p>\n<p>2012011379 高越</p>\n<p>2012011372 赖国堃</p>\n<p>2012011371 徐捷</p>\n<p></p>"}, {"folders": [], "updated": "2016-03-23T10:51:07Z", "no_upvotes": 0, "uid": "i0ccqbaxwdz75c", "created": "2016-03-23T10:51:07Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4qc613mpx1hw", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>何乐 2013011351 郭栋 2013011334 黎文杰 2013011353 曹科垒 2013011345</p>\n<p>可以参考swap_fifo.c来实现&#xff0c;维护一个环形链表链表。主要修改换入和换出函数&#xff1a;swappable中将可交换页加入链表&#xff0c;并加入访问位&#xff0c;out_victim函数扫描链表&#xff0c;查看访问位并选择换出。</p>\n<p>与LRU算法相比&#xff0c;Clock算法只用到一段时间内的访问信息&#xff0c;缺页率较大&#xff0c;但实现简单。LRU算法实现更为复杂&#xff0c;维护代价过高&#xff0c;若要在lab3使用LRU算法&#xff0c;缺少硬件支持&#xff0c;效果未必会好。</p>"}, {"folders": [], "updated": "2016-03-23T11:00:13Z", "no_upvotes": 0, "uid": "i0gkdbms5ie20o", "created": "2016-03-23T11:00:13Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4qnvnnga35qo", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>乔奕 2013011324</p>\n<p>贺子松 2013011296</p>\n<p></p>\n<p>参考FIFO算法&#xff0c;利用同样的swap_manager模板。区别在于&#xff1a;</p>\n<p>1、FIFO的链表需要改成循环链表</p>\n<p>2、在struct Page中多加入一个访问位。</p>\n<p>3、swap_out_victim中&#xff0c;遍历循环链表&#xff0c;把访问位为1的置为0&#xff0c;为0的换出。</p>\n<p>4、map_swappable中&#xff0c;插入页并把访问位置为0.</p>\n<p></p>\n<p>性能差异性&#xff1a;LRU和Clock算法都一定程度上通过统计过去来预测未来页的使用情况。</p>\n<p>LRU的统计更全面&#xff0c;Clock算法比较简单。但是由于LRU算法过于复杂&#xff0c;访存过多&#xff0c;所以Clock算法更加优秀。</p>"}, {"folders": [], "updated": "2016-03-23T11:12:25Z", "no_upvotes": 0, "uid": "i0hjdkesg9c5z7", "created": "2016-03-23T11:12:25Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4r3jsx8dp1y9", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>王苏 2013011301</p>\n<p>王哲 2013012443</p>\n<p></p>\n<p>参考FIFO的实现&#xff0c;维护一个保存访问bit的链表&#xff0c;在swap_out_victim和map_swappable的时候&#xff0c;需要在链表中找到最前面的访问bit最小的页&#xff0c;然后修改扫描指针经过的页的访问bit。</p>\n<p><br />性能分析&#xff1a;</p>\n<p>当访问序列不随机的时候&#xff0c;由于clock只记录一个页是否出现过&#xff0c;因此clock的性能会比LRU差很多。</p>"}, {"folders": [], "updated": "2016-03-23T11:21:50Z", "no_upvotes": 0, "uid": "i242q8ug7vw40x", "created": "2016-03-23T11:21:50Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4rfofd1a46dc", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>2013011356 董豪宇</p>\n<p>2013011302 李奕昕</p>\n<p><a href=\"https://github.com/donghy/os_exercise/blob/master/lecture10_ex.md\" target=\"_blank\">https://github.com/donghy/os_exercise/blob/master/lecture10_ex.md</a></p>"}, {"folders": [], "updated": "2016-03-23T11:24:14Z", "no_upvotes": 0, "uid": "ikvcvmzbvlf7i6", "created": "2016-03-23T11:24:14Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4rir3nwk26zc", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2013011312 孟凡航 2013011297 杨青霖</p>\n<p>clock算法和fifo算法没有什么太大不同&#xff0c;无非是增加一个访问位的问题&#xff08;扩展clock还有一个修改位&#xff09;</p>\n<p>在换入时&#xff08;map_swappable&#xff09;&#xff0c;插入链表&#xff0c;并将页的访问位置1。</p>\n<p>换出时&#xff08;swap_out_victim&#xff09;&#xff0c;遍历链表&#xff0c;若访问位为1&#xff0c;置零&#xff0c;否则换出该页&#xff0c;不断循环知道找到访问位为0的页。</p>\n<p></p>\n<p>性能分析上面&#xff0c;由于clock利用的信息不多&#xff0c;缺页率就相对高很多&#xff0c;理论上而言劣于LRU</p>\n<p>不过受限于硬件与框架条件&#xff0c;实验上还是clock好</p>\n<p></p>"}, {"folders": [], "updated": "2016-03-23T11:24:17Z", "no_upvotes": 0, "uid": "i0evrfcnckf5dt", "created": "2016-03-23T11:24:17Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4ritqu2o6706", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>何轩 2013011307</p>\n<p>主要是仿照FIFO算法&#xff0c;kern/mm/swap_fifo.c。<br />需要修改的函数为_fifi_map_swappable和_fifo_swap_out_victim。在fifo中&#xff0c;维护可交换页面时使用的是单向链表&#xff0c;然而clock算法所需要维护的是一个循环链表&#xff0c;这一点很好修改&#xff0c;将头尾连接起来即可。<br />由于clock算法需要修改访问位&#xff0c;我们需要在struct page里加入一个访问位。<br />map_swappable基本不变&#xff0c;只需标记访问位为0<br />在swap_out_victim中&#xff0c;指正遍历循环链表&#xff0c;如果访问位为0&#xff0c;则换出该页&#xff0c;反之则置0并移动到下一项。</p>\n<p>比较&#xff1a;在有对应的硬件支持的情况下&#xff0c;LRU的性能是优于clock的&#xff0c;但是在lab3中由于ucore中并没有这样的硬件支持&#xff0c;使用LRU开销过大。</p>"}, {"folders": [], "updated": "2016-03-23T11:28:17Z", "no_upvotes": 0, "uid": "i6ub7i4hdcc", "created": "2016-03-23T11:28:17Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4rnyev3yf29o", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>徐梓哲 2012011487</p>\n<p>杨凯峪 2011010870</p>\n<p></p>\n<p>1. 小组思考题(1)&#xff1a;请思考如何在lab3_results中实现clock算法&#xff0c;给出你的概要设计方案。要求说明你的方案中clock算法与LRU算法上相比&#xff0c;潜在的性能差异性。进而说明在lab3的LRU算法实现的可能性评价。</p>\n<p>&#xff08;1&#xff09; 在FIFO的基础上&#xff0c;要使用一个循环链表</p>\n<p>&#xff08;2&#xff09; swap_out_victim需要修改&#xff08;访问位为0换出&#xff0c;否则置为零下一页&#xff09;</p>\n<p>&#xff08;3&#xff09;page的结构内要加入一个访问位&#xff0c;这个位可以由硬件来记录</p>\n<p></p>\n<div>\n<div>\n<div>\n<div></div>\n</div>\n</div>\n</div>\n<p></p>"}, {"folders": [], "updated": "2016-03-23T11:40:19Z", "no_upvotes": 0, "uid": "i28t9sj8bas79c", "created": "2016-03-23T11:40:19Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4s3g5k36g77w", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>徐圣韬 2012011287</p>\n<p>张振宁 2012011325</p>\n<p></p>\n<p>一、设计方案:<br />参考swap_fifo.c并在其基础上修改</p>\n<p>FIFO维护单向链表改为循环链表&#xff0c;要把头和尾连接起来</p>\n<p>struct Page需要加一个变量表示访问位<br />swap_out_victim中需要遍历链表&#xff0c;并根据访问位决定是否换出</p>\n<p><br />二、性能分析&#xff1a;</p>\n<p>LRU和clock都是根据过去的访问内存的情况来对未来的情况进行预测。</p>\n<p>clock由于统计信息少效果低于LRU算法&#xff0c;但由于实现简单性能可能更高</p>\n<p>在ucore中用实现LRU不太可能&#xff0c;因为在没有硬件支持的情况下维护LRU的数据结构的开销太大。</p>"}, {"folders": [], "updated": "2016-03-23T11:44:58Z", "no_upvotes": 0, "uid": "ikvcvp62fcm7ka", "created": "2016-03-23T11:44:58Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4s9erqxxh66d", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>周恩泽 2012012617</p>\n<p>1.设计算法</p>\n<p>   1.需要在page结构中加个访问位&#xff08;或者用某个现有不用的&#xff09;&#xff0c;用于clock算法记录访问</p>\n<p>   2.在init_mm函数中注意建成环&#xff0c;用于clock算法循环</p>\n<p>   3.在swap_out_victim函数中实现clock算法找到替换位置</p>\n<p>   4.在map_swappable函数中处理换入</p>\n<p>2.性能</p>\n<p>   clock只有一个bit的记录&#xff0c;信息保留太不完整&#xff0c;因此缺页率相对于LRU应当不低。但LRU的实现会复杂很多&#xff0c;缺页率虽低但算法本身效率也低&#xff0c;因此也未必就更好。</p>"}, {"folders": [], "updated": "2016-03-23T11:48:41Z", "no_upvotes": 0, "uid": "i11v1az5sf83l2", "created": "2016-03-23T11:48:41Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4se7hx34m322", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>2013011308 林婕茵</p>\n<p>2013011310 余翔</p>\n<p>1.</p>\n<p>模仿FIFO以及swap_fifo.c的代码。需要注意的是链表需要改成循环链表&#xff0c;以及在struct Page中多加入一个访问位。</p>\n<p>2.</p>\n<p>clock与LRU各有优势&#xff0c;LRU比较复杂&#xff0c;但是缺页率比较低。clock虽然考虑的信息比较少&#xff0c;但是基于硬件支持在一般情况下能很快。</p>\n<p></p>\n<p></p>"}, {"folders": [], "updated": "2016-03-23T11:49:41Z", "no_upvotes": 0, "uid": "i6u94pk3j2C", "created": "2016-03-23T11:49:41Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4sfh5anur52i", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>田家申 2012011296</p>\n<p></p>\n<p>维护一个循环链表和一个指针&#xff0c;以及每个页对应的标记&#xff08;0/1&#xff09;&#xff1b;与FIFO实现不同的地方是换出页面时(swap_out_victim)按照clock算法操作&#xff08;遍历、修改标记位直到找到&#xff09;。</p>\n<p></p>\n<p>LRU虽然在记录页的使用上比clock更加准确&#xff0c;但是维护需要耗费更多时间。当空间足够大时&#xff0c;换页的次数不多&#xff0c;这时LRU在性能上比clock的优势就不明显了。</p>"}, {"folders": [], "updated": "2016-03-23T11:53:07Z", "no_upvotes": 0, "uid": "i11dx198ive25r", "created": "2016-03-23T11:53:07Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4sjwit4n649b", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>叶方轲 2013011340</p>\n<p>张殿炎 2013011328</p>\n<p></p>\n<p>设计方案&#xff1a;</p>\n<p>在swap_fifo.c的基础上做微小改动即可</p>\n<p>由于ucore的链表全部是双向循环链表&#xff0c;所以不需要对init_mm做出改动</p>\n<p>对map_swappable也不需要做出改动&#xff0c;因为PTE的访问位是CPU自动置的</p>\n<p>要改的只有swap_out_victim&#xff0c;只需要利用一个循环去查询、修改链表中page对应的PTE的访问位即可</p>\n<p>具体修改如下&#xff1a;</p>\n<pre>static int\n_clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick)\n{\n     list_entry_t *head=(list_entry_t*) mm-&gt;sm_priv;\n         assert(head != NULL);\n     assert(in_tick==0);\n     /* Select the victim */\n    list_entry_t *le = list_prev(head);\n    struct Page *p = NULL;\n\n    while (1)\n    {\n        if (le == head)\n            le = list_prev(le);\n        p = le2page(le, pra_page_link);\n        uintptr_t va = p-&gt;pra_vaddr;\n        pte_t *pte = get_pte(mm-&gt;pgdir, va, 0);\n        if (*pte &amp; PTE_A)\n            *pte &amp;= ~PTE_A;\n        else\n            break;\n        le = list_prev(le);\n    }\n\n    list_del(le);\n    assert(p !=NULL);\n    *ptr_page = p;\n    return 0;\n}</pre>\n<p></p>\n<p>性能&#xff1a;</p>\n<p>clock算法较LRU开销小&#xff0c;虽然缺页率高于LRU&#xff0c;但是其效率高&#xff0c;实现简单&#xff0c;CPU支持好。LRU的开销太大&#xff0c;实现起来不现实。</p>"}, {"folders": [], "updated": "2016-03-23T11:54:59Z", "no_upvotes": 0, "uid": "i0i7rzz9iau2gd", "created": "2016-03-23T11:54:59Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4smafcmou4ts", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>2013010617 王凯</p>\n<p>2012012231 黄科</p>\n<p>1. 将swap_fifo.c中FIFO的结构改为循环链表&#xff0c;并在page结构中加访问位</p>\n<p>2. CLOCK算法较LRU实现简单&#xff0c;并且开销小&#xff0c;虽然缺页率高于LRU&#xff0c;但是效率更高&#xff0c;LRU过于复杂</p>"}, {"folders": [], "updated": "2016-03-23T11:58:35Z", "no_upvotes": 0, "uid": "ikwht0mda9v4iu", "created": "2016-03-23T11:58:35Z", "type": "followup", "d-bucket": "Yesterday", "id": "im4sqxdx2g638l", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2012011271  宋佳铭 2012011284 章彦恺</p>\n<p>为了实现clock算法&#xff0c;我们至少需要增加维护一个访问位的环形链表&#xff0c;可以直接利用mm-&gt;sm_priv。</p>\n<p>在swappable中&#xff0c;需要把加入的页设置好对应的访问位。</p>\n<p>swap_out_victim中&#xff0c;每次将表头指针移动到下一个页面&#xff0c;直到找到可以置换的页面。</p>\n<p></p>\n<p>无法实现LRU&#xff0c;因为没有时钟硬件记录页面访问的时间前后顺序。</p>"}, {"folders": [], "updated": "2016-03-23T12:31:51Z", "no_upvotes": 0, "uid": "i1569mw0xp954u", "created": "2016-03-23T12:31:51Z", "type": "followup", "no_answer": 1, "id": "im4txp8k51v6tm", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>2013011303 程凯</p>\n<p>2013012213 张明钊<br />1、实现clock算法&#xff0c;首先要在FIFO的基础上&#xff0c;使用一个循环链表。swap_out_victim中&#xff0c;让访问位如果为0则换出&#xff0c;否则置为零切换到下一页。page的结构内还可以加入一个访问位。</p>\n<p>2、clock算法实现简单&#xff0c;开销小&#xff0c;但LRU缺页率更高。</p>"}, {"folders": [], "updated": "2016-03-23T12:33:58Z", "no_upvotes": 0, "uid": "i0f7v0qgfm61s6", "created": "2016-03-23T12:33:58Z", "type": "followup", "no_answer": 1, "id": "im4u0fq5zro440", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>实现代码与FIFO类似&#xff0c;需要修改swap_fifo.c<br />在代码中有三处需要修改&#xff1a;<br />初始化函数&#xff1a;需要构造循环链表<br />换入函数&#xff1a;由于CLOCK机制扫描后替换出的页正好在指针之前&#xff0c;此处仍加入循环链表尾端&#xff0c;注意访问位置为0<br />换出函数&#xff1a;如果访问位为1&#xff0c;则置0&#xff1b;如果访问位为0&#xff0c;则换出该页。</p>\n<p></p>\n<p>2013011339 白家松</p>\n<p>2013011355 徐涵</p>"}], "nr": 732, "bucket_order": 2, "config": {}, "status": "active", "tags": ["instructor-note", "lecture10", "课堂问答"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-03-23T08:29:45Z", "is_tag_good": false, "type": "note", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1458747051962, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p></p>\n<div>请向勇班的同学把“第十讲 实验三 虚拟内存管理”中指定小题的回答结果写在此贴中对应题目后面。</div>\n<div> </div>\n<div><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/04-3-lab3-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/04-3-lab3-spoc-discussion.md#小组思考题</a></div>\n<div> </div>\n<div>第十讲的回答的截止时间是今天&#xff08;20160323&#xff09;晚20点前。</div>\n<div> </div>\n<div>要求&#xff1a;</div>\n<div>1. 最多四个人一组&#xff0c;也可以独立回答。</div>\n<div> </div>\n<div>题目&#xff1a;</div>\n<div> 1. 小组思考题(1)&#xff1a;请思考如何在lab3_results中实现clock算法&#xff0c;给出你的概要设计方案。要求说明你的方案中clock算法与LRU算法上相比&#xff0c;潜在的性能差异性。进而说明在lab3的LRU算法实现的可能性评价。</div>\n<div></div>\n<div>优胜者&#xff1a;</div>\n<div></div>\n<div>李宇轩 2013011349</div>", "anon": "no", "subject": "2016春季-第十讲课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-03-23T08:51:15Z"}, {"content": "<p></p><div>请向勇班的同学把“第十讲 实验三 虚拟内存管理”中指定小题的回答结果写在此贴中对应题目后面。</div>\n<div> </div>\n<div><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/04-3-lab3-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/04-3-lab3-spoc-discussion.md#小组思考题</a></div>\n<div> </div>\n<div>第十讲的回答的截止时间是今天&#xff08;20160323&#xff09;晚20点前。</div>\n<div> </div>\n<div>要求&#xff1a;</div>\n<div>1. 最多四个人一组&#xff0c;也可以独立回答。</div>\n<div> </div>\n<div>题目&#xff1a;</div>\n<div> 1. 小组思考题(1)&#xff1a;请思考如何在lab3_results中实现clock算法&#xff0c;给出你的概要设计方案。要求说明你的方案中clock算法与LRU算法上相比&#xff0c;潜在的性能差异性。进而说明在lab3的LRU算法实现的可能性评价。</div>\n<div></div>\n<div>优胜者&#xff1a;</div>", "anon": "no", "subject": "2016春季-第十讲课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-03-23T08:29:45Z"}]}, "error": null}