{"aid": "izvenz13vwn2xb", "result": {"status": "active", "unique_views": 34, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-03-03T06:33:17Z", "data": "iztg1hlxrve5p6", "uid": "hdjonbiyfs62ie"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:37:40Z", "type": "followup", "uid": "ie7xyabq1z61v9"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:40:11Z", "type": "followup", "uid": "ie7xy5sipx51qz"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:41:28Z", "type": "followup", "uid": "ie7xy0l5qrq1lq"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:41:51Z", "type": "followup", "uid": "izb0cbqbyzd6wf"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:41:55Z", "type": "followup", "uid": "ie7xy0nh1811ls"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:41:59Z", "type": "followup", "uid": "ie7xy1b3f61mi"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:42:21Z", "type": "followup", "uid": "i5g31e12hcr27s"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:42:29Z", "type": "followup", "uid": "ie7xy0669cj1lc"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:42:46Z", "type": "followup", "uid": "izb0ce5rlex6xc"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:42:47Z", "type": "followup", "uid": "ie7xxyhe7dp1jr"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:43:55Z", "type": "followup", "uid": "ie7xy5cvsc61qg"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:44:28Z", "type": "followup", "uid": "ixur2nigPyB"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:47:02Z", "type": "followup", "uid": "izb0cbe1zb56w5"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:51:57Z", "type": "feedback", "uid": "ie7xy0669cj1lc"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:53:11Z", "type": "followup", "uid": "ie7xxz4di3o1ke"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:53:34Z", "type": "feedback", "uid": "ie7xy0l5qrq1lq"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:54:45Z", "type": "followup", "uid": "ikjdo9jtz0e2jq"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:54:47Z", "type": "feedback", "uid": "ie7xy6ut1rx1rv"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:57:05Z", "type": "feedback", "uid": "ikjdo9jtz0e2jq"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T06:59:16Z", "type": "feedback", "uid": "ie7xy1b3f61mi"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T08:21:48Z", "type": "followup", "uid": "ie7xy9yltfs1uq"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T10:09:25Z", "type": "followup", "uid": "ie7xy8iscsw1t7"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T13:46:18Z", "type": "followup", "uid": "izb0cbkdd5s6w9"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-03T14:45:17Z", "type": "followup", "uid": "ie7xy6gkrq21rh"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-04T02:13:36Z", "type": "feedback", "uid": "ie7xy6isp8v1rk"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-04T03:13:51Z", "type": "followup", "uid": "ie7xy6isp8v1rk"}, {"to": "iztg1hlu2x25p5", "anon": "no", "when": "2017-03-04T09:19:20Z", "type": "followup", "uid": "ie7xy8gtpwk1t5"}], "upvote_ids": [], "id": "iztg1hlu2x25p5", "bookmarked": 25, "tags": ["2017", "instructor-note", "lecture4", "课堂问答"], "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2017-03-03T06:37:40Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xyabq1z61v9", "created": "2017-03-03T06:37:40Z", "type": "followup", "no_answer": 0, "id": "iztg74iak9hq9", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>lab8 libs/x86.h line 64</p>\n<pre>asm volatile (&#34;inw %1, %0&#34; : &#34;=a&#34; (data) : &#34;d&#34; (port));</pre>\n<div>翻译为汇编代码后为</div>\n<pre>inw %dx, %ax</pre>\n<div>从IO端口port中读取一个字(uint16_t)放入data中</div>"}, {"folders": [], "updated": "2017-03-03T06:40:11Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xy5sipx51qz", "created": "2017-03-03T06:40:11Z", "type": "followup", "no_answer": 0, "id": "iztgacnbrvi36h", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "在<code>/libs/atomic.h</code>文件中有函数&#xff1a;\n<pre>/* *\n * test_and_set_bit - Atomically set a bit and return its old value\n * &#64;nr:     the bit to set\n * &#64;addr:   the address to count from\n * */\nstatic inline bool\ntest_and_set_bit(int nr, volatile void *addr) {\n    int oldbit;\n    asm volatile (&#34;btsl %2, %1; sbbl %0, %0&#34; : &#34;=r&#34; (oldbit), &#34;=m&#34; (*(volatile long *)addr) : &#34;Ir&#34; (nr) : &#34;memory&#34;);\n    return oldbit != 0;\n}</pre>\n其中的内联汇编代码为&#xff1a;\n<pre>asm volatile (&#34;btsl %2, %1; sbbl %0, %0&#34; : &#34;=r&#34; (oldbit), &#34;=m&#34; (*(volatile long *)addr) : &#34;Ir&#34; (nr) : &#34;memory&#34;);</pre>\n完整包含“三个冒号格式”。\n\n1. 第一个关键字<code>asm</code>表示内联汇编代码&#xff1b;第二个关键字<code>volatile</code>表示禁止编译器优化重排&#xff1b;\n2. 括号里引号部分表示主要指令为<code>btsl</code>和<code>sbbl</code>两条&#xff1b;\n3. 第一个冒号后的部分表示会有两个输出变量。第一个输出变量是<code>oldbit</code>&#xff0c;<code>&#34;=r&#34;</code>表示可以存到任何寄存器内&#xff1b;第二个输出变量<code>&#34;=m&#34;</code>表示将输出变量直接存到内存中地址为<code>addr</code>的地方&#xff1b;\n4. 第二个冒号后的部分表示会有一个输入变量。<code>&#34;Ir&#34;</code>表示输入变量<code>nr</code>是一个常数&#xff0c;从寄存器输入&#xff1b;\n5. 第三个冒号后的部分表示“修改部分”。<code>&#34;memory&#34;</code>表示内存已经变化&#xff0c;并通知编译器。"}, {"folders": [], "updated": "2017-03-03T06:41:28Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xy0l5qrq1lq", "created": "2017-03-03T06:41:28Z", "type": "followup", "no_answer": 0, "id": "iztgc09b87f2lz", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2017-03-03T06:53:34Z", "uid": "ie7xy0l5qrq1lq", "created": "2017-03-03T06:53:34Z", "type": "feedback", "d-bucket": "Yesterday", "id": "iztgrk36iki138", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p><pre>static inline uint8_t\ninb(uint16_t port) {\n    uint8_t data;\n    asm volatile (&#34;inb %1, %0&#34; : &#34;=a&#34; (data) : &#34;d&#34; (port) : &#34;memory&#34;); &#xff0f;&#xff0f; 第57行\n    return data;\n}</pre>\n<p>从 port 输入到寄存器 dx&#xff0c;使用寄存器 ax 输出到data中。</p>\n<p></p>\n<p>修改部分&#xff08;clobber list,也称 乱码列表&#xff09;:这部分以“memory”为约束条件&#xff0c;以表示操作完成后内存中的内容已有改变&#xff0c;如果原来某个寄存器的内容来自内存&#xff0c;那么现在内存中这个单元的内容已经改变。乱码列表通知编译器&#xff0c;有些寄存器或内存因内联汇编块造成乱码&#xff0c;可隐式地破坏了条件寄存器的某些位&#xff08;字段&#xff09;。</p>"}], "subject": "<p>/lab8_result/libs/x86.h </p>\n<p>第57行&#xff1a;占坑&#xff0c;稍后更新</p>"}, {"folders": [], "updated": "2017-03-03T06:41:51Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "izb0cbqbyzd6wf", "created": "2017-03-03T06:41:51Z", "type": "followup", "no_answer": 1, "id": "iztgci0s88h3bn", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p><tt>lab1/kern/mm/pmm.c</tt> 第60行. 加载 <tt>gdt</tt> 占坑.</p>\n<p></p>\n<p>代码: </p>\n<p></p>\n<pre>static inline void\nlgdt(struct pseudodesc *pd) {\n    asm volatile (&#34;lgdt (%0)&#34; :: &#34;r&#34; (pd));\n    asm volatile (&#34;movw %%ax, %%gs&#34; :: &#34;a&#34; (USER_DS));\n    asm volatile (&#34;movw %%ax, %%fs&#34; :: &#34;a&#34; (USER_DS));\n    asm volatile (&#34;movw %%ax, %%es&#34; :: &#34;a&#34; (KERNEL_DS));\n    asm volatile (&#34;movw %%ax, %%ds&#34; :: &#34;a&#34; (KERNEL_DS));\n    asm volatile (&#34;movw %%ax, %%ss&#34; :: &#34;a&#34; (KERNEL_DS));\n    // reload cs\n    asm volatile (&#34;ljmp %0, $1f\\n 1:\\n&#34; :: &#34;i&#34; (KERNEL_CS));\n}\n\n</pre>\n<p>让 cpu 知道当前 gdt 表的位置. 改一些寄存器, 然后重新获取cs.</p>"}, {"folders": [], "updated": "2017-03-03T06:41:55Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xy0nh1811ls", "created": "2017-03-03T06:41:55Z", "type": "followup", "no_answer": 1, "id": "iztgclbycz53w6", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>lab8_result/kern/process/proc.c, line 962</p>\n<pre>// kernel_execve - do SYS_exec syscall to exec a user program called by user_main kernel_thread\nstatic int\nkernel_execve(const char *name, const char **argv) {\n    int argc = 0, ret;\n    while (argv[argc] != NULL) {\n        argc &#43;&#43;;\n    }\n    asm volatile (\n        &#34;int %1;&#34;\n        : &#34;=a&#34; (ret)\n        : &#34;i&#34; (T_SYSCALL), &#34;0&#34; (SYS_exec), &#34;d&#34; (name), &#34;c&#34; (argc), &#34;b&#34; (argv)\n        : &#34;memory&#34;);\n    return ret;\n}</pre>\n<p>该函数的调用链&#xff1a;</p>\n<p>kern_init() (in kern/init/init.c)</p>\n<p>proc_init() (in kern/proc/proc.c)</p>\n<p>init_main() (in kern/proc/proc.c)</p>\n<p>user_main() (in kern/proc/proc.c)</p>\n<p>KERNEL_EXECVE() (in kern/proc/proc.c)</p>\n<p>__KERNEL_EXECVE() (in kern/proc/proc.c)</p>\n<p>kern_execve() (in kern/proc/proc.c)</p>\n<p></p>\n<p>该函数在操作系统启动时&#xff0c;从内核态调用用户态的sh程序时使用。</p>\n<p>这个函数在内核态产生了一个系统调用&#xff0c;调用类型为SYS_exec&#xff0c;把程序名和参数(argc、argv)作为系统调用的参数传入&#xff0c;通过系统调用来启动一个用户态程序。</p>"}, {"folders": [], "updated": "2017-03-03T06:41:59Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xy1b3f61mi", "created": "2017-03-03T06:41:59Z", "type": "followup", "no_answer": 1, "id": "iztgcodlmhj2cg", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2017-03-03T06:59:16Z", "uid": "ie7xy1b3f61mi", "created": "2017-03-03T06:59:16Z", "type": "feedback", "d-bucket": "Yesterday", "id": "iztgyvv9lik66p", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>"}], "subject": "<p>lab8 kern/init/init.c line 82-87</p>\n<p></p>\n<pre>asm volatile(\n\t&#34;mov %%cs, %0;&#34;\n \t&#34;mov %%ds, %1;&#34;\n\t&#34;mov %%es, %2;&#34; \n\t&#34;mov %%ss, %3;&#34;\n\t: &#34;=m&#34;(reg1), &#34;=m&#34;(reg2), &#34;=m&#34;(reg3), &#34;=m&#34;(reg4));</pre>\n<p></p>\n<p>1. 前四条语句为mov指令&#xff0c;分别将cs,ds,,es,ss这四个寄存器的内容依次放到第1-4个寄存器中。</p>\n<p>2. 冒号后为输出语句&#xff0c;参数皆为&#34;=m&#34;&#xff0c;表示输出变量直接存到内存中地址为<span style=\"font-family:monospace\">reg1,reg2,reg3,reg4</span>的地方。</p>\n<p>3. 因此这段代码的效果为&#xff0c;将cs, ds, es, ss这四个寄存器的内容依次赋给reg1,reg2,reg3,reg4这四个变量。</p>"}, {"folders": [], "updated": "2017-03-03T06:42:21Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "i5g31e12hcr27s", "created": "2017-03-03T06:42:21Z", "type": "followup", "no_answer": 0, "id": "iztgd5bqkf12hn", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<pre>// kern/libs/x86.h\nstatic inline uint32_t\nread_ebp(void) {\n    uint32_t ebp;\n    asm volatile (&#34;movl %%ebp, %0&#34; : &#34;=r&#34; (ebp));\n    return ebp;\n}</pre>\n<p>asm: 表示内联汇编</p>\n<p>volatile: 避免指令被删除/移动/组合</p>\n<pre>movl %%ebp, %0</pre>\n<p>%%ebp表示%ebp寄存器, %0表示使用1个操作数/变量.</p>\n<p>=r表示%0可以使用任意通用寄存器, (ebp)表示变量uint32_t ebp存放在该寄存器中</p>"}, {"folders": [], "updated": "2017-03-03T06:42:29Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xy0669cj1lc", "created": "2017-03-03T06:42:29Z", "type": "followup", "no_answer": 1, "id": "iztgdaxysdq2lt", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2017-03-03T06:51:57Z", "uid": "ie7xy0669cj1lc", "created": "2017-03-03T06:51:57Z", "type": "feedback", "d-bucket": "Yesterday", "id": "iztgphqs1wj7j9", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<pre>    asm volatile (&#34;lgdt (%0)&#34; :: &#34;r&#34; (pd));\n    asm volatile (&#34;movw %%ax, %%gs&#34; :: &#34;a&#34; (USER_DS));\n    asm volatile (&#34;movw %%ax, %%fs&#34; :: &#34;a&#34; (USER_DS));\n    asm volatile (&#34;movw %%ax, %%es&#34; :: &#34;a&#34; (KERNEL_DS));\n    asm volatile (&#34;movw %%ax, %%ds&#34; :: &#34;a&#34; (KERNEL_DS));\n    asm volatile (&#34;movw %%ax, %%ss&#34; :: &#34;a&#34; (KERNEL_DS));\n    // reload cs\n    asm volatile (&#34;ljmp %0, $1f\\n 1:\\n&#34; :: &#34;i&#34; (KERNEL_CS));</pre>\n<p><code>加载GDT&#xff0c;并且重置kernel中的段存储。&#xff08;比如在bootloader过程中&#xff0c;初始化段存储时&#xff0c;需加载GDT表&#xff0c;第一条语句是特殊汇编指令&#xff0c;表示将pd的值作为GDT的地址&#xff0c;之后将相应的kernel中段存储的相关参数置给相应的寄存器&#xff0c;最后重新得到cs寄存器的值</code></p>"}], "subject": "<p>pmm 102 占坑</p>"}, {"folders": [], "updated": "2017-03-03T06:42:46Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "izb0ce5rlex6xc", "created": "2017-03-03T06:42:46Z", "type": "followup", "no_answer": 1, "id": "iztgdo7780t2r4", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p> /libs/x86.h</p>\n<p> 82 static inline void<br /> 83 cli(void) {<br /> 84     asm volatile (&#34;cli&#34;);<br /> 85 }</p>\n<p></p>\n<p>禁止中断</p>"}, {"folders": [], "updated": "2017-03-03T06:42:47Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xxyhe7dp1jr", "created": "2017-03-03T06:42:47Z", "type": "followup", "no_answer": 0, "id": "iztgdpeborb3fo", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>/kern/debug/kdebug.h: line 295</p>\n<p></p>\n<pre>static __noinline uint32_t\nread_eip(void) {\n    uint32_t eip;\n    asm volatile(&#34;movl 4(%%ebp), %0&#34; : &#34;=r&#34; (eip));\n    return eip;\n}</pre>\n<p></p>\n<p>读出调用此函数时 eip 寄存器的值</p>\n<p></p>\n<p>用到了调用函数时会把返回地址(即 eip 寄存器)的值压在栈上的的约定&#xff0c;所以可以通过直接读取 4(%ebp) 来读取 %eip</p>\n<p></p>\n<p>&#xff08;致上学期调板子天天 trap 到 kernel debugger 的日子 </p>\n<p></p>"}, {"folders": [], "updated": "2017-03-03T06:43:55Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xy5cvsc61qg", "created": "2017-03-03T06:43:55Z", "type": "followup", "no_answer": 1, "id": "iztgf5e6e0a4s4", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>libs/x86.h</p>\n<p>259 static inline void *                                                                                                                      <br />260 __memset(void *s, char c, size_t n) {<br />261     int d0, d1;<br />262     asm volatile (<br />263         &#34;rep; stosb;&#34;<br />264         : &#34;=&amp;c&#34; (d0), &#34;=&amp;D&#34; (d1)<br />265         : &#34;0&#34; (n), &#34;a&#34; (c), &#34;1&#34; (s)<br />266         : &#34;memory&#34;);<br />267     return s;<br />268 }<br /><br /></p>\n<p>memset 操作</p>\n<p>rep stosb就是从EDI所指的内存开始&#xff0c;将连续的ECX个字节写成AL的内容</p>\n<p></p>"}, {"folders": [], "updated": "2017-03-03T06:44:28Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ixur2nigPyB", "created": "2017-03-03T06:44:28Z", "type": "followup", "no_answer": 1, "id": "iztgfv7wwo657q", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2017-03-03T06:54:47Z", "uid": "ie7xy6ut1rx1rv", "created": "2017-03-03T06:54:47Z", "type": "feedback", "d-bucket": "Yesterday", "id": "iztgt4pnk2c2j3", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p><p>补充&#xff0c;%1表示第2个C语言中的标志符&#xff0c;在本处表示的是T_SYSCALL</p>\n<p></p>"}, {"folders": [], "updated": "2017-03-04T02:13:36Z", "uid": "ie7xy6isp8v1rk", "created": "2017-03-04T02:13:36Z", "type": "feedback", "id": "izum7dj5qsb12", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>补充&#34;cc&#34;</p>\n<p>手册上说&#xff1a;If our instruction can alter the condition code register, we have to add &#34;cc&#34; to the list of clobbered registers.</p>\n<p>也就是在此处会改变条件码寄存器。</p>"}], "subject": "<p>lab8/user/syscall.c</p>\n<pre>static inline int<br />syscall(int num, ...) {<br />    va_list ap;<br />    va_start(ap, num);<br />    uint32_t a[MAX_ARGS];<br />    int i, ret;<br />    for (i = 0; i &lt; MAX_ARGS; i &#43;&#43;) {<br />        a[i] = va_arg(ap, uint32_t);<br />    }<br />    va_end(ap);<br /><br />    asm volatile (<br />        &#34;int %1;&#34;<br />        : &#34;=a&#34; (ret)<br />        : &#34;i&#34; (T_SYSCALL),<br />          &#34;a&#34; (num),<br />          &#34;d&#34; (a[0]),<br />          &#34;c&#34; (a[1]),<br />          &#34;b&#34; (a[2]),<br />          &#34;D&#34; (a[3]),<br />          &#34;S&#34; (a[4])<br />        : &#34;cc&#34;, &#34;memory&#34;);<br />    return ret;<br />}</pre>\n<p>num表示系统调用号&#xff0c;存于%eax</p>\n<p>%edx&#xff0c;%ecx&#xff0c;%ebx&#xff0c;%edi&#xff0c;%esi分别存放传入的5个参数</p>\n<p>memory表示上述汇编代码会对内存进行修改</p>\n<p>结果返回值存于%eax&#xff0c;随后放入ret变量&#xff0c;返回</p>"}, {"folders": [], "updated": "2017-03-03T06:47:02Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "izb0cbe1zb56w5", "created": "2017-03-03T06:47:02Z", "type": "followup", "no_answer": 1, "id": "iztgj632tw45ql", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>lab8 &#96;lab8 libs/x86.h&#96; line78-81</p>\n<pre>static inline void\noutb(uint16_t port, uint8_t data) {\n    asm volatile (&#34;outb %0, %1&#34; :: &#34;a&#34; (data), &#34;d&#34; (port));\n}</pre>\n<p>实现了将源操作数(单个字节, uint8_t)拷贝至 CPU 端口(目的操作数代表的)的功能.</p>"}, {"folders": [], "updated": "2017-03-03T06:53:11Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xxz4di3o1ke", "created": "2017-03-03T06:53:11Z", "type": "followup", "no_answer": 0, "id": "iztgr2tvhbhxq", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>在<strong>libs/x86.h</strong>中的153行有&#xff1a;</p>\n<pre>asm volatile (&#34;ltr %0&#34; :: &#34;r&#34; (sel) : &#34;memory&#34;);</pre>\n<p>意思即&#xff1a;</p>\n<p>读取目标寄存器的值到task register中&#xff0c;这里的目标寄存器是r。实际上&#xff0c;load进去的是变量sel的值。</p>\n<p>memory代表会对内存进行操作。</p>\n<p></p>\n<p>mooc中提到了a, b, c, d, S, D的代表含义&#xff0c;分别指%eax, %ebx, %ecx, %edx, %esi, %edi。</p>\n<p>而在这里r的意思是指gcc会使用任意一个寄存器。</p>\n<p>也正因如此&#xff0c;我们无法预知GCC会使用哪个寄存器&#xff0c;也就无法具体给出将要发生的寄存器是哪一个。因此用一个笼统的&#34;memory&#34;来泛指&#xff1a;寄存器中有一个发生了变化。</p>"}, {"folders": [], "updated": "2017-03-03T06:54:45Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ikjdo9jtz0e2jq", "created": "2017-03-03T06:54:45Z", "type": "followup", "no_answer": 0, "id": "iztgt357j9h1jn", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2017-03-03T06:57:05Z", "uid": "ikjdo9jtz0e2jq", "created": "2017-03-03T06:57:05Z", "type": "feedback", "d-bucket": "Yesterday", "id": "iztgw2tg8ws4r3", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>分析第一条&#xff1a;取出ebp&#43;4地址中的内容&#xff0c;赋予变量eip</p>"}], "subject": "<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/ikjdo9jtz0e2jq/iztgpdjucscn/1.png\" alt=\"\" /></p>\n<p>使用cscope工具在lab8中找到结果六十余条&#xff0c;上截图。</p>\n<p></p>\n<p></p>\n<p></p>"}, {"folders": [], "updated": "2017-03-03T08:21:48Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xy9yltfs1uq", "created": "2017-03-03T08:21:48Z", "type": "followup", "no_answer": 1, "id": "iztjx0ysy3u79r", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>选择<em>lab4/lib/atomic.h</em>中的以下函数&#xff1a;</p>\n<pre>/* *<br /> * change_bit - Atomically toggle a bit in memory<br /> * &#64;nr:     the bit to change<br /> * &#64;addr:   the address to start counting from<br /> * */<br />static inline void<br />change_bit(int nr, volatile void *addr) {<br />    asm volatile (&#34;btcl %1, %0&#34; :&#34;=m&#34; (*(volatile long *)addr) : &#34;Ir&#34; (nr));<br />}</pre>\n<p>其中内联汇编的作用是&#xff0c;将所传参数<em>addr</em>所指地址的第<em>nr</em>位通过汇编指令“<em>btcl</em>”反转&#xff1b;</p>\n<p>第一个可选参数表示有一个输出参数&#xff0c;将最终得到的结果赋给<em>addr</em>指针指向的内存区域&#xff1b;</p>\n<p>第二个可选参数是一个输入参数&#xff0c;指明汇编指令中要改变的是第几位。</p>"}, {"folders": [], "updated": "2017-03-03T10:09:25Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xy8iscsw1t7", "created": "2017-03-03T10:09:25Z", "type": "followup", "no_answer": 1, "id": "iztnrf8dedb2gm", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p><p>labcodes_answer/lab8_result/libs/x86.h中的159行&#xff1a;</p>\n<pre>read_eflags(void) {<br />    uint32_t eflags;<br />    asm volatile (&#34;pushfl; popl %0&#34; : &#34;=r&#34; (eflags));<br />    return eflags;<br />}</pre>\n<p>asm: 表示内联汇编</p>\n<p>volatile: 避免指令被删除/移动/组合</p>\n<pre>popl %0&#34; : &#34;=r&#34; (eflags)</pre>\n<p>%0表示使用1个操作数/变量&#xff1b;=r表示%0可以使用任意通用寄存器&#xff1b; (eflags)表示变量eflags存放在该寄存器中。</p>\n<p></p>"}, {"folders": [], "updated": "2017-03-03T13:46:18Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "izb0cbkdd5s6w9", "created": "2017-03-03T13:46:18Z", "type": "followup", "no_answer": 1, "id": "iztvic661h9h8", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p><em>labcodes_answer/lab8_result/libs/atomic.h</em> 中一下函数</p>\n<pre>/* *\n * test_bit - Determine whether a bit is set\n * &#64;nr:     the bit to test\n * &#64;addr:   the address to count from\n * */\nstatic inline bool\ntest_bit(int nr, volatile void *addr) {\n    int oldbit;\n    asm volatile (&#34;btl %2, %1; sbbl %0,%0&#34; : &#34;=r&#34; (oldbit) : &#34;m&#34; (*(volatile long *)addr), &#34;Ir&#34; (nr));\n    return oldbit != 0;\n}</pre>\n<p>btl 测试addr的第nr位复制到寄存器CF</p>\n<p>sbbl 表示将oldorbit减去oldorbit再减去CF&#xff0c;进而判断出addr第nr位的值</p>\n<p>&#34;=r&#34;表示任意寄存器</p>\n<p>&#34;m&#34; 表示内存操作数&#xff0c;</p>\n<p>&#34;Ir&#34;表示任意寄存器&#xff0c;值在0-31之间</p>"}, {"folders": [], "updated": "2017-03-03T14:45:17Z", "d-bucket": "Yesterday", "no_upvotes": 0, "uid": "ie7xy6gkrq21rh", "created": "2017-03-03T14:45:17Z", "type": "followup", "no_answer": 1, "id": "iztxm6og1rt5nm", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "/labcodes_answer/lab8_result/libs/x86.h中第165行<div><br /></div><div>static inline void</div><div>write_eflags(uint32_t eflags) {</div><div>    asm volatile (&#34;pushl %0; popfl&#34; :: &#34;r&#34; (eflags));</div><div>}</div><div><br /></div><div><br /></div><div>volatile 表示不进行进一步优化调整顺序</div><div><br /></div><div>&#34;r&#34; (eflags) &#xff1a;表示%0中存放的是eflags的值</div>"}, {"folders": [], "updated": "2017-03-04T03:13:51Z", "no_upvotes": 0, "uid": "ie7xy6isp8v1rk", "created": "2017-03-04T03:13:51Z", "type": "followup", "no_answer": 1, "id": "izuocux1pvs1k0", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>在lab1/libs/x86.h中</p>\n<pre>#define do_div(n, base) ({                                        \\\n    unsigned long __upper, __low, __high, __mod, __base;        \\\n    __base = (base);                                            \\\n    asm(&#34;&#34; : &#34;=a&#34; (__low), &#34;=d&#34; (__high) : &#34;A&#34; (n));            \\\n    __upper = __high;                                            \\\n    if (__high != 0) {                                            \\\n        __upper = __high % __base;                                \\\n        __high = __high / __base;                                \\\n    }                                                            \\\n    asm(&#34;divl %2&#34; : &#34;=a&#34; (__low), &#34;=d&#34; (__mod)                    \\\n        : &#34;rm&#34; (__base), &#34;0&#34; (__low), &#34;1&#34; (__upper));            \\\n    asm(&#34;&#34; : &#34;=A&#34; (n) : &#34;a&#34; (__low), &#34;d&#34; (__high));                \\\n    __mod;                                                        \\\n })</pre>\n<p>第一个内联汇编代码</p>\n<pre><tt>asm(&#34;&#34; : &#34;=a&#34; (__low), &#34;=d&#34; (__high) : &#34;A&#34; (n));</tt></pre>\n<p>其中&#34;A&#34;的意思是 Specifies the &#96;a’ or &#96;d’ registers. This is primarily useful for 64-bit integer values intended to be returned with the &#96;d’ register holding the most significant bits and the &#96;a’ register holding the least significant bits. 就是说把64位的整数n的高32位放在寄存器edx&#xff0c;低32位放在寄存器eax。再把eax的值放在变量__low&#xff0c;edx的值放在变量__high。<br /><br />第二个内联汇编代码</p>\n<pre>asm(&#34;divl %2&#34; : &#34;=a&#34; (__low), &#34;=d&#34; (__mod)                    \\\n        : &#34;rm&#34; (__base), &#34;0&#34; (__low), &#34;1&#34; (__upper));</pre>\n<p>根据手册&#xff0c;Common constraints include ‘r’ for register and ‘m’ for memory. When you list more than one possible location (for example, <code>&#34;=rm&#34;</code>), the compiler chooses the most efficient one based on the current context. 这里的&#34;rm&#34;表示__base可能在寄存器里可能在内存中&#xff0c;编译器会自动选择最可能的地方。%2表示__base。divl 将商存在eax&#xff0c;将余数存在edx。</p>\n<p></p>\n<p>第三个内联汇编代码</p>\n<pre>asm(&#34;&#34; : &#34;=A&#34; (n) : &#34;a&#34; (__low), &#34;d&#34; (__high)); </pre>\n<p>将32位的__high和__low分别存到寄存器edx,eax&#xff0c;n等于edx&#xff0c;eax拼接起来。</p>\n<p></p>"}, {"folders": [], "updated": "2017-03-04T09:19:20Z", "no_upvotes": 0, "uid": "ie7xy8gtpwk1t5", "created": "2017-03-04T09:19:20Z", "type": "followup", "no_answer": 1, "id": "izv1evcuuyz4gp", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p></p><pre># ucore_os_lab/labcodes_answer/lab8_result/libs/x86.h\nstatic inline uintptr_t\nrcr0(void) {\n    uintptr_t cr0;\n    asm volatile (&#34;mov %%cr0, %0&#34; : &#34;=r&#34; (cr0) :: &#34;memory&#34;);\n    return cr0;\n}</pre>\n<ul><li>作用&#xff1a;读取cr0寄存器的内容</li><li>&#34;=r&#34;表示可使用任意寄存器存储读出的内容</li><li>&#34;memory&#34;指示指令会改变内存</li></ul>"}], "nr": 995, "bucket_order": 2, "type": "note", "folders": ["2017", "课堂问答", "lecture4"], "no_answer_followup": 14, "num_favorites": 1, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2017-03-03T06:33:17Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1488641420055, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p><a href=\"https://chyyuu.gitbooks.io/os_course_exercises/content/all/02-2-lab1-spoc-discussion.html\">https://chyyuu.gitbooks.io/os_course_exercises/content/all/02-2-lab1-spoc-discussion.html</a></p>\n<p><br />每个同学找一段ucore中的一段内联汇编代码&#xff0c;进行完整的解释。在本贴后回复你的解释。如果有多个同学解释同一段代码&#xff0c;后面的同学只需要修改或完善前面同学的回答。</p>\n<p></p>\n<p>下面链接是一个内联汇编解释的样例。</p>\n<p><a href=\"http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html\">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</a></p>\n<p></p>", "anon": "no", "created": "2017-03-03T06:33:17Z", "uid": "hdjonbiyfs62ie", "subject": "2017春季-第四讲 课堂思考题回答"}]}, "error": null}