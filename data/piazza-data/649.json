{"aid": "iln9r9n4k5m17t", "result": {"folders": ["课堂问答"], "unique_views": 153, "request_instructor_me": false, "change_log": [{"data": "ilakhr3tz8c6nm", "anon": "no", "when": "2016-03-02T08:14:25Z", "uid": "hdjonbiyfs62ie", "type": "create"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:15:30Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:15:42Z", "uid": "i0hjdkesg9c5z7", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:15:49Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:16:10Z", "uid": "i0em4o8wvj34lb", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:16:15Z", "uid": "ibz6vywnw6g7nl", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:16:31Z", "uid": "i0eqqq6jvng408", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:16:33Z", "uid": "ibz6vywnw6g7nl", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:16:42Z", "uid": "ie7xy3iwuug1os", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:20:05Z", "uid": "i0nuu5yhgno5tv", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:20:05Z", "uid": "i0c1nsm3911wc", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:20:26Z", "uid": "i0nuu5yhgno5tv", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:21:20Z", "uid": "i3qk2vs65x276j", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:22:21Z", "uid": "i0nuu5yhgno5tv", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:22:27Z", "uid": "i18riqkwrl225m", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:22:34Z", "uid": "i0ayxqk6wry734", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:22:59Z", "uid": "i6ub4vwhQXd", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:24:02Z", "uid": "i0yuo4o74sx70w", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:24:23Z", "uid": "i0nan8i4g0o3s3", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:25:20Z", "uid": "ierwkwbinsj2t8", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:25:29Z", "uid": "i6w84pnmjCQ", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:25:52Z", "uid": "i242q8ug7vw40x", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:27:35Z", "uid": "i0f7v0qgfm61s6", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:28:35Z", "uid": "i6vjwdpfniF", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:29:07Z", "uid": "i0evrfcnckf5dt", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:29:37Z", "uid": "i6vir34gLfK", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:30:21Z", "uid": "i0em4o8wvj34lb", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:30:22Z", "uid": "i21zpwab2z775p", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:30:43Z", "uid": "ie7xy71bn7b1s2", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:33:12Z", "uid": "ikvcvq38pa7l6", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:33:17Z", "uid": "i6ugy67km5b", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:37:49Z", "uid": "i6ub5at2geM", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:38:06Z", "uid": "ikx8y1dzPrM", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:39:31Z", "uid": "i242q8ug7vw40x", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:41:16Z", "uid": "i0gkdbms5ie20o", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:41:57Z", "uid": "i701mss708y", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:46:57Z", "uid": "i1569mw0xp954u", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:47:10Z", "uid": "i11dx198ive25r", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:52:03Z", "uid": "ibz6web8v91dk", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:54:29Z", "uid": "i1jd60b7orl10p", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:54:35Z", "uid": "ikvcvo2cckb7jb", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:54:36Z", "uid": "i17iy2ly5py3ad", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T08:56:42Z", "uid": "i0f97hpgaug3eu", "type": "followup"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T09:01:06Z", "uid": "i0ccqbaxwdz75c", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T09:32:44Z", "uid": "i0d4mr9tga62ki", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T10:13:22Z", "uid": "ic226rac4j5jw", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T10:30:40Z", "uid": "i11v1az5sf83l2", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T10:34:38Z", "uid": "i0cb1385ni65l", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T10:39:29Z", "uid": "ikvcvmzbvlf7i6", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T10:49:23Z", "uid": "i2om0jwie732m1", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T10:49:36Z", "uid": "i0cb1385ni65l", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T10:51:08Z", "uid": "i0b7d04pl3y6c0", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T10:51:54Z", "uid": "i6uaz437IKR", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T11:01:17Z", "uid": "i28t9sj8bas79c", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T11:05:17Z", "uid": "ikvcvr6di5i7ma", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T11:14:15Z", "uid": "i75nho1hE8g", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T11:38:36Z", "uid": "ikx8y1dzPrM", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T11:43:34Z", "uid": "i0i7rzz9iau2gd", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T11:46:09Z", "uid": "i0ccfx63sir1e", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T11:48:08Z", "uid": "iem550jbpyn515", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T11:53:10Z", "uid": "iem550jbpyn515", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T13:23:46Z", "uid": "i0minzvpea57bu", "type": "feedback"}, {"to": "ilakhr3pzap6nl", "anon": "no", "when": "2016-03-02T14:56:37Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"data": "ilaz6crd408on", "anon": "no", "when": "2016-03-02T15:05:27Z", "uid": "hdjonbiyfs62ie", "type": "update"}], "upvote_ids": [], "id": "ilakhr3pzap6nl", "bookmarked": 54, "no_answer_followup": 2, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2016-03-02T08:15:30Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-03-02T08:15:30Z", "type": "followup", "no_answer": 1, "id": "ilakj57ax9l604", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2016-03-02T08:15:42Z", "uid": "i0hjdkesg9c5z7", "created": "2016-03-02T08:15:42Z", "type": "feedback", "id": "ilakjex3mp36he", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>王苏 2013011301</p>\n<p>王哲 2013012443</p>\n<p><strong></strong></p>\n<p><strong>1.各自的含义</strong></p>\n<p>    CPL是当前进程的权限级别(Current Privilege Level)&#xff0c;是当前正在执行的代码所在的段的特权级。</p>\n<p>    RPL说明的是进程对段访问的请求权限(Request Privilege Level)&#xff0c;是对于段选择子而言的&#xff0c;每个段选择子有自己的RPL&#xff0c;它说明的是进程对段访问的请求权     限&#xff0c;有点像函数参数。</p>\n<p>    DPL规定访问该段的权限级别(Descriptor Privilege Level)&#xff0c;每个段的DPL固定。</p>\n<p></p>\n<p><strong>2.在哪些寄存器中</strong></p>\n<p>   CPL存储在cs寄存器中。</p>\n<p>   RPL存储在段选择子中。</p>\n<p>   DPL存储在段描述符中。</p>\n<p></p>\n<p><strong>3.访问条件</strong></p>\n<p>  进程访问一个段时&#xff0c;需要进程特权级检查&#xff0c;一般要求DPL &gt;= max {CPL, RPL}。</p>"}, {"folders": [], "updated": "2016-03-02T08:16:10Z", "uid": "i0em4o8wvj34lb", "created": "2016-03-02T08:16:10Z", "type": "feedback", "id": "ilakk0k6tc06ac", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>DPL是存在于段描述符中的特权级&#xff0c;表示这个段代表的特权级</p>\n<p>CPL是存在于CS&#xff08;代码段寄存器&#xff09;中&#xff0c;表示当前执行代码的特权级的描述标志</p>\n<p>RPL是存在于每一个段选择子中&#xff0c;说明的是进程对段访问的请求权限&#xff0c;是对于段选择子而言的&#xff0c;每个段选择子有自己的RPL&#xff0c;它说明的是进程对段访问的请求权限</p>\n<p>当访问段时&#xff0c;DPL&gt;= max{CPL, RPL}</p>"}, {"folders": [], "updated": "2016-03-02T08:16:15Z", "uid": "ibz6vywnw6g7nl", "created": "2016-03-02T08:16:15Z", "type": "feedback", "id": "ilakk4ajqil2bl", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>当前特权级CPL是当前进程运行代码所在的段的特权级&#xff0c;视为进程的优先级&#xff0c;请求特权级RPL是进程对段访问的特权级&#xff0c;符特权级DPL是该段被访问的特权级。</p>\n<p>CPL存储于cs寄存器的低2位&#xff0c;RPL存储于段选择子的低2位&#xff0c;DPL存储于段描述符里。</p>\n<p>当进程访问段时&#xff0c;要求段的符特权级DPL要高于CPL和RPL。</p>"}, {"folders": [], "updated": "2016-03-02T08:16:42Z", "uid": "ie7xy3iwuug1os", "created": "2016-03-02T08:16:42Z", "type": "feedback", "id": "ilakkp78eql2ha", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2014011381 梁泽宇</p>\n<p></p>\n<p>CPL为当前进程特权级&#xff0c;DPL为段特权级&#xff08;访问该段所需的特权级&#xff09;&#xff0c;</p>\n<p>当前进程访问其它进程时&#xff0c;被访问进程所在段的DPL要不小于当前进程CPL。</p>\n<p>RPL为段选择子权限级&#xff0c;有时使用偏移&#xff08;段选择子:偏移量&#xff09;的方式访问段&#xff0c;此时&#xff0c;被访问进程所在段的DPL要同时不小于当前进程所在段选择子的RPL以及当前进程的CPL。</p>\n<p></p>\n<p>CPL保存于CS和SS寄存器的1..0位&#xff0c;RPL保存于段选择子的1..0位&#xff0c;而DPL是段的一个固有属性&#xff0c;不保存在寄存器中。</p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:20:05Z", "uid": "i0nuu5yhgno5tv", "created": "2016-03-02T08:20:05Z", "type": "feedback", "id": "ilakp1socpe51o", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>发错了- -我是第二题。</p>"}, {"folders": [], "updated": "2016-03-02T08:20:05Z", "uid": "i0c1nsm3911wc", "created": "2016-03-02T08:20:05Z", "type": "feedback", "id": "ilakp1z3m6e5kz", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>朱俸民 2012011894 &amp; 朱新瑞 2013011411</p>\n<p></p>\n<p>1. 含义</p>\n<ul><li>CPL是当前进程的权限级别(Current Privilege Level)&#xff0c;是当前正在执行的代码所在的段的特权级</li><li>RPL说明的是进程对段访问的请求权限(Request Privilege Level)&#xff0c;是对于段选择子而言的&#xff0c;每个段选择子有自己的RPL&#xff0c;它说明的是进程对段访问的请求</li><li>DPL存储在段描述符中&#xff0c;规定访问该段的权限级别(Descriptor Privilege Level)&#xff0c;每个段的DPL固定</li></ul>\n<p></p>\n<p>2. 在哪些寄存器中这些字段&#xff1f;</p>\n<ul><li>CPL&#xff1a;存储在CS段寄存器的最低两位</li><li>DPL&#xff1a;在段描述符中的权限位</li><li>RPL&#xff1a;在段选择子的最低两位</li></ul>\n<p></p>\n<p>3. 对应的访问条件是什么&#xff1f;</p>\n<p>一般要求DPL &gt;= max {CPL, RPL}&#xff0c;即本身所具备的权限或者请求权限中的最低者&#xff0c;也必须高于所规定的权限。</p>\n<p></p>\n<p>4. 小程序</p>\n<p></p>\n<p>提升用户态的DPL (Line 46~47, kern/mm/pmm.c):</p>\n<p></p>\n<pre>[SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_KERNEL),\n[SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),</pre>\n<p>这时运行</p>\n<pre>make &amp;&amp; make qemu</pre>\n<p>会出错&#xff0c;OS会不断reboot。</p>\n<p></p>\n<p>如果我们也提升用户态的CPL (Line 25~26, kern/mm/memlayout.h):</p>\n<pre>#define USER_CS        ((GD_UTEXT) | DPL_KERNEL)\n#define USER_DS        ((GD_UDATA) | DPL_KERNEL)</pre>\n<p>尽管这时OS可以运行&#xff0c;但是会报错</p>\n<pre>qemu: fatal: Trying to execute code outside RAM or ROM at 0xf000ff53</pre>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:21:20Z", "uid": "i3qk2vs65x276j", "created": "2016-03-02T08:21:20Z", "type": "feedback", "id": "ilakqnjx2ds4mi", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011296贺子松 2013011320陆禹</p>\n<p>描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么&#xff1f;在哪些寄存器中这些字段&#xff1f;对应的访问条件是什么&#xff1f; </p>\n<p> </p>\n<ol><li></li></ol>\n<p>CPL是当前进程的权限级别(Current Privilege Level)&#xff0c;是当前正在执行的代码所在的段的特权级&#xff0c;存在于cs寄存器的低两位。<br />        RPL说明的是进程对段访问的请求权限(Request Privilege Level)&#xff0c;是对于段选择子而言的&#xff0c;每个段选择子有自己的RPL&#xff0c;它说明的是进程对段访问的请求权限&#xff0c;有点像函数参数。而且RPL对每个段来说不是固定的&#xff0c;两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用&#xff0c;例如当前CPL=0的进程要访问一个数据段&#xff0c;它把段选择符中的RPL设为3&#xff0c;这样虽然它对该段仍然只有特权为3的访问权限。<br />       DPL存储在段描述符中&#xff0c;规定访问该段的权限级别(Descriptor Privilege Level)&#xff0c;每个段的DPL固定。</p>\n<ol start=\"2\"><li></li></ol>\n<p>RPL在段选择子的后两位</p>\n<p>程序的CPL(CS.RPL)是CS register 里bit 0和bit 1 位组合所得的值.</p>\n<p>DPL是段描述符中的特权级, 它的本意是用来代表它所描述的段的特权级. 一个程序可以使用很多段(Data&#xff0c;Code&#xff0c;Stack)也可以只用一个code段等&#xff0e;在正常的情况下当程序的环境建立好后&#xff0c;段描述符都不需要改变-----当然DPL也不需要改变&#xff0e;</p>\n<p>3. </p>\n<p>当进程访问一个段时&#xff0c;需要进程特权级检查&#xff0c;一般要求DPL &gt;= max {CPL, RPL}</p>"}, {"folders": [], "updated": "2016-03-02T08:22:27Z", "uid": "i18riqkwrl225m", "created": "2016-03-02T08:22:27Z", "type": "feedback", "id": "ilaks2ynwoj51k", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011297 杨青霖</p>\n<p>①</p>\n<p>CPL&#xff1a;当前特权级。CPL就是当前活动代码段的特权级&#xff0c;并且它定义了当前所执行程序的特权级别</p>\n<p>DPL&#xff1a;描述符特权。用于描述对应段所属的特权等级&#xff0c;也就是段本身真正的特权级。</p>\n<p>RPL&#xff1a;请求特权级。RPL说明的是进程对段访问的请求权限&#xff0c;意思是当前进程想要的请求权限。</p>\n<p>②</p>\n<p>CPL保存在CS段寄存器&#xff08;选择子&#xff09;的最低两位</p>\n<p>DPL存储在段描述符中的权限位</p>\n<p>RPL保存在选择子的最低两位</p>\n<p>③</p>\n<p>RPL的值由程序员自己来自由的设置&#xff0c;并不一定RPL&gt;=CPL&#xff0c;但是当RPL&lt;CPL时&#xff0c;实际起作用的就是CPL了&#xff0c;因为访问时的特权检查是判断&#xff1a;max(RPL,CPL)&lt;=DPL是否成立&#xff0c;所以RPL可以看成是每次访问时的附加限制&#xff0c;RPL=0时附加限制最小&#xff0c;RPL=3时附加限制最大。</p>"}, {"folders": [], "updated": "2016-03-02T08:22:34Z", "uid": "i0ayxqk6wry734", "created": "2016-03-02T08:22:34Z", "type": "feedback", "id": "ilaks8ilmy66gi", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011371 沈哲言 2013011404 叶子鹏</p>\n<p>一、特权级所处位置</p>\n<p>CPL&#xff1a;存储在CS和SS的最低两位&#xff08;第0和第1位&#xff09;</p>\n<p>DPL&#xff1a;存储在门&#xff08;中断描述符IDT&#xff09;或者段的描述符&#xff08;GDT&#xff09;的DPL字段中</p>\n<p>RPL&#xff1a;存储在代码段寄存器DS,ES,FS,GS的最低两位 寄存器结构&#xff1a;&#xff08;SS和CS一致&#xff0c;DE,ES,FS,GS一致&#xff09; <img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ayxqk6wry734/ilaow2y4be29/屏幕快照_20160302_下午6.16.59.png\" /> 段描述符的结构如下 <img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ayxqk6wry734/ilap0vfzfit9/屏幕快照_20160302_下午6.19.21.png\" /> 二、含义</p>\n<p>CPL&#xff1a;当前特权级&#xff08;Current Privilege Level) CPL就是当前活动代码段的特权级&#xff0c;并且它定义了当前所执行程序的特权级别&#xff09;</p>\n<p>DPL&#xff1a;描述符特权&#xff08;Descriptor Privilege Level&#xff09; 存储在段描述符中的权限位&#xff0c;用于描述对应段所属的特权等级&#xff0c;也就是段本身真正的特权级。</p>\n<p>RPL&#xff1a;请求特权级RPL(Request Privilege Level) RPL保存在选择子的最低两位。RPL说明的是进程对段访问的请求权限&#xff0c;意思是当前进程想要的请求权限。RPL的值由程序员自己来自由的设置&#xff0c;并不一定RPL&gt;=CPL&#xff0c;但是当RPL&lt;CPL时&#xff0c;实际起作用的就是CPL了。</p>\n<p>三、访问条件</p>\n<p>因为访问时的特权检查是判断&#xff1a;max(RPL,CPL)&lt;=DPL是否成立&#xff0c;所以RPL可以看成是每次访问时的附加限制&#xff0c;RPL=0时附加限制最小&#xff0c;RPL=3时附加限制最大。</p>\n<p>四、实例</p>\n<p><a href=\"http://www.cnblogs.com/pang123hui/archive/2010/11/27/2309924.html\" target=\"_blank\">应用RPL实现数据段的特权级保护的实例</a></p>\n<p>这个链接&#xff0c;前面一段介绍了这3个字段分别有什么含义&#xff0c;以及一些简单的例子&#xff0c;这些在我们上面这段文字也同样说明了。重要的是下面的部分&#xff0c;是一个实验的图示。说明了这些字段在不同状态下的4种情况&#xff0c;哪些是合法的&#xff0c;哪些会触发异常。它详细地描述了实验的过程&#xff0c;当程序的特权级不足&#xff0c;或是请求特权级不足时&#xff0c;会产生异常(或报错)&#xff0c;也就是说当DPL要求KERNAL权限&#xff0c;而CPL和RPL只要有一个是用户权限就会不合法。</p>\n<p></p>\n<p>五、小程序</p>\n<p>特权指令是指保护方式下只有当前特权级CPL=0时&#xff0c;才可执行的指令。如果CPL不等于0而执行它们&#xff0c;那么会引起通用保护异常。</p>\n<p>我们选取CLTS这条指令进行我们的小实验。</p>\n<pre>int main()<br />{<br />\tasm(&#34;CLTS&#34;);<br />\treturn 0;<br />}</pre>\n<p>我们写了一个非常简单的小程序&#xff0c;但是我们用2种不同的方法来运行它。</p>\n<pre>$./a.out</pre>\n<p>和</p>\n<pre>$sudo ./a.out</pre>\n<p>他们的结果不同&#xff0c;前者会出segment fault。</p>\n<p>我们用gdb查看它的CS寄存器&#xff0c;得知其大小为0x33&#xff0c;所以CPL=3&#xff0c;为用户态&#xff0c;无法访问CR0。</p>"}, {"folders": [], "updated": "2016-03-02T08:22:59Z", "uid": "i6ub4vwhQXd", "created": "2016-03-02T08:22:59Z", "type": "feedback", "id": "ilaksrtqzoa59v", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2012011371 徐捷&#xff0c;2012011372 赖国堃</p>\n<p></p>\n<p>- DPL&#xff08;描述符特权级&#xff09;存在于段描述符中的特权级&#xff0c;表示这个段访问的段的特权级</p>\n<p>- CPL&#xff08;当前特权级&#xff09;存在于代码段寄存器(CS)中&#xff0c;表示当前执行代码的特权级的描述标志</p>\n<p>- RPL&#xff08;请求特权级&#xff09;存在于每一个段选择子中&#xff0c;说明的是进程对段访问时想使用的请求权限&#xff0c;不同的段选择子可能有不同的RPL</p>\n<p></p>\n<p>访问条件&#xff1a;</p>\n<p>- DPL &gt;= max(CPL,RPL)</p>"}, {"folders": [], "updated": "2016-03-02T08:24:02Z", "uid": "i0yuo4o74sx70w", "created": "2016-03-02T08:24:02Z", "type": "feedback", "id": "ilaku4tlc2i2wl", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011389 郑兆衡  2013011416 张浩天</p>\n<p>当前特权级CPL是指当前进程的权限级别</p>\n<p></p>\n<p>描述符特权级DPL是指某个段的特权级别&#xff0c;一般存储在描述这个段的段描述符里面</p>\n<p>段描述符的高32位中14-13位就是DPL</p>\n<p></p>\n<p>请求特权级RPL是指进程对某个段的访问权限级别&#xff0c;存在段选择子的低2位</p>\n<p>段选择子的结构&#xff1a;</p>\n<p>一共16位&#xff0c;高13位是GDT的索引&#xff0c;再有1位TI&#xff0c;最后是2位RPL</p>\n<p></p>\n<p>访问的条件是 max(CPL, RPL) &lt;= DPL</p>\n<p></p>\n<p>一些根据Intel手册补充的内容&#xff1a;</p>\n<p></p>\n<p>RPL存在于一般意义下的段寄存器中&#xff0c; 或者说Segment Selector&#xff0c;也就是CS, SS, DS, ES, FS, GS中都包括了RPL。具体结构如下</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0yuo4o74sx70w/ilalxhpd7sao/1.png\" /></p>\n<p>此外&#xff0c;每个段寄存器还有其隐藏的部分&#xff0c;当selector确定时&#xff0c;CPU会把对应的段描述符的部分重要内容加载到段寄存器的Hidden Part&#xff0c;其中就包括了段描述符中的DPL。因此&#xff0c;DPL也存在于CS, SS, DS, ES, FS, GS中&#xff0c;只不过是存在这些寄存器的隐藏部分。如图所示&#xff0c;</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0yuo4o74sx70w/ilalxzrz6r6y/2.png\" /></p>\n<p>其中&#xff0c;Access Information中就包括了DPL。</p>\n<p> </p>\n<p>而为了访问数据段&#xff0c;CPU需要将Segment Selector加载入段寄存器&#xff08;DS, ES, FS ,GS, SS&#xff09;。在此之前&#xff0c;CPU要进行优先级检查&#xff0c;此时的CPL存储在CS或SS中的低2位&#xff0c;标识了当前代码段的优先级&#xff0c;结构如图,</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0yuo4o74sx70w/ilalysue999y/3.png\" /></p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:25:29Z", "uid": "i6w84pnmjCQ", "created": "2016-03-02T08:25:29Z", "type": "feedback", "id": "ilakvzjspog4km", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>王智默 2012011355 高越 2012011379</p>\n<p>1.</p>\n<p>DPL是说当前段被访问时访问者所需要的特权级。</p>\n<p>CPL是说当前程序的特权级。</p>\n<p>RPL是说当前程序对段访问发出请求时指定的特权级。</p>\n<p>2.</p>\n<p>DPL存在段描述符中&#xff0c;CPL存在CS中&#xff0c;RPL存在段选择子中。</p>\n<p>3.</p>\n<p>DPL &gt;= max(CPL, RPL)</p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:25:52Z", "uid": "i242q8ug7vw40x", "created": "2016-03-02T08:25:52Z", "type": "feedback", "id": "ilakwhlpdu96mq", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "CPL是当前进程的权限级别, 它的值存在CS的低两位\n\nDPL存在于段描述符中, 用于规定这个段的访问权限(具体存在于一个段选择子的第31 &#43; 13/14位)\n\nRPL是说明进程的请求权限, 存在于段选择子中的低两位\n\n如果要访问成功, 需要DPL&gt;=max{CPL, RPL}\n\n抱歉我应该答另外一题..... 余数算错...."}, {"folders": [], "updated": "2016-03-02T08:27:35Z", "uid": "i0f7v0qgfm61s6", "created": "2016-03-02T08:27:35Z", "type": "feedback", "id": "ilakyop4f5f141", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>白家松 2013011339 徐涵 2013011355</p>\n<p>CPL: 当前进程的权限级别, 指当前正在执行的代码所在段的权限级别</p>\n<p>DPL: 存储在段描述符中&#xff0c;规定访问该段的权限级别&#xff0c;每个段的DPL固定</p>\n<p>RPL: 进程对段访问的请求权限&#xff0c;每个段选择子有自己的RPL, 一个程序可以有多个段选择子, 即有多个RPL</p>\n<p></p>\n<p>CPL: 存在于cs寄存器中(低两位)</p>\n<p>DPL: 存在于段描述符</p>\n<p>RPL: 存在于段选择子(低两位)</p>\n<p></p>\n<p>进程在访问一个段时进行的进程特权级检查&#xff0c;一般要求DPL &gt;= max {CPL, RPL}</p>"}, {"folders": [], "updated": "2016-03-02T08:28:35Z", "uid": "i6vjwdpfniF", "created": "2016-03-02T08:28:35Z", "type": "feedback", "id": "ilakzyyb4gs1gj", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p><br />2012011383 赵涵</p>\n<p>CPL是当前进程权限级别&#xff0c;存在cs寄存器低两位&#xff1b;<br />RPL是进程对段访问请求权限&#xff0c;存在段选择子低两位&#xff1b;<br />DPL规定访问该段的权限级别&#xff0c;存在段描述符中。</p>\n<p>当 DPL &gt;= max(CPL, RPL) 时&#xff0c;允许访问。</p>"}, {"folders": [], "updated": "2016-03-02T08:29:07Z", "uid": "i0evrfcnckf5dt", "created": "2016-03-02T08:29:07Z", "type": "feedback", "id": "ilal0o89xkx5ns", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011307</p>\n<p>注&#xff1a;以下内容参见intel手册page 2110-2111<br />1.描述符特权级DPL(Descriptor Privilege Level)存储在段描述符中&#xff0c;规定访问该段的权限级别。每一个段的DPL是固定的&#xff0c;在有进程访问该段时&#xff0c;进行进程特权级检查&#xff0c;要求DPL &gt;= max{CPL, RPL}<br />2.当前特权级CPL(Current Privilege Level)存在于CS和SS段寄存器的bits 0 和 bits 1&#xff0c;是当前正在执行的代码所在的段的特权级。<br />3.请求特权级RPL(Request Privilege Level)是对于段选择子而言的&#xff0c;存在于段选择子的bits 0 和 bits 1,每个段选择子有自己的RPL。它用于说明进程对段访问的所请求的权限。同时RPL对于每个段来说不是固定的&#xff0c;多次访问同一段是的RPL可以不同。</p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:29:37Z", "uid": "i6vir34gLfK", "created": "2016-03-02T08:29:37Z", "type": "feedback", "id": "ilal1arkxv767y", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2012011321</p>\n<p>1、CPL&#xff1a;当前特权级保存在CS段寄存器&#xff08;选择子&#xff09;的最低两位&#xff0c;CPL就是当前活动代码段的特权级&#xff0c;并且它定义了当前所执行程序的特权级别&#xff09;</p>\n<p>2、DPL&#xff1a;描述符特权存储在段描述符中的权限位&#xff0c;用于描述对应段所属的特权等级&#xff0c;也就是段本身真正的特权级。</p>\n<p>3、RPL&#xff1a;请求特权级RPL保存在选择子的最低两位。RPL说明的是进程对段访问的请求权限&#xff0c;意思是当前进程想要的请求权限。访问时的特权检查是判断&#xff1a;max(RPL,CPL)&lt;=DPL是否成立。</p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:30:22Z", "uid": "i21zpwab2z775p", "created": "2016-03-02T08:30:22Z", "type": "feedback", "id": "ilal29qcc7z2en", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>马志明 2013011395 王启圣2013011409</p>\n<p>含义&#xff1a;CPL是当前进程的权限级别&#xff08;current privilege level&#xff09;&#xff0c;也就是当前正在执行的代码所在的段的特权级&#xff1b;RPL是进程访问段的时候的请求权限&#xff08;request privilege level&#xff09;&#xff1b;DPL是规定访问该段的权限级别&#xff08;descriptor privilege level&#xff09;&#xff0c;也就是某进程要访问该段的最低权限级别。<br />所处位置&#xff1a;CPL存在于cs寄存器的低两位&#xff1b;DPL存在于段描述符&#xff08;segment decriptor&#xff09;的权限位中&#xff1b;RPL存在于段选择子&#xff08;segment selector&#xff09;中。<br />访问条件&#xff1a;某进程可以访问某段的的条件是&#xff0c;DPL &gt;= max{CPL, RPL}。</p>"}, {"folders": [], "updated": "2016-03-02T08:30:43Z", "uid": "ie7xy71bn7b1s2", "created": "2016-03-02T08:30:43Z", "type": "feedback", "id": "ilal2q8kkls7k8", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011509郭嘉丞</p>\n<p>CS的最后两位写有CPL为当前特权级CPL</p>\n<p>DS、ES、SS、GS的最后两位为DPL&#xff0c;即需要什么特权级才能访问</p>\n<p>而DPL不在寄存器而是从gdt/ldt等加载时使用的index的最后两位。</p>\n<p>一个简单的例子可以用lab1_result构造&#xff1a;</p>\n<p>将kern/trap/trap.c 181行中</p>\n<p>将载入的USER_DS改为KERNEL_DS</p>\n<p>会产生一个kernel panic。</p>\n<p>原因是此时DS和SS后的DPL为0&#xff0c;即只有kernel才能访问</p>\n<p>而我们切换后的cs的CPL为3即在用户态。</p>\n<p>于是触发了General protection</p>\n<p>另外x86还有IOPL&#xff0c;专门用于IO的访问权限控制&#xff0c;在EFLAGS中的12 13位。</p>\n<p>同样代码中在187行设置了IOPL为3&#xff0c;如果删除这一行&#xff0c;会使得在用户态的cprintf发生错喔</p>"}, {"folders": [], "updated": "2016-03-02T08:33:17Z", "uid": "i6ugy67km5b", "created": "2016-03-02T08:33:17Z", "type": "feedback", "id": "ilal60tajew31u", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>DPL-描述符特权级&#xff0c;存储在段描述符中的特权位段&#xff0c;表示当前段的特权级<br />CPL-当前特权等级&#xff0c;存储在代码段寄存器(CS)的最低两位&#xff0c;表示当前执行代码的特权级<br />RPL-请求特权等级&#xff0c;存储在每一个段选择子的最低两位&#xff0c;表示进程对段的访问权限<br />访问条件&#xff1a;DPL &gt;= max(CPL,RPL)</p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:37:49Z", "uid": "i6ub5at2geM", "created": "2016-03-02T08:37:49Z", "type": "feedback", "id": "ilalbv2cwkh6qg", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2012080059 </p>\n<div>CPL是当前进程的权限级别(Current Privilege Level)&#xff0c;是当前正在执行的代码所在的段的特权级&#xff0c;存在于cs寄存器的低两位&#xff1b;</div>\n<div>RPL说明的是进程对段访问的请求权限(Request Privilege Level)&#xff0c;是对于<strong>段选择子</strong>而言的&#xff0c;每个段选择子有自己的RPL&#xff0c;它说明的是进程对段访问的请求权限&#xff1b;</div>\n<div>DPL存储在段描述符中&#xff0c;规定访问该段的权限级别(Descriptor Privilege Level)&#xff0c;<strong>每个段的DPL固定</strong>。当进程访问一个段时&#xff0c;需要进程特权级检查&#xff0c;一般要求DPL &gt;= max {CPL,RPL}&#xff1b;</div>"}, {"folders": [], "updated": "2016-03-02T08:46:56Z", "uid": "i1569mw0xp954u", "created": "2016-03-02T08:46:56Z", "type": "feedback", "id": "ilalnki4s3p2iw", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>1、DPL存储在段描述符中&#xff0c;规定访问该段的权限级别(Descriptor Privilege Level)&#xff0c;每个段的DPL固定。</p>\n<p>      CPL是当前进程的权限级别(Current Privilege Level)&#xff0c;是当前正在执行的代码所在的段的特权级。</p>\n<p>      RPL说明的是进程对段访问的请求权限(Request Privilege Level)&#xff0c;是对于段选择子而言的&#xff0c;每个段选择子有自己的                 RPL&#xff0c;它说明的是进程对段访问的请求权限。</p>\n<p>2、CPL存在于CS寄存器的低两位。</p>\n<p>      DPL存在于段描述符的特权级。</p>\n<p>      RPL存在于每一个段选择子中&#xff0c;是段选择子里面的bit 0和bit 1位组合所得的值。</p>\n<p>3、一般要求DPL &gt;= max {CPL, RPL}</p>"}, {"folders": [], "updated": "2016-03-02T08:54:29Z", "uid": "i1jd60b7orl10p", "created": "2016-03-02T08:54:29Z", "type": "feedback", "id": "ilalxa9pehl430", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013080071李云龙2013080074温家尊<br />DPL: 规定访问该段的权限级别&#xff0c;每个段的DPL固定&#xff0c;存储在段描述符中&#xff0c;访问条件是DPL &gt;= max {CPL, RPL}<br />CPL: 表示当前进程的权限级别&#xff0c;是当前正在执行的代码所在的段的特权级&#xff0c;存在于cs寄存器的低两位<br />RPL: 表示进程对段访问的请求权限&#xff0c;每个段选择子有自己的RPL&#xff0c;指进程对段访问的请求权限。RPL不固定&#xff0c;两次访问同一段时的RPL可以不同。</p>"}, {"folders": [], "updated": "2016-03-02T08:54:36Z", "uid": "i17iy2ly5py3ad", "created": "2016-03-02T08:54:36Z", "type": "feedback", "id": "ilalxfcc1rc4gx", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>DPL&#xff1a;存储在段描述符中&#xff0c;是段规定的访问该段的权限级别&#xff1b;</p>\n<p>CPL&#xff1a;存储在cs寄存器的低两位&#xff0c;是当前正在执行的代码所在的段的特权级&#xff1b;</p>\n<p>RPL&#xff1a;存储在段选择子的低两位&#xff0c;是进程对段的访问权限&#xff1b;</p>\n<p>访问时检查特权级&#xff0c;当DPL &gt;= max {CPL, RPL}时允许访问&#xff1b;</p>"}, {"folders": [], "updated": "2016-03-02T09:01:06Z", "uid": "i0ccqbaxwdz75c", "created": "2016-03-02T09:01:06Z", "type": "feedback", "id": "ilam5snbaawnh", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>CPL&#xff1a;Current Privilege Level&#xff0c;当前正在执行的代码所在的段的特权级&#xff0c;存在于cs寄存器的低两位</p>\n<p>DPL&#xff1a;Descriptor Privilege Level&#xff0c;表示这个段访问的段的特权级&#xff0c;存储在段描述符中的权限位</p>\n<p>RPL&#xff1a;Request Privilege Level&#xff0c;进程对段访问的请求权限&#xff0c;存在段选择子的后两位</p>\n<p>访问条件要求段的符特权级DPL要高于CPL和RPL</p>"}, {"folders": [], "updated": "2016-03-02T09:32:44Z", "uid": "i0d4mr9tga62ki", "created": "2016-03-02T09:32:44Z", "type": "feedback", "id": "ilanahbk1m45t5", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>学号&#xff1a;2013011303  2013012213</p>\n<p>CPL (Current Privilege Level) : 表示当前执行的任务的特权等级&#xff0c;它存储在CS寄存器的低两位上</p>\n<p>DPL (Descriptor Privilege Level) : 表示段的特权等级&#xff0c;它存储在段描述符的特权位上</p>\n<p>RPL (Rquest Privilege Level) : 表示进程对该段的请求权限&#xff0c;它存储在段选择子的低二位上</p>\n<p>访问条件是DPL大于等于CPL和RPL</p>"}, {"folders": [], "updated": "2016-03-02T10:13:22Z", "uid": "ic226rac4j5jw", "created": "2016-03-02T10:13:22Z", "type": "feedback", "id": "ilaoqqccf9mvt", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2012012139</p>\n<p>1.</p>\n<p>CPL是当前进程的权限级别(Current Privilege Level)&#xff0c;是当前正在执行的代码所在的段的特权级</p>\n<p>RPL说明的是进程对段访问的请求权限(Request Privilege Level)&#xff0c;是对于段选择子而言的&#xff0c;每个段选择子有自己的RPL&#xff0c;它说明的是进程对段访问的请求</p>\n<p>DPL存储在段描述符中&#xff0c;规定访问该段的权限级别(Descriptor Privilege Level)&#xff0c;每个段的DPL固定</p>\n<p> </p>\n<p>2. 在哪些寄存器中这些字段&#xff1f;</p>\n<p>CPL: CS低两位</p>\n<p>RPL存储在段选择子中。</p>\n<p>DPL存储在段描述符中。</p>\n<p></p>\n<p>RPL: DS, ES, FS, GS 数据段</p>\n<p>CPL: CS, SS 代码段</p>\n<p> </p>\n<p>3. 对应的访问条件是什么&#xff1f;</p>\n<p>一般要求DPL &gt;= max {CPL, RPL}&#xff0c;即本身所具备的权限或者请求权限中的最低者&#xff0c;也必须高于所规定的权限。</p>"}, {"folders": [], "updated": "2016-03-02T10:49:36Z", "uid": "i0cb1385ni65l", "created": "2016-03-02T10:49:36Z", "type": "feedback", "id": "ilaq1c69y6v3bm", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>曹科垒2013011345<br />黎文杰2013011353<br /><br />描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么&#xff1f;<br />在哪些寄存器中这些字段&#xff1f;<br />对应的访问条件是什么&#xff1f;<br /><br />当前特权级CPL是当前进程运行代码所在的段的特权级&#xff0c;视为进程的优先级&#xff0c;请求特权级RPL是进程对段访问的特权级&#xff0c;符特权级DPL是该段被访问的特权级。<br />CPL存储于cs寄存器的低2位&#xff0c;RPL存储于段选择子的低2位&#xff0c;DPL存储于段描述符里。<br />当进程访问段时&#xff0c;要求段的符特权级DPL要高于CPL和RPL。</p>"}, {"folders": [], "updated": "2016-03-02T10:51:08Z", "uid": "i0b7d04pl3y6c0", "created": "2016-03-02T10:51:08Z", "type": "feedback", "id": "ilaq3ajwok84c4", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>1. </p>\n<ul><li>Descriptor privilege level (DPL) 指定一个段(segment)或入口(gate)的特权级别&#xff0c;存在于段的DPL域或入口描述符(gate descriptor)中。在下图段描述符(segment descriptor)中我们可以看到DPL域。入口描述符的作用与段描述符相仿&#xff0c;当我们要call/jmp到某一代码段(code segment)时要进行当前进程特权等级与该代码段入口描述符的DPL进行比较。</li><li><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0b7d04pl3y6c0/ilaq2a2ud6w3/屏幕快照_20160302_下午6.28.48.png\" /></li><li></li><li></li><li>Requested privilege level (RPL) 存在与段寄存器(segment register)中&#xff0c;段寄存器共有6个&#xff0c;分别命名为CS DS SS ES FS GS&#xff0c;每个段寄存器保存着一个16bits的段选择子(segment selector)&#xff0c;段选择子的最低两位保存着RPL值&#xff0c;如下图。当需要访问代码段(code segment&#xff0c;对应段寄存器CS)&#xff0c;数据段(data segment&#xff0c;对应段寄存器DS ES FS GS)&#xff0c;栈段(stack segment&#xff0c;对应段寄存器SS)时&#xff0c;只有当对应的RPL值小于等于该部分的DPL值时&#xff0c;进程才被允许访问。</li><li><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0b7d04pl3y6c0/ilaq2za2uxz0/屏幕快照_20160302_下午6.36.32.png\" /></li></ul>\n<p></p>\n<p></p>\n<ul><li>Current privilege level (CPL) 是RPL的一种&#xff0c;一般指存在CS段寄存器中的RPL值&#xff0c;根据文档&#xff0c;也指SS段寄存器中的RPL值。当程序成功调用了某一代码段后&#xff08;满足入口描述符DPL值&#xff09;&#xff0c;当前进程的CPL值会被调整到与该段代码的CPL值相同。</li></ul>\n<p></p>\n<p></p>\n<p>进行对代码段&#xff0c;数据段&#xff0c;栈段的访问和调用时&#xff0c;要求当前进程的RPL(或CPL)值大于目标段段DPL值。</p>\n<p></p>\n<p></p>\n<p>2.思路如下&#xff1a;</p>\n<p>首先&#xff0c;关于进程的信息存储在结构体proc_struct中&#xff08;详见文件/kern/trap.c&#xff09;</p>\n<p>这个结构体有一个变量为struct trapframe *tf; 结构体trapframe的代码如下&#xff1a;</p>\n<pre>struct trapframe {\n    struct pushregs tf_regs;\n    uint16_t tf_gs;\n    uint16_t tf_padding0;\n    uint16_t tf_fs;\n    uint16_t tf_padding1;\n    uint16_t tf_es;\n    uint16_t tf_padding2;\n    uint16_t tf_ds;\n    uint16_t tf_padding3;\n    uint32_t tf_trapno;\n    /* below here defined by x86 hardware */\n    uint32_t tf_err;\n    uintptr_t tf_eip;\n    uint16_t tf_cs;\n    uint16_t tf_padding4;\n    uint32_t tf_eflags;\n    /* below here only when crossing rings, such as from user to kernel */\n    uintptr_t tf_esp;\n    uint16_t tf_ss;\n    uint16_t tf_padding5;\n} __attribute__((packed)); // /kern/trap.h</pre>\n<p>这里的uint16_t tf_cs;存储着该进程的CPL信息&#xff0c;其名称tf_cs体现了它与CS段寄存器有关。</p>\n<p></p>\n<p>实验中&#xff0c;我们改变了kernel_thread的CPL&#xff0c;代码如下&#xff1a;</p>\n<pre>int\nkernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {\n    struct trapframe tf;\n    memset(&amp;tf, 0, sizeof(struct trapframe));\n    tf.tf_cs = USER_CS; // 从KERNEL_CS改为USER_CS&#xff0c;从内核特权级0改为用户特权级3\n    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;\n    tf.tf_regs.reg_ebx = (uint32_t)fn;\n    tf.tf_regs.reg_edx = (uint32_t)arg;\n    tf.tf_eip = (uint32_t)kernel_thread_entry;\n    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);\n} // from /kern/process/proc.c</pre>\n<p></p>\n<p>改动后make qemu执行&#xff0c;会发生错误如下&#xff1a;</p>\n<pre>unhandled trap.\nkernel panic at kern/process/proc.c:526:\n    initproc exit.</pre>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T11:01:17Z", "uid": "i28t9sj8bas79c", "created": "2016-03-02T11:01:17Z", "type": "feedback", "id": "ilaqgcok7mw1na", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>徐圣韬 2012011287</p>\n<p></p>\n<p>CPL&#xff1a;当前活动代码段的特权级&#xff0c;定义了当前所执行程序的特权级别&#xff0c;保存在CS段寄存器的最低两位</p>\n<p>DPL&#xff1a;描述符特权&#xff0c;用于描述对应段所属的特权等级&#xff0c;也就是段本身真正的特权级&#xff0c;存储在段描述符中的权限位</p>\n<p>RPL&#xff1a;请求特权级&#xff0c;说明的是进程对段访问的请求权限&#xff0c;意思是当前进程想要的请求权限&#xff0c;保存在选择子的最低两位</p>\n<p></p>\n<p>访问条件是判断max(RPL,CPL)&lt;=DPL是否成立&#xff0c;RPL可以看成是每次访问时的临时限制&#xff0c;RPL=0时限制最小RPL=3时最大。</p>"}, {"folders": [], "updated": "2016-03-02T11:14:15Z", "uid": "i75nho1hE8g", "created": "2016-03-02T11:14:15Z", "type": "feedback", "id": "ilaqx0wtac03ni", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>韩刘成 2012080057</p>\n<p>1.CPL是当前进程的权限级别(Current Privilege Level)&#xff0c;是当前正在执行的代码所在的段的特权级</p>\n<p>RPL说明的是进程对段访问的请求权限(Request Privilege Level)&#xff0c;是对于段选择子而言的&#xff0c;每个段选择子有自己的RPL&#xff0c;它说明的是进程对段访问的请求</p>\n<p>DPL存储在段描述符中&#xff0c;规定访问该段的权限级别(Descriptor Privilege Level)&#xff0c;每个段的DPL固定</p>\n<p> </p>\n<p>2. 在哪些寄存器中这些字段&#xff1f;</p>\n<p>CPL: CS低两位</p>\n<p> </p>\n<p>3. 对应的访问条件是什么&#xff1f;</p>\n<p>一般要求DPL &gt;= max {CPL, RPL}&#xff0c;即本身所具备的权限或者请求权限中的最低者&#xff0c;也必须高于所规定的权限。</p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T11:38:36Z", "uid": "ikx8y1dzPrM", "created": "2016-03-02T11:38:36Z", "type": "feedback", "id": "ilarscivjbe2fb", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>krajna 2014010527</p>\n<p>CPL(Current Privilege Level)是当前执行程序或任务的特权级&#xff0c;存储在CS和SS第0,1位</p>\n<p>DPL(Descriptor Privilege Level)表示段或者门的特权级&#xff0c;存储在段描述符或者门描述符的DPL字段中</p>\n<p>RPL(Request Privilege Level)是段选择子的低2位的值。这两个位是可以修改的。</p>\n<p></p>\n<p>假如用户进程ring3通过系统调用进入操作系统代码段ring0,这时CPL=0可以访问kernel的代码&#xff0c;这时操作系统可以在</p>\n<p>访问kernel代码段前修改段选择子的RPL=调用者的特权级&#xff0c;可以防止ring3程序访问内核数据。</p>\n<p>只有当满足目标代码段DPL&gt;=max{CPL,RPL}时才能发生跨特权级的访问。</p>"}, {"folders": [], "updated": "2016-03-02T11:43:34Z", "uid": "i0i7rzz9iau2gd", "created": "2016-03-02T11:43:34Z", "type": "feedback", "id": "ilaryqarywyk2", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013010617 王凯</p>\n<p>2012012231 黄科</p>\n<p>1、2&#xff1a;</p>\n<p>CPL&#xff1a;当前活动代码段的特权级&#xff0c;定义了当前所执行程序的特权级别&#xff0c;保存在CS段寄存器的最低两位</p>\n<p>DPL&#xff1a;描述符特权&#xff0c;用于描述对应段所属的特权等级&#xff0c;也就是段本身真正的特权级&#xff0c;存储在段描述符中的权限位</p>\n<p>RPL&#xff1a;请求特权级&#xff0c;说明的是进程对段访问的请求权限&#xff0c;意思是当前进程想要的请求权限&#xff0c;保存在选择子的最低两位</p>\n<p>3&#xff1a;</p>\n<p>一般要求DPL &gt;= max {CPL, RPL}&#xff0c;即本身所具备的权限或者请求权限中的最低者&#xff0c;也必须高于所规定的权限。</p>"}, {"folders": [], "updated": "2016-03-02T11:46:09Z", "uid": "i0ccfx63sir1e", "created": "2016-03-02T11:46:09Z", "type": "feedback", "id": "ilas228aubg1no", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p></p>\n<ol><li>\n<pre>关于特权级的官方参考资料</pre>\n<ul><li>在PDF的Volume 3, Chapter 5 Protection&#xff0c;5.5 ~ 5.9 都涉及 Privilege Levels</li></ul>\n</li><li>\n<pre>描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么&#xff1f;在哪些寄存器中特权级字段&#xff1f;</pre>\n<ul><li>CPL (Current Privilege Level)&#xff0c;当前进程的权限级别&#xff0c;存在于cs、ss寄存器</li><li>RPL (Request Privilege Level)&#xff0c;进程对段访问的请求权限&#xff0c;存在于段选择子(DS,ES,FS,GS)</li><li>DPL (Descriptor Privilege Level)&#xff0c;规定访问该段的权限级别&#xff0c;存在于segment or gate描述符</li><li>参考资料如下&#xff0c;均在Volume 3,  5.5 Privilege Levels ~</li><li><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/ilarxc7ogv8r/屏幕快照_20160302_下午7.41.46.png\" width=\"661\" height=\"123\" /></li><li><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/ilarzfx61rt3/屏幕快照_20160302_下午7.41.55.png\" width=\"661\" height=\"79\" /></li><li><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/ilas11gtnx2y/屏幕快照_20160302_下午7.42.01.png\" width=\"653\" height=\"121\" /></li><li>特权级具体位置如下(Volume 3, Chapter 3)</li><li><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/ilasjau7b33o/屏幕快照_20160302_下午7.58.37.png\" width=\"431\" height=\"129\" /></li><li><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/ilask9vwsxss/屏幕快照_20160302_下午7.58.56.png\" width=\"445\" height=\"273\" /></li></ul>\n</li><li>\n<pre>对应的访问条件是什么&#xff1f;</pre>\n<ul><li>max(RPL,CPL) &lt;= DPL </li><li><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/ilas88lvvwzw/屏幕快照_20160302_下午7.48.05.png\" width=\"500\" height=\"231\" /></li><li>那篇博客写得很形象了&#xff0c;实在要看官方资料&#xff0c;可以参考PDF的Volume 3 Chapter 5.6 ~ 5.8</li><li><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i0ccfx63sir1e/ilas7irwztdr/屏幕快照_20160302_下午7.47.48.png\" width=\"614\" height=\"59\" /></li></ul>\n</li></ol>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T11:48:08Z", "uid": "iem550jbpyn515", "created": "2016-03-02T11:48:08Z", "type": "feedback", "id": "ilas4lajpqg16i", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "章彦恺 2012011284\n\n1. 描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么\n\nCPL是当前进程的权限级别(Current Privilege Level)&#xff0c;是当前正在执行的代码所在的段的特权级\nRPL说明的是进程对段访问的请求权限(Request Privilege Level)&#xff0c;它说明的是进程对段访问的请求权限\nDPL规定访问该段的权限级别(Descriptor Privilege Level)&#xff0c;每个段的DPL固定\n\n2. 在哪些寄存器中这些字段\n\nCPL存储在cs寄存器的低两位\nRPL在段选择子中\nDPL在段描述符中\n\n3. 访问条件\n\nDPL &gt;= max{CPL, RPL}"}], "subject": "<p></p><div>题目&#xff1a;</div>\n<div>1. 4.1中的第7小题&#xff1a;描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么&#xff1f;在哪些寄存器中这些字段&#xff1f;对应的访问条件是什么&#xff1f; (challenge)写出一些简单的小程序&#xff08;c or asm&#xff09;来体现这些特权级的区别和联系。</div>\n<div></div>\n<div>回答结果写在此贴中对应题目后面。</div>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:15:49Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-03-02T08:15:49Z", "type": "followup", "no_answer": 1, "id": "ilakjk2ggkv3cz", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2016-03-02T08:16:31Z", "uid": "i0eqqq6jvng408", "created": "2016-03-02T08:16:31Z", "type": "feedback", "id": "ilakkgk9a6f3n8", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011376龚拓宇 2013011379姚炫容</p>\n<p>       如果一个中断产生时任务正在用户代码中执行&#xff0c;那么该中断会引起CPU特权级从3到0的变化&#xff0c;此时CPU就会运行用户态堆栈到内核态堆栈的切换操作。CPU会从当前任务的任务状态段TSS中取得新堆栈的段选择符和偏移量。因为中断服务程序在内核中&#xff0c;属于0级特权级代码&#xff0c;所以48位的内核态堆栈指针会从TSS的ss0和esp0字段中获得。在定位了新堆栈&#xff08;内核态堆栈&#xff09;之后&#xff0c;CPU就会首先把原用户态堆栈指针ss和esp压入内核态堆栈&#xff0c;随后把标志积存器eflags的内容和返回位置cs&#xff0c;eip压入内核态堆栈。</p>\n<p>  内核的系统调用是一个软件中断&#xff0c;因此任务调用系统调用时就会进入内核并执行内核中的中断服务代码。此时内核代码就会使用该任务的内核态堆栈进行操作。同样&#xff0c;当进入内核程序时&#xff0c;由于特权级别发生了改变&#xff0c;用户态堆栈的堆栈段和堆栈指针以及eflags会被保存在任务的内核态堆栈中。而在执行iret退出内核程序返回到用户程序时&#xff0c;将恢复用户态的堆栈和eflags。<br />  如果一个任务正在内核态中运行&#xff0c;那么若CPU响应中断就不再需要进行堆栈切换操作。因为此时该任务运行的内核代码已经在使用内核态堆栈&#xff0c;并且不涉及到优先级别的变化&#xff0c;所以CPU仅把eflags和中断返回指针cs&#xff0c;eip压入当前内核态堆栈&#xff0c;然后执行中断服务过程。</p>"}, {"folders": [], "updated": "2016-03-02T08:16:33Z", "uid": "ibz6vywnw6g7nl", "created": "2016-03-02T08:16:33Z", "type": "feedback", "id": "ilakkigehy42f2", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>特权级切换的中断触发时&#xff0c;需要在trap的参数trapframe里暂存各个段寄存器&#xff08;ss以外&#xff09;和eip&#xff0c;这时不需要堆栈的变化。</p>\n<p>只有在用户态和内存态的转换时&#xff0c;需要用户堆栈和内核堆栈的转换&#xff0c;此时trapframe里的esp和cs就起作用了。</p>\n<p>在每个中断前后&#xff0c;进行LAB1的栈显示。</p>\n<p></p>\n<pre><br />void<br />trap(struct trapframe *tf) {<br />\tcprintf(&#34;trap&#34;);<br />\tprint_trapframe();<br />\tprint_stackframe();<br />    // dispatch based on what type of trap occurred<br />    trap_dispatch(tf);<br />    print_stackframe();<br />}</pre>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:20:26Z", "uid": "i0nuu5yhgno5tv", "created": "2016-03-02T08:20:26Z", "type": "feedback", "id": "ilakpi0oamj1id", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>"}, {"folders": [], "updated": "2016-03-02T08:22:21Z", "uid": "i0nuu5yhgno5tv", "created": "2016-03-02T08:22:21Z", "type": "feedback", "id": "ilakryc44k42m8", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011402 钱迪晨&#xff0c;2013011413 高思达</p>\n<p>challenge:</p>\n<pre>通过ucore的challenge的代码&#xff0c;可以进行用户态和内核态的切换。<br />实验的代码为&#xff1a;<br />\t进行切换。<br />\t死循环。&#xff08;这个时候时钟中断还在继续&#xff0c;如果100下了会有输出&#xff09;<br />正常情况的输出。<br />0: &#64;ring 0\n0:  cs = 8\n0:  ds = 10\n0:  es = 10\n0:  ss = 10\n&#43;&#43;&#43; switch to  user  mode &#43;&#43;&#43;\n1: &#64;ring 3\n1:  cs = 1b\n1:  ds = 23\n1:  es = 23\n1:  ss = 23\n&#43;&#43;&#43; switch to kernel mode &#43;&#43;&#43;\n2: &#64;ring 0\n2:  cs = 8\n2:  ds = 10\n2:  es = 10\n2:  ss = 10<br />//这里开始死循环&#xff0c;等待tick<br />100 ticks<br /><br />奇葩情况。<br />1. 用户态使用系统中断&#xff0c;先切换到用户态&#xff0c;使用切换回内核态的系统调用。如果对应的idt的dpl设置为KERNEL_DPL&#xff0c;这个时候输出会变成。<br />&#43;&#43; setup timer interrupts\n0: &#64;ring 0\n0:  cs = 8\n0:  ds = 10\n0:  es = 10\n0:  ss = 10\n&#43;&#43;&#43; switch to  user  mode &#43;&#43;&#43;\n1: &#64;ring 3\n1:  cs = 1b\n1:  ds = 23\n1:  es = 23\n1:  ss = 23\n&#43;&#43;&#43; switch to kernel mode &#43;&#43;&#43;<br />//这里程序飞掉了\n100 ticks<br /><br />2. 切换到用户态&#xff0c;然后死循环&#xff0c;输出为。<br />&#43;&#43; setup timer interrupts\n0: &#64;ring 0\n0:  cs = 8\n0:  ds = 10\n0:  es = 10\n0:  ss = 10\n&#43;&#43;&#43; switch to  user  mode &#43;&#43;&#43;\n1: &#64;ring 3\n1:  cs = 1b\n1:  ds = 23\n1:  es = 23\n1:  ss = 23\n100 ticks<br />可以看到这里面时钟的中断还是成功的进行了&#xff0c;时钟中断的IDT的DPL = 0。<br />虽然现在是用户态&#xff0c;但是还是成功执行了中断程序&#xff0c;所以说RPL = CPL = 0。<br /><br />总结一下&#xff1a;<br />系统调用<br />\t在用户态使用的CPL = 3&#xff0c; 中断后 RPL = CPL = 3<br />\t如果IDT的DPL不是3的话&#xff0c;跑飞<br />硬件中断<br />\t无论在用户态还是内核态&#xff0c;如果是硬件中断&#xff0c;则中断后CPL = RPL = 0</pre>\n<p></p>\n<pre>以ucore为例子\n系统调用的权限控制\n\t在idt_init中&#xff0c;可以设置中断调用的权限&#xff0c;通过这个进行权限控制\n从用户态到内核态过程\n\t硬件构造trapframe&#xff0c;切换到内核态&#xff0c;然后软件记录通用寄存器和&#xff0c;gs&#xff0c;fs&#xff0c;es&#xff0c;ds。\n\t进行处理\n\tiret的时候&#xff0c;恢复硬件esp&#xff0c;ss&#xff0c;eip&#xff0c;cs&#xff0c;操作系统辅助回复通用寄存器&#xff0c;gs&#xff0c;fs&#xff0c;es&#xff0c;ds。\n从内核态到内核态过程\n\t硬件构造trapframe&#xff0c;然后软件记录通用寄存器和&#xff0c;gs&#xff0c;fs&#xff0c;es&#xff0c;ds。\n\t进行处理\n\tiret的时候&#xff0c;恢复硬件eip&#xff0c;cs&#xff0c;操作系统辅助回复通用寄存器&#xff0c;gs&#xff0c;fs&#xff0c;es&#xff0c;ds。</pre>\n<p></p>\n<p>以ucore为例子。</p>\n<pre>我们可以看到这个数据结构&#xff0c;在trap.h里面。使用来存储中断时候的寄存器的状态的。\nstruct trapframe {\n struct pushregs tf_regs;\n uint16_t tf_gs;\n uint16_t tf_padding0;\n uint16_t tf_fs;\n uint16_t tf_padding1;\n uint16_t tf_es;\n uint16_t tf_padding2;\n uint16_t tf_ds;\n uint16_t tf_padding3;\n uint32_t tf_trapno;\n /* below here defined by x86 hardware */\n uint32_t tf_err;\n uintptr_t tf_eip;\n uint16_t tf_cs;\n uint16_t tf_padding4;\n uint32_t tf_eflags;\n /* below here only when crossing rings, such as from user to kernel */\n uintptr_t tf_esp;\n uint16_t tf_ss;\n uint16_t tf_padding5;\n} __attribute__((packed));</pre>\n<p>最下面有两个东西比较特殊&#xff0c;esp&#xff0c;ss&#xff0c;他们只会在从用户态到内核态中断的时候出现&#xff0c;而且是硬件负责记录的&#xff0c;和软件没关系。</p>\n<p></p>\n<p>由于中断只可能在内核态处理&#xff0c;所以从用户态到内核态的中断时候&#xff0c;会有最后两个东西在栈中间。</p>\n<p></p>\n<p>这两个东西的用处&#xff0c;是因为栈的切换&#xff0c;导致esp的值应该从用户态的esp到内核态的esp。 ss也是一样的原因。 而都是在内核态的话&#xff0c;大家用的是一个栈&#xff0c;所以不用记录。其他的寄存器由于切换肯定都有可能会改所以大家都一起记录。</p>\n<p></p>\n<p>相反&#xff0c;如果当前线程在内核态&#xff0c;并且中断来了&#xff0c;则不会有这两个东西&#xff0c;因为不需要修改esp。</p>\n<p></p>\n<p>在lab1里面的challenge里面&#xff0c;有这个题目的实现。一些通用寄存器在切换的时候可以直接修改&#xff0c;比如cs&#xff0c;ss&#xff0c;eflag等&#xff0c;iret的时候则根据esp返回。内核返回不需要iret。</p>\n<p></p>\n<p>在实现的过程中&#xff0c;会发现&#xff0c;最后的esp永远无法恢复需要手动恢复&#xff0c;是因为用户到内核的时候&#xff0c;切换之后到了内核态&#xff0c;最后的esp会被忽略恢复&#xff0c;相反到用户态的时候你用户态的esp你不知道&#xff0c;不好设置。</p>\n<p></p>\n<p>总结一下&#xff1a;由于有堆栈的切换&#xff0c;所以多了用户态当前的esp&#xff0c;和ss。</p>\n<p></p>\n<p>补充&#xff1a;</p>\n<p>在lab1里面有trap.c中间的idt_init的初始化过程&#xff0c;这里面&#xff0c;可以看到软件中断也是有他的DPL&#xff0c;如果用户要使用系统对用&#xff0c;在初始化的时候应该使用USER_DPL&#xff0c;而不是能是KERNEL_DPL。这是因为用户程序的CPL是3最低&#xff0c;无论RPL怎么样&#xff0c;DPL必须是USER_DPL。系统调用的CPL和RPL相等也是一个原因。</p>\n<p></p>\n<pre>SETGATE(gate, istrap, sel, off, dpl)这里面包含GATE的selector和各种属性。\n\nextern uintptr_t __vectors[];\nvoid\nidt_init(void) {\n    int index = 0;\n    for (; index &lt; 256; index &#43;&#43;) {\n        if (index &lt; IRQ_OFFSET) { // trap {\n            SETGATE(idt[index], 1, GD_KTEXT, __vectors[index], DPL_KERNEL);\n        } else {\n            SETGATE(idt[index], 0, GD_KTEXT, __vectors[index], DPL_KERNEL);\n        }\n    }\n    SETGATE(idt[T_SWITCH_TOU], 1, GD_KTEXT, __vectors[T_SWITCH_TOU], DPL_KERNEL);\n    SETGATE(idt[T_SWITCH_TOK], 1, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);\n    lidt(&amp;idt_pd);\n}</pre>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:24:23Z", "uid": "i0nan8i4g0o3s3", "created": "2016-03-02T08:24:23Z", "type": "feedback", "id": "ilakukg13o45s4", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>谭思楠 2013011720%2==2%2</p>\n<p>廖亦阳 2013011336</p>\n<p>从用户态&#xff08;ring3&#xff09;和特权态&#xff08;ring0&#xff09;发生中断切换是堆栈有所不同&#xff0c;主要区别是从用户态切换时&#xff0c;堆栈里的会多两个寄存器的值&#xff1a;SS和ESP寄存器。实际上当前特权级别影响着int和iret指令的行为。</p>\n<p>如果执行int指令时是在内核态&#xff0c;那么寄存器中只会保存EFLAGS、CS、EIP&#xff0c;iret返回时直接通过ESP改变一个常量来恢复原来的栈帧。否则的话iret会根据当时保存的ESP寄存器进行恢复。</p>\n<p>Lab1的challenge的主要难点就是在于这个区别。从内核态切换到用户态时&#xff0c;执行int指令明明是在内核态&#xff0c;因此系统不会自动保存ESP的值&#xff0c;需要手动编写汇编保存&#xff0c;否则返回的时候iret就可能用奇怪的数据作为新的ESP了。</p>\n<p>反过来说&#xff0c;从用户态切换回内核态后&#xff0c;iret并不会根据后面的ESP恢复栈帧&#xff0c;因此必须手动恢复&#xff0c;否则程序就会执行不正常。</p>\n<p>在uCore的内核代码中&#xff0c;trapframe有部分字段是和系统的iret/int的行为有关的&#xff0c;如下&#xff1a;</p>\n<pre>    uint32_t tf_err;\n    uintptr_t tf_eip;\n    uint16_t tf_cs;\n    uint16_t tf_padding4;\n    uint32_t tf_eflags;\n    /* below here only when crossing rings, such as from user to kernel */\n    uintptr_t tf_esp;\n    uint16_t tf_ss;\n    uint16_t tf_padding5;</pre>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:25:20Z", "uid": "ierwkwbinsj2t8", "created": "2016-03-02T08:25:20Z", "type": "feedback", "id": "ilakvshbveu4s", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2014011434 == 2 (mod2)</p>\n<p></p>\n<p>如果要执行的中断处理程序在数值上更低的特权级别&#xff0c;就要进行栈切换。新的段选择子和栈指针被读取到后&#xff0c;处理器在新的栈上放入被中断的进程的栈选择子和栈指针&#xff1b;并且&#xff0c;目前的EFLAGS, CS, EIP寄存器的值会被保存到新的栈上。</p>\n<p></p>\n<p>如果要执行的中断处理程序在同样的特权级别&#xff0c;则处理器仅把EFLAGS, CS, EIP寄存器保存在当前的栈上。</p>\n<p></p>\n<p>Reference: Intel® 64 and IA-32 Architectures Software Developer’s Manual Vol.3 Selection 6.12.1</p>"}, {"folders": [], "updated": "2016-03-02T08:30:21Z", "uid": "i0em4o8wvj34lb", "created": "2016-03-02T08:30:21Z", "type": "feedback", "id": "ilal29ax47z6jw", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>特权态中断时&#xff0c;不需发生栈切换。需保存Error Code、EIP、CS、EFLAGS</p>\n<p>内核态中断时&#xff0c;需进行栈切换。并在切换到的栈中保存Error Code、EIP、CS、EFLAGS、ESP、SS。ESP、SS用于进行前一个栈的恢复。</p>"}, {"folders": [], "updated": "2016-03-02T08:33:12Z", "uid": "ikvcvq38pa7l6", "created": "2016-03-02T08:33:12Z", "type": "feedback", "id": "ilal5wx5f7w3g6", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p><span style=\"color:#333333\">2013011296贺子松 2013011320陆禹</span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\">从用户态切换到内核态中断时&#xff0c;堆栈里的会多两个寄存器的值&#xff1a;SS和ESP寄存器</span></span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\">而如果当前线程就在内核态&#xff0c;则不需要保存这两个寄存器。</span></span></p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:38:06Z", "uid": "ikx8y1dzPrM", "created": "2016-03-02T08:38:06Z", "type": "feedback", "id": "ilalc7urpu06vh", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>krajna 2014010527</p>\n<p>当中断发生在ring3时&#xff0c;CPU会向对应的ring0级别的栈中压入如下数据结构。</p>\n<p><strong>参考XV6的源代码。其中632,633,634行是多出来的用户态ring3级别的栈指针和段选择子&#xff08;只有16位有用&#xff09;。</strong></p>\n<p>在ring0发生中断切换时&#xff0c;只会压栈CS,EIP,EFLAGS,ERRCODE以及其他寄存器的值。</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/ikx8y1dzPrM/ilal5mf0hof0/xv6中断.JPG\" /></p>"}, {"folders": [], "updated": "2016-03-02T08:39:31Z", "uid": "i242q8ug7vw40x", "created": "2016-03-02T08:39:31Z", "type": "feedback", "id": "ilale1iq4k25l8", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "学号 2013011356\n在手册的6.12.1 中的 FIgure 6-4 提到了区别\n如果没有特权级的变化, 那么就不会涉及到栈的切换, 并且压入Error Code, EIP, CS, EFLAGS\n如果有特权级变化, 那么会涉及到栈的切换, 并且会在切换到的栈中压入Error Code, EIP, CS, EFLAGS, ESP, SS"}, {"folders": [], "updated": "2016-03-02T08:41:16Z", "uid": "i0gkdbms5ie20o", "created": "2016-03-02T08:41:16Z", "type": "feedback", "id": "ilalgadivno51l", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>乔奕 2013011324</p>\n<p></p>\n<p>内核态中断时&#xff0c;不需要发生栈切换。会在栈上保存Error Code、EIP、CS、EFLAGS。</p>\n<p></p>\n<p>用户态中断时&#xff0c;需进行栈切换。用户栈上内容保持不变&#xff0c;但是esp转到内核栈上&#xff0c;但是原来的esp&#xff08;指向y用户栈上的&#xff09;需要被保存下来&#xff0c;以便之后恢复到用户栈上。所以用户态的esp和ss需要保存在内核栈上。因此内核栈上需要保存Error Code、EIP、CS、EFLAGS和ESP、SS。</p>\n<p></p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:41:57Z", "uid": "i701mss708y", "created": "2016-03-02T08:41:57Z", "type": "feedback", "id": "ilalh5wgfg56jq", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>2012011302 陈伯乐</p>\n<p>内核态中断时&#xff0c;不发生栈切换&#xff0c;只需要保存Error Code、EIP、CS、EFLAGS。</p>\n<p>用户态中断时&#xff0c;发生栈切换。并在切换到的栈中保存Error Code、EIP、CS、EFLAGS。</p>\n<p>并且堆栈里的会多两个寄存器的值&#xff1a;SS和ESP寄存器用于进行前一个栈的恢复。</p>"}, {"folders": [], "updated": "2016-03-02T08:47:10Z", "uid": "i11dx198ive25r", "created": "2016-03-02T08:47:10Z", "type": "feedback", "id": "ilalnvqeeer7ew", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>叶方轲 2013011340</p>\n<p>张殿炎 2013011328</p>\n<p>在内核态中断不需要发生栈切换&#xff0c;需要在栈上保存Error Code、EIP、CS、EFLAGS。</p>\n<p>在用户态中断会发生特权级变化&#xff0c;需要进行栈切换&#xff0c;硬件会额外将SS和ESP压入栈中以便在中断处理完成后恢复原来的栈。</p>"}, {"folders": [], "updated": "2016-03-02T08:52:03Z", "uid": "ibz6web8v91dk", "created": "2016-03-02T08:52:03Z", "type": "feedback", "id": "ilalu5ta7ko4a9", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>查阅Intel 开发手册&#xff0c;在6.12.1 (p. 2150) 中说明了特权级改变和不变时的堆栈变化。</p>\n<p></p>\n<p><strong>特权级不变时&#xff1a;</strong>被打断的进程和Handler的栈中相同&#xff0c;从顶到下储存的是EFLAGS, CS, EIP, Error Code。</p>\n<p><strong>特权级改变时&#xff1a;</strong>发生栈切换&#xff0c;Handler的栈中从顶到下储存的是SS, ESP, EFLAGS, CS, EIP, Error Code.</p>\n<p></p>\n<p>组员&#xff1a;2012011308 陆喆&#xff0c;2012080060甄显安</p>"}, {"folders": [], "updated": "2016-03-02T08:54:35Z", "uid": "ikvcvo2cckb7jb", "created": "2016-03-02T08:54:35Z", "type": "feedback", "id": "ilalxev1nnu44t", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>#2013011302</p>\n<p></p>\n<p>比较不同特权级的中断切换时的堆栈变化差别&#xff1b;(challenge)写出一些简单的小程序&#xff08;c or asm&#xff09;来显示出不同特权级的的中断切换的堆栈变化情况。</p>\n<p></p>\n<p>内核态中断时不发生栈切换&#xff0c;栈上保存Error Code、EIP、CS、EFLAGS。</p>\n<p>用户态中断时发生栈切换。切换后的栈保存SS、Error Code、EIP、CS、EFLAGS。</p>"}, {"folders": [], "updated": "2016-03-02T10:30:40Z", "uid": "i11v1az5sf83l2", "created": "2016-03-02T10:30:40Z", "type": "feedback", "id": "ilapcyw0srk2g2", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>余翔2013011310</p>\n<p>林婕茵2013011308</p>\n<p>内核态中断时&#xff0c;不发生栈切换。会在栈上保存Error Code、EIP、CS、EFLAGS。</p>\n<p>用户态中断时&#xff0c;发生栈切换。因此内核栈上需要保存Error Code、EIP、CS、EFLAGS和ESP、SS。</p>"}, {"folders": [], "updated": "2016-03-02T10:34:38Z", "uid": "i0cb1385ni65l", "created": "2016-03-02T10:34:38Z", "type": "feedback", "id": "ilapi33tpba1kw", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>"}, {"folders": [], "updated": "2016-03-02T10:39:29Z", "uid": "ikvcvmzbvlf7i6", "created": "2016-03-02T10:39:29Z", "type": "feedback", "id": "ilapoben104265", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p><span style=\"color:#333333\"><span style=\"color:#333333\">当中断发生时,如果正在内核态,则不需要进行栈切换,同时内核栈上只要保存Error Code,EIP,CS,EFLAGS</span></span></p>\n<p><span style=\"color:#333333\"><span style=\"color:#333333\">否则,如果中断发生在用户态,需要进行到内核态的切换,同时需要额外保存<span style=\"color:#333333\"><span style=\"color:#333333\">ESP,SS,用于在中断处理完毕返回用户态时的状态恢复</span></span></span></span></p>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T10:49:23Z", "uid": "i2om0jwie732m1", "created": "2016-03-02T10:49:23Z", "type": "feedback", "id": "ilaq12321xk6ug", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "内核态中断时&#xff0c;无栈切换&#xff0c;只需要保存Error Code、EIP、CS、EFLAGS。\n用户态中断时&#xff0c;有栈切换&#xff0c;在切换到的栈里保存Error Code、EIP、CS、EFLAGS。\n并且堆栈里的会多两个寄存器的值&#xff1a;SS和ESP寄存器用于进行前一个栈的恢复。"}, {"folders": [], "updated": "2016-03-02T10:51:54Z", "uid": "i6uaz437IKR", "created": "2016-03-02T10:51:54Z", "type": "feedback", "id": "ilaq4a3c4kpo8", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "2012080056 金贤林 \n从用户态切换到内核态中断时&#xff0c;堆栈里的会多两个寄存器的值&#xff1a;SS和ESP寄存器\n而如果没有切换&#xff0c;则不需要保存这两个寄存器。"}, {"folders": [], "updated": "2016-03-02T11:05:17Z", "uid": "ikvcvr6di5i7ma", "created": "2016-03-02T11:05:17Z", "type": "feedback", "id": "ilaqlhxsylf17j", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>杨明 2013011412 谢琛睿2013011406</p>\n<p>详见intel手册6.4.1节&#xff1a;切换前后的两个程序是相同级别的&#xff0c;那么它们使用的是同一个栈&#xff0c;先将EFLAGS,CS,EIP依次压栈&#xff0c;<br />并将error code压栈&#xff0c;将新段基址和指令指针覆盖CS和EIP寄存器&#xff08;中断调用会清空EFLAGS寄存器&#xff09;&#xff0c;再开始执行处理程<br />序&#xff1b;如果切换到更高级别的程序&#xff0c;则暂存SS,ESP,EFLAGS,CS,EIP寄存器&#xff0c;将任务状态段TSS中内容加载到SS和ESP,转到新<br />栈&#xff0c;将之前暂存的SS,ESP,EFLAGS,CS,EIP值压入新栈&#xff0c;并压上error code,将新段基址和指令指针覆盖CS和EIP寄存器<br />&#xff08;中断调用会清空EFLAGS寄存器&#xff09;&#xff0c;最后以新的优先级执行处理程序&#xff1b;当从中断返回时&#xff0c;也会检查优先级别做出相应<br />处理。</p>\n<p>&#64;challenge: 修改trap/trap.c中idt_init的代码&#xff0c;将</p>\n<p>SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</p>\n<p>这句DPL_USER改为DPL_KERNEL&#xff0c;即切回时转到内核态&#xff0c;产生错误&#xff0c;无法切回。</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/ikvcvr6di5i7ma/ilaqhjwycfxl/res.JPG\" /></p>"}, {"folders": [], "updated": "2016-03-02T11:53:10Z", "uid": "iem550jbpyn515", "created": "2016-03-02T11:53:10Z", "type": "feedback", "id": "ilasb2uf78f2p7", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>章彦恺 2012011284<br /><br />以ucore为例&#xff0c;<br /><br />考虑从内核态切换到用户态的实现。由于从内核态到用户态的切换过程在调用中断时依然在内核态进行调用&#xff0c;不涉及到特权级的转换&#xff0c;因此此时ss和esp没有进行压栈&#xff0c;因此需要对esp预先减8。最后在int调用结束后恢复esp的值。<br /><br />实现的方法是在init.c中对lab1_switch_to_user函数进行修改&#xff0c;实现</p>\n<p></p>\n<pre>static void<br />lab1_switch_to_user(void) {<br />    asm volatile (<br />        &#34;sub $0x8, %%esp;&#34;<br />        &#34;int %0;&#34;<br />        &#34;movl %%ebp, %%esp;&#34;<br />        :<br />        : &#34;i&#34;(T_SWITCH_TOU)<br />    );<br />}</pre>\n<p>类似的&#xff0c;在init.c中&#xff0c;对&#96;lab1_switch_to_kernel&#96;函数进行修改来触发中断&#xff0c;实现如下</p>\n<pre>static void\nlab1_switch_to_kernel(void) {\n\tasm volatile (\n\t    &#34;int %0;&#34;\n\t    &#34;movl %%ebp, %%esp;&#34;\n\t    :\n\t    : &#34;i&#34;(T_SWITCH_TOK)\n\t);\n}</pre>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T13:23:46Z", "uid": "i0minzvpea57bu", "created": "2016-03-02T13:23:46Z", "type": "feedback", "id": "ilavjksb3xm2pj", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>在内核态发生中断时&#xff0c;不会发生栈切换&#xff0c;只需要保存Error Code、EIP、CS、EFLAGS</p>\n<p>而在用户态发生中断时&#xff0c;需要切换到内核态的栈&#xff0c;且需要多保存ESP、SS&#xff0c;用于执行结束后恢复到用户栈。</p>"}], "subject": "<p></p><div>题目&#xff1a;</div>\n<div>2. 4.2中的第5小题&#xff1a;比较不同特权级的中断切换时的堆栈变化差别&#xff1b;(challenge)写出一些简单的小程序&#xff08;c or asm&#xff09;来显示出不同特权级的的中断切换的堆栈变化情况。</div>\n<div></div>\n<div>回答结果写在此贴中对应题目后面。</div>\n<p></p>"}, {"folders": [], "updated": "2016-03-02T08:56:42Z", "no_upvotes": 0, "uid": "i0f97hpgaug3eu", "created": "2016-03-02T08:56:42Z", "type": "followup", "no_answer": 0, "id": "ilam04oc8ah5yw", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2016-03-02T14:56:37Z", "uid": "hdjonbiyfs62ie", "created": "2016-03-02T14:56:37Z", "type": "feedback", "id": "ilayuzjfjwq3mn", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p><p>韩旭 2013011343</p>\n<p>徐磊 2013011344</p>\n<p></p>\n<p>完成两个challenge.</p>\n<p></p>\n<p>find on <a href=\"https://github.com/THUCSTHanxu13/OS2016/tree/master/02-2-spoc\">[GitHub]</a></p>\n<p></p>\n<p>https://github.com/THUCSTHanxu13/OS2016/tree/master/02-2-spoc</p>"}], "subject": "<p>The post is a mistake</p>\n<p></p>"}], "nr": 649, "bucket_order": 2, "config": {}, "status": "active", "tags": ["instructor-note", "课堂问答"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-03-02T08:14:25Z", "is_tag_good": false, "type": "note", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1457674493584, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p></p>\n<div>请向勇班的同学把“第四讲 lab1 SPOC思考题”中指定小题的回答结果写在此贴中对应题目后面。</div>\n<div> </div>\n<div><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-2-lab1-spoc-discussion.md#lab1-spoc%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-2-lab1-spoc-discussion.md#lab1-spoc思考题</a></div>\n<div> </div>\n<div>第四讲的回答的截止时间是今天&#xff08;20160302&#xff09;晚20点前。</div>\n<div> </div>\n<div>要求&#xff1a;两个人一组或独立回答&#xff0c;每组只需要完成指定的一个题目。题目指定方法是&#xff0c;小组成员学号最小值与题号除2后余数相同。</div>\n<div> </div>\n<div>题目&#xff1a;</div>\n<div>1. 4.1中的第7小题&#xff1a;描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么&#xff1f;在哪些寄存器中这些字段&#xff1f;对应的访问条件是什么&#xff1f; (challenge)写出一些简单的小程序&#xff08;c or asm&#xff09;来体现这些特权级的区别和联系。</div>\n<div>2. 4.2中的第5小题&#xff1a;比较不同特权级的中断切换时的堆栈变化差别&#xff1b;(challenge)写出一些简单的小程序&#xff08;c or asm&#xff09;来显示出不同特权级的的中断切换的堆栈变化情况。</div>\n<div> </div>\n<div>优胜者&#xff1a;</div>\n<div>1. 4.1中的第7小题&#xff1a;<br />2013011389 郑兆衡 2013011416 张浩天<br />Liu Xiaohong<br /><br />challenge:<br />2013011371 沈哲言 2013011404 叶子鹏<br />杨晓成2013011383<br />朱俸民 2012011894 &amp; 朱新瑞 2013011411<br /><br />2. 4.2中的第5小题&#xff1a;<br />Wang Chengrui<br />杨明 2013011412 谢琛睿2013011406<br /><br />challenge:<br />2013011402 钱迪晨&#xff0c;2013011413 高思达<br />章彦恺 2012011284<br />韩旭 2013011343 徐磊 2013011344</div>", "anon": "no", "subject": "2016春季-第四讲课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-03-02T15:05:27Z"}, {"content": "<p></p><div>请向勇班的同学把“第四讲 lab1 SPOC思考题”中指定小题的回答结果写在此贴中对应题目后面。</div>\n<div> </div>\n<div><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-2-lab1-spoc-discussion.md#lab1-spoc%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/02-2-lab1-spoc-discussion.md#lab1-spoc思考题</a></div>\n<div> </div>\n<div>第四讲的回答的截止时间是今天&#xff08;20160302&#xff09;晚20点前。</div>\n<div> </div>\n<div>要求&#xff1a;两个人一组或独立回答&#xff0c;每组只需要完成指定的一个题目。题目指定方法是&#xff0c;小组成员学号最小值与题号除2后余数相同。</div>\n<div> </div>\n<div>题目&#xff1a;</div>\n<div>1. 4.1中的第7小题&#xff1a;描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么&#xff1f;在哪些寄存器中这些字段&#xff1f;对应的访问条件是什么&#xff1f; (challenge)写出一些简单的小程序&#xff08;c or asm&#xff09;来体现这些特权级的区别和联系。</div>\n<div>2. 4.2中的第5小题&#xff1a;比较不同特权级的中断切换时的堆栈变化差别&#xff1b;(challenge)写出一些简单的小程序&#xff08;c or asm&#xff09;来显示出不同特权级的的中断切换的堆栈变化情况。</div>\n<div> </div>\n<div>优胜者&#xff1a;</div>", "anon": "no", "subject": "2016春季-第四讲课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-03-02T08:14:25Z"}]}, "error": null}