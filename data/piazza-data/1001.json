{"aid": "j02jv7j34fpj4", "result": {"status": "active", "unique_views": 8, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "stud", "when": "2017-03-09T09:10:39Z", "data": "j026aynlbx729r", "uid": "ie7xy53vpn41q7"}, {"to": "j026ayni4i629q", "anon": "no", "when": "2017-03-09T12:45:43Z", "type": "followup", "uid": "io2ra61elC5"}], "upvote_ids": [], "id": "j026ayni4i629q", "bookmarked": 5, "tags": ["lab1", "student"], "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2017-03-09T12:45:43Z", "no_upvotes": 0, "uid": "io2ra61elC5", "created": "2017-03-09T12:45:43Z", "type": "followup", "no_answer": 1, "id": "j02dzjtxuei4ra", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>我觉得是这样&#xff0c;最早只有段机制&#xff0c;x86通过CPL&#xff0c;RPL和DPL机制&#xff08;视频有讲&#xff09;来实现保护模式完整的权限检查&#xff0c;后来用页机制也只是用到了虚拟地址空间&#xff0c;权限管理用的不多。可能为了前向兼容&#xff0c;没有完全抛弃段机制&#xff08;以及基于段机制的完整的权限管理&#xff09;&#xff0c;所以还是要保留用户态和内核态的代码段、数据段来实现权限检查。其他架构比如arm就没有历史包袱&#xff0c;就完全没有段管理机制&#xff0c;是通过其他方式实现权限管理的。</p>"}], "nr": 1001, "bucket_order": 2, "type": "note", "folders": ["lab1"], "no_answer_followup": 1, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2017-03-09T09:10:39Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1489073418975, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>在Lab1的实验中需要了解GDT表的建立&#xff0c;于是我在mm/pmm.c文件中找到了如下的定义&#xff1a;</p>\n<p></p>\n<pre>/* *<br /> * Global Descriptor Table:<br /> *<br /> * The kernel and user segments are identical (except for the DPL). To load<br /> * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the<br /> * segments for the user and the kernel. Defined as follows:<br /> *   - 0x0 :  unused (always faults -- for trapping NULL far pointers)<br /> *   - 0x8 :  kernel code segment<br /> *   - 0x10:  kernel data segment<br /> *   - 0x18:  user code segment<br /> *   - 0x20:  user data segment<br /> *   - 0x28:  defined for tss, initialized in gdt_init<br /> * */<br />static struct segdesc gdt[] = {<br />    SEG_NULL,<br />    [SEG_KTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_KERNEL),<br />    [SEG_KDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_KERNEL),<br />    [SEG_UTEXT] = SEG(STA_X | STA_R, 0x0, 0xFFFFFFFF, DPL_USER),<br />    [SEG_UDATA] = SEG(STA_W, 0x0, 0xFFFFFFFF, DPL_USER),<br />    [SEG_TSS]    = SEG_NULL,<br />};</pre>\n<p>老师在课堂和MOOC中均提到&#xff0c;uCore将x86提供的段机制看作是直接映射&#xff0c;在页机制未启用的前提下&#xff0c;达到了逻辑地址=线性地址=物理地址的效果。观察上面的代码&#xff0c;除了第一个SEG_NULL是硬件需要之外&#xff0c;其他的五个SEG有四个都将地址映射到了0x00000000-0xFFFFFFFF&#xff0c;也就是说&#xff1a;当访存的逻辑地址唯一确定的时候&#xff0c;对应的线性地址就确定了&#xff0c;而对该逻辑地址的权限则由CS或是DS等寄存器决定&#xff0c;因此也可以通过观察CS的值确定当前到底是用户态还是内核态。</p>\n<p></p>\n<p>那么为什么还需要这6个段呢&#xff1f;在课下与陈老师的讨论中&#xff0c;得知这样做的目的是<strong>权限控制</strong>。</p>\n<p>举个例子&#xff0c;当CS为用户态时&#xff0c;如果试图执行某些特权指令或是内核态中断&#xff0c;就会触发x86的13号一般保护异常(  <a href=\"http://ilinuxkernel.com/?p=1388\">http://ilinuxkernel.com/?p=1388</a> )。 在lab1的challenge实验中&#xff0c;建立IDT表的时候&#xff0c;需要把T_SWITCH_TOK特权级别设置为DPL_USER&#xff0c;这样一来&#xff0c;在用户态执行lab1_switch_to_kernel的int指令时&#xff0c;就不会触发一般保护异常了。</p>\n<p></p>\n<p>至于SEG_NULL和SEG_TSS&#xff0c;前者应该是x86硬件需求&#xff0c;后者是之后的lab中会用到的用户用户态和内核态栈切换存储寄存器的临时区域&#xff0c;是动态建立的。</p>\n<p></p>\n<p>但其实写到这里&#xff0c;我还是有一个不太理解的地方&#xff0c;那就是既然之后会有页机制来进行权限控制&#xff0c;为什么还要在这里重复进行检查呢&#xff0c;这一步是多余的吗&#xff08;即段表只设置NULL和KERNEL可以吗&#xff09;&#xff1f;</p>\n<p></p>\n<p>希望同学一起讨论一下&#xff0c;如果我有新的理解再更新。</p>", "anon": "stud", "created": "2017-03-09T09:10:39Z", "uid": "ie7xy53vpn41q7", "subject": "有关于mm/pmm.c中GDT表的建立"}]}, "error": null}