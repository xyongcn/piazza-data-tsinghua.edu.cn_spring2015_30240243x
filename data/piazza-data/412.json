{"aid": "igkpwbe6but2pp", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 23, "request_instructor": 0, "history": [{"uid": "hcrrjuyequh4bt", "anon": "no", "created": "2015-05-11T06:18:09Z", "content": "<p>提交到此</p>", "subject": "lec20 spoc"}], "s_edits": [], "tag_good_arr": [], "is_bookmarked": false, "my_favorite": false, "t": 1446636292782, "children": [{"uid": "i6vi7mt1I4G", "no_answer": 0, "created": "2015-05-11T06:18:56Z", "id": "i9ji13a416d401", "updated": "2015-05-11T06:18:56Z", "subject": "<p>pipe实现</p>\n<p>银行家算法</p>\n<p></p>\n<p>黄杰 2012011272</p>\n<p>杜鹃 2012011354</p>\n<p>袁源 2012011294</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [{"uid": "i6sl02qfUgI", "created": "2015-05-11T06:28:34Z", "id": "i9jidhjkrrp7j6", "updated": "2015-05-11T06:28:34Z", "subject": "<p>https://github.com/THUHJ/os_exercises/blob/master/all/08-1-spoc-discussion.md</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}, {"uid": "i6sl02qfUgI", "created": "2015-05-11T06:54:00Z", "id": "i9jja6vrqro681", "updated": "2015-05-11T06:54:00Z", "subject": "<p>银行家算法的实现也在08-1-spoc-discussion.md中~</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i7oaxkxhxjo3ui", "no_answer": 1, "created": "2015-05-11T06:20:49Z", "id": "i9ji3ii9jtc4zz", "updated": "2015-05-11T06:20:49Z", "subject": "<p>罗鸿胤 2012011319</p>\n<p>杨元 2012011331</p>\n<p></p>\n<p>管道&#xff1a;</p>\n<p>使用struck储存所有pipe的内存位置&#xff0c;pipefile的数量和pipe的大小&#xff0c;当父进程创建pipe时&#xff0c;分配空间。在读进程中&#xff0c;判断是否有写进程在临界区&#xff0c;若有&#xff0c;读近程等待&#xff0c;若无&#xff0c;阻塞写进程。之后对rc共享变量进行互斥访问。读进程完成后&#xff0c;判断有无写进程需要进入临界区若有&#xff0c;则唤醒写进程进入临界区。父进程关闭pipe时&#xff0c;判断引用计数是否为零。若是&#xff0c;释放资源&#xff0c;若否&#xff0c;关闭失败</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}, {"uid": "i6tezdpdQbq", "no_answer": 1, "created": "2015-05-11T06:21:31Z", "id": "i9ji4fk2jdi515", "updated": "2015-05-11T06:21:31Z", "subject": "<p>shared memory实现</p>\n<p></p>\n<p>首先&#xff0c;在内核中维护一个共享内存表&#xff0c;每一个共享内存表项对应一个共享内存空间的入口。</p>\n<p>在进程创建共享内存空间时&#xff0c;会在共享内存表中初始化该内存空间&#xff0c;并且其和其通信进程获得一个key&#xff0c;对应共享内存表可以查询到该共享内存空间的地址。</p>\n<p>利用同步互斥机制完成对共享内存的同步互斥管理。</p>\n<p></p>\n<p>周昊 2012011326</p>\n<p>李日灵 2012011332</p>\n<p>楼华哲 2012011327</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [{"uid": "i7bq1v7feay2z9", "created": "2015-05-11T06:48:42Z", "id": "i9jj3dsayjoap", "updated": "2015-05-11T06:48:42Z", "subject": "<p></p><pre>def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # 2012011327\n        ans = True;\n        for i in range(len(self.need[index])):\n        \tif (self.need[index][i] &gt; self.avaliable[i]):\n        \t\tans = False\n        \t\tbreak\n        #check END here\n\n        #allocating what they need.\n        # 2012011327\n        if ans:\n        \tself.finished[index] = True\n        \tfor i in range(len(self.need[index])):\n        \t\tself.avaliable[i] -= self.need[index][i]\n        \t\tself.allocated[index][i] &#43;= self.need[index][i]\n        \t\tself.need[index][i] = 0\n        #allocating END here\n        return ans\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # 2012011327\n        ans = False\n        ishave = False\n        for i in range(len(self.need)):\n        \tif self.finished[i] == False:\n        \t\tishave = True\n        \t\tfor j in range(len(self.need[i])):\n        \t\t\tif (self.need[i][j] &gt; self.avaliable[j]):\n        \t\t\t\tbreak\n        \t\t\tif (j == len(self.need[i])-1):\n        \t\t\t\tans = True\n        #check END here\n        if ishave:\n        \treturn ans\n        else:\n        \treturn True</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}, {"uid": "i6tezdpdQbq", "created": "2015-05-11T06:53:13Z", "id": "i9jj96jxy3c3cd", "updated": "2015-05-11T06:53:13Z", "subject": "<p>结果如下&#xff1a;</p>\n<p>start here</p>\n<p>_____________________________________________</p>\n<p>MAX  Allocated Need</p>\n<p>[18, 16, 0, 0] [17, 8, 0, 0] [1, 8, 0, 0]</p>\n<p>[4, 5, 0, 0] [0, 0, 0, 0] [4, 5, 0, 0]</p>\n<p>[2, 2, 0, 1] [0, 0, 0, 0] [2, 2, 0, 1]</p>\n<p>_____________________________________________</p>\n<p>Resources:</p>\n<p>Total: [28, 28, 1, 2] Available: [11, 20, 1, 2]</p>\n<p></p>\n<p>Executing...</p>\n<p>Request: </p>\n<p>[1, 8, 0, 0]</p>\n<p>Dispatching Done...</p>\n<p>_____________________________________________</p>\n<p>MAX  Allocated Need</p>\n<p>[18, 16, 0, 0] [18, 16, 0, 0] [0, 0, 0, 0]</p>\n<p>[4, 5, 0, 0] [0, 0, 0, 0] [4, 5, 0, 0]</p>\n<p>[2, 2, 0, 1] [0, 0, 0, 0] [2, 2, 0, 1]</p>\n<p>_____________________________________________</p>\n<p>Resources:</p>\n<p>Total: [28, 28, 1, 2] Available: [10, 12, 1, 2]</p>\n<p></p>\n<p>-----Releasing Process------</p>\n<p>_____________________________________________</p>\n<p>MAX  Allocated Need</p>\n<p>[18, 16, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0]</p>\n<p>[4, 5, 0, 0] [0, 0, 0, 0] [4, 5, 0, 0]</p>\n<p>[2, 2, 0, 1] [0, 0, 0, 0] [2, 2, 0, 1]</p>\n<p>_____________________________________________</p>\n<p>Resources:</p>\n<p>Total: [28, 28, 1, 2] Available: [28, 28, 1, 2]</p>\n<p></p>\n<p>Executing...</p>\n<p>Request: </p>\n<p>[4, 5, 0, 0]</p>\n<p>Dispatching Done...</p>\n<p>_____________________________________________</p>\n<p>MAX  Allocated Need</p>\n<p>[18, 16, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0]</p>\n<p>[4, 5, 0, 0] [4, 5, 0, 0] [0, 0, 0, 0]</p>\n<p>[2, 2, 0, 1] [0, 0, 0, 0] [2, 2, 0, 1]</p>\n<p>_____________________________________________</p>\n<p>Resources:</p>\n<p>Total: [28, 28, 1, 2] Available: [24, 23, 1, 2]</p>\n<p></p>\n<p>-----Releasing Process------</p>\n<p>_____________________________________________</p>\n<p>MAX  Allocated Need</p>\n<p>[18, 16, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0]</p>\n<p>[4, 5, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0]</p>\n<p>[2, 2, 0, 1] [0, 0, 0, 0] [2, 2, 0, 1]</p>\n<p>_____________________________________________</p>\n<p>Resources:</p>\n<p>Total: [28, 28, 1, 2] Available: [28, 28, 1, 2]</p>\n<p></p>\n<p>Executing...</p>\n<p>Request: </p>\n<p>[2, 2, 0, 1]</p>\n<p>Dispatching Done...</p>\n<p>_____________________________________________</p>\n<p>MAX  Allocated Need</p>\n<p>[18, 16, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0]</p>\n<p>[4, 5, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0]</p>\n<p>[2, 2, 0, 1] [2, 2, 0, 1] [0, 0, 0, 0]</p>\n<p>_____________________________________________</p>\n<p>Resources:</p>\n<p>Total: [28, 28, 1, 2] Available: [26, 26, 1, 1]</p>\n<p></p>\n<p>-----Releasing Process------</p>\n<p>_____________________________________________</p>\n<p>MAX  Allocated Need</p>\n<p>[18, 16, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0]</p>\n<p>[4, 5, 0, 0] [0, 0, 0, 0] [0, 0, 0, 0]</p>\n<p>[2, 2, 0, 1] [0, 0, 0, 0] [0, 0, 0, 0]</p>\n<p>_____________________________________________</p>\n<p>Resources:</p>\n<p>Total: [28, 28, 1, 2] Available: [28, 28, 1, 2]</p>\n<p></p>\n<p>SUCCESS proc lists  [0, 1, 2]</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i7bg4v1keqE", "no_answer": 1, "created": "2015-05-11T06:22:10Z", "id": "i9ji5944vi78w", "updated": "2015-05-11T06:22:10Z", "subject": "<p>共享内存通信实现&#xff1a;</p>\n<p></p>\n<p>王妍 2012011352</p>\n<p></p>\n<p>数据结构&#xff1a;struct share_mem : Page* pages; size_t size; int shmid;<br />int shmget(key_t key, size_t size, int shmflg);<br />创建共享块时&#xff0c;首先alloc相应大小的pages&#xff0c;保存share_mem结构(文件系统中可通过创建文件实现)&#xff0c;返回全局的唯一共享内存标识符 shm_id&#xff1b; <br />void *shmat(int shm_id, const void *shm_addr, int shmflg); <br />进程使用时&#xff0c;根据shm_id, 获取相应的共享内存块&#xff0c;将其映射到自己的地址空间&#xff0c;即修改页表项<br />int shmdt(const void *shm_addr);<br />禁止本进程使用这块共享内存&#xff1a;解除进程对共享内存区域的映射&#xff0c;将相应的页表项valid位置为0<br />int shmctl(int shm_id, int cmd, struct shmid_ds *buf);<br />共享内存块独立于进程进行控制&#xff1a;要在程序结束前&#xff0c;进行系统调用删除等操作<br />处理互斥同步问题&#xff1a;进程间使用互斥锁和信号量实现均可</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}, {"uid": "i6t7mzhbhwF", "no_answer": 1, "created": "2015-05-11T06:23:36Z", "id": "i9ji73gdofd5ri", "updated": "2015-05-11T06:23:36Z", "subject": "<p>周界 2012011394</p>\n<p>战裕隆 2012011388</p>\n<p>杨俊 2012011400</p>\n<p></p>\n<p>信号实现</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [{"uid": "i6t7mzhbhwF", "created": "2015-05-11T06:31:24Z", "id": "i9jih4kf93vmg", "updated": "2015-05-11T06:31:24Z", "subject": "<p>信号设计方案</p>\n<p> 对于每个进程设立一个信号处理列表。这里记录了每个信号标识和运行程序地址的映射关系。</p>\n<p></p>\n<p>每当运行一个signal(SIGINT, signal_callback_handler);函数时&#xff0c;会进行系统调用&#xff0c;在系统调用的内核处理函数中会将SIGINT对应的程序调用地址设置为signal_callback_handler&#xff0c;这里修改的是current进程的信号处理列表。 </p>\n<p></p>\n<p>当系统收到信号时&#xff0c;会调用中断处理例程&#xff0c;在中断处理例程中会判断这是否是一个信号&#xff0c;如果是则跳转到信号处理的内核函数。在该内核函数中&#xff0c;操作系统内核会查找current进程的信号处理列表&#xff0c;找到其程序处理地址&#xff0c;然后执行一个函数调用&#xff0c;在用户运行栈上增加处理程序的栈帧&#xff0c;然后修改PC为该地址&#xff0c;转而运行该处理程序&#xff0c;处理程序结束后&#xff0c;会根据函数调用的退出方式&#xff0c;继续回到程序原地址继续执行。</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}, {"uid": "i6t7mzhbhwF", "created": "2015-05-11T07:22:00Z", "id": "i9jka76j4xgi4", "updated": "2015-05-11T07:22:00Z", "subject": "<p></p><pre>    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # YOUR CODE, 2012011394\n\tflag = True\n\tfor i in range(0, len(self.need[index])):\n\t\tif self.avaliable[i] &lt; self.need[index][i]:\n\t\t\tflag = False\n\t\t\tbreak\n\tif (not flag):\n\t\treturn flag\n        #check END here\n\n        #allocating what they need.\n        # YOUR CODE, YOUR ID\n        #allocating END here\n\t\n\tfor i in range(0, len(self.need[index])):\n\t\tself.allocated[index][i] &#43;= self.need[index][i]\n\t\tself.avaliable[i] -= self.need[index][i]\n\t\tself.need[index][i] = 0\n\tself.CalcAvaliable()\n\treturn flag\n\tpass\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # YOUR CODE, 2012011394\n\tflag = True\n\tfor i in range(0, procnum):\n\t\tfor j in range(0, len(self.avaliable)):\n\t\t\tif self.avaliable[j] &lt; self.need[i][j]:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n\treturn flag\n        #check END here\n        pass</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i7bfq2txxyw689", "no_answer": 1, "created": "2015-05-11T06:24:46Z", "id": "i9ji8lgiulp6c7", "updated": "2015-05-11T06:24:46Z", "subject": "<p>覃伟 计22 2012011278</p>\n<p>徐天宇 计22 2012011275</p>\n<p></p>\n<p>进程间通信&#xff1a;</p>\n<div> 共享内存&#xff1a;通过系统调用&#xff0c;申请一段内存为共享内存&#xff0c;用于与其他进程的通信&#xff0c;该段内存地址空间将通过修改页表的方式映射到该进程的虚拟地址空间&#xff0c;该段内存地址空间有一个唯一的标志id&#xff0c;其他进程如果需要进行通信&#xff0c;就要先通过该id申请并且建立映射关系&#xff0c;这样就可以共享这一段内存空间了&#xff0c;但是在实际上使用的时候&#xff0c;需要借助同步互斥来进行读、写操作。</div>\n<div></div>\n<div></div>\n<div></div>\n<div>银行家算法&#xff1a;</div>\n<div><a href=\"https://github.com/qw540232188/ucore_lab/blob/master/related_info/lab7/deadlock/bankers-homework.py\">https://github.com/qw540232188/ucore_lab/blob/master/related_info/lab7/deadlock/bankers-homework.py</a></div>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [{"uid": "i6uak1ivjzr1i0", "created": "2015-05-11T07:10:33Z", "id": "i9jjvh5hc78oh", "updated": "2015-05-11T07:10:33Z", "subject": "<p>银行家算法实现如下&#xff1a;&#xff08;只提供填写的部分所在的函数&#xff09;</p>\n<pre>def ExecuteProcess(self,index):<br /><br />    #check if less avaliable than Request<br />    #YOUR CODE 2012011275<br />    for Ri in range(len(self.need[index])):<br />        if self.need[index][Ri] &gt; self.avaliable[Ri]:<br />            return False<br />    #check END here<br /><br />    #allocating what they need.<br />    #YOUR CODE 2012011275<br />    for Ri in range(len(self.need[index])):<br />        self.allocated[index][Ri] &#43;= self.need[index][Ri]<br />        self.avaliable[Ri] -= self.need[index][Ri]<br />        self.need[index][Ri] = 0<br />    #allocating END here<br />    return True<br /><br />def TempSafeCheckAfterRelease(self):<br />    #check if at least one request can be done after previous process done. not check whole sequences.<br />    #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state<br />    #YOUR CODE 2012011275<br />    finishedNum = 0<br />    for Ti in range(len(self.max)):<br />        if self.finished[Ti]:<br />            finishedNum &#43;= 1<br />            continue<br />        canDone = 1<br />        for Ri in range(len(self.need[Ti])):<br />            if self.need[Ti][Ri] &gt; self.avaliable[Ri]:<br />                canDone = 0<br />                break<br />        if canDone == 1:<br />            return True<br />    if finishedNum == len(self.max):<br />        return True<br />    #check END here<br />    return False</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i6utvrywozd2vd", "no_answer": 1, "created": "2015-05-11T06:29:01Z", "id": "i9jie2cbp0q1ll", "updated": "2015-05-11T06:29:01Z", "subject": "<p>陈天昱 2012011348</p>\n<p>李心田 2012011338</p>\n<p></p>\n<p>共享内存</p>\n<p></p>\n<p>看一下 Linux 是如何实现共享内存的&#xff0c;这是 System V 风格的共享内存。首先有这样一个表示共享内存区域的结构体&#xff1a;</p>\n<p></p>\n<pre>/* Data structure describing a shared memory segment.  */\nstruct shmid_ds\n  {\n    struct ipc_perm shm_perm;           /* operation permission struct */\n    size_t shm_segsz;                   /* size of segment in bytes */\n    __time_t shm_atime;                 /* time of last shmat() */\n#ifndef __x86_64__\n    unsigned long int __glibc_reserved1;\n#endif\n    __time_t shm_dtime;                 /* time of last shmdt() */\n#ifndef __x86_64__\n    unsigned long int __glibc_reserved2;\n#endif\n    __time_t shm_ctime;                 /* time of last change by shmctl() */\n#ifndef __x86_64__\n    unsigned long int __glibc_reserved3;\n#endif\n    __pid_t shm_cpid;                   /* pid of creator */\n    __pid_t shm_lpid;                   /* pid of last shmop */\n    shmatt_t shm_nattch;                /* number of current attaches */\n    __syscall_ulong_t __glibc_reserved4;\n    __syscall_ulong_t __glibc_reserved5;\n  };</pre>\n<p></p>\n<p>然后在 sys/shm.h 中定义几个方法&#xff0c;功能如下&#xff1a;</p>\n<p></p>\n<pre>/* The following System V style IPC functions implement a shared memory\n   facility.  The definition is found in XPG4.2.  */\n\n/* Shared memory control operation.  */\nextern int shmctl (int __shmid, int __cmd, struct shmid_ds *__buf) __THROW;\n\n/* Get shared memory segment.  */\nextern int shmget (key_t __key, size_t __size, int __shmflg) __THROW;\n\n/* Attach shared memory segment.  */\nextern void *shmat (int __shmid, const void *__shmaddr, int __shmflg)\n     __THROW;\n\n/* Detach shared memory segment.  */\nextern int shmdt (const void *__shmaddr) __THROW;</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [{"uid": "i6utvrywozd2vd", "created": "2015-05-11T07:18:34Z", "id": "i9jk5s9riog5pg", "updated": "2015-05-11T07:18:34Z", "subject": "<p></p>\n<p>shmget 就是用一个 key 返回一个对应到共享内存段的标识符。</p>\n<p></p>\n<p>shmat 将标识符 attach 到调用进程的内存地址空间的一个地址上。</p>\n<p></p>\n<p>shmdt detach 一个当前进程的 shmaddr 指向的内存段。有一个引用计数&#xff0c;最后 detach 的 process 负责释放内存。</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i6uswob7jl4242", "no_answer": 1, "created": "2015-05-11T06:29:04Z", "id": "i9jie4mtvin13k", "updated": "2015-05-11T06:29:04Z", "subject": "<p>数据结构&#xff1a;</p>\n<p>每个进程中维护一个列表&#xff0c;存储每个signal的编号和相应的处理程序的位置</p>\n<p></p>\n<p>执行过程&#xff1a;</p>\n<ul><li>signal函数是一个系统调用&#xff0c;在用户程序中执行时&#xff0c;向本地signal列表中对应的信号编号绑定一个处理程序</li><li>系统接收到信号时&#xff0c;跳入中断处理程序</li><li>判断是否是一个信号</li><li>若是信号则通过调用current进程中signal列表储存的对应信号的处理程序</li><li>此时保存中断前的trapframe保存&#xff0c;记为①</li><li>将返回的trapframe替换为处理程序的trapframe&#xff0c;记为②</li><li>中断返回时返回至处理程序</li><li>处理程序结束后返回信号发生前的程序的trapframe①&#xff0c;即信号处理完成</li></ul>\n<p></p>\n<p>丁延卓 2012011395 </p>\n<p>马晓彬 2012011402</p>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}, {"uid": "i6ut6cjo5lj4aa", "no_answer": 1, "created": "2015-05-11T06:33:42Z", "id": "i9jik2wzgyu5tv", "updated": "2015-05-11T06:33:42Z", "subject": "<p>2012011342 周圣凯</p>\n<p>2012011397 王振</p>\n<p>2012011401 张梦豪</p>\n<p>2012011392 韦福超</p>\n<p> 实现信号&#xff1a;由于通过时钟中断实现调度&#xff0c;可以在操作系统调度进程时&#xff0c;检查发来的信号&#xff0c;根据信号检查此时的信号处理例程&#xff08;在内核组织成一个默认的回调函数表&#xff0c;回调函数也可以由用户进程重新定义&#xff0c;只需要重新传入相应的回调函数&#xff09;&#xff0c;从而实现对信号的处理。</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [{"uid": "i6tawpo5Fm8", "created": "2015-05-11T07:33:09Z", "id": "i9jkojgt6pb1w5", "updated": "2015-05-11T07:33:09Z", "subject": "<p></p><pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = []\n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j])\n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n    \ta=self.avaliable\n    \tb=self.need[index]\n    \tflag=1;\n    \tfor i in range(len(a)):\n    \t    a[i]=a[i]-b[i]\n            if b[i]&gt;a[i]:\n                flag=0\n        if flag==0:\n            return False\n        else:\n            self.avaliable=a\n            self.need[index]=[0,0,0,0]\n            self.finished[index] == True\n            return True\n\n        #check if less avaliable than Request\n        # YOUR CODE, YOUR ID\n        #check END here\n\n        #allocating what they need.\n        # YOUR CODE, YOUR ID\n        #allocating END here\n        #pass\n\n    def TempSafeCheckAfterRelease(self):\n        a=self.avaliable\n    \tb=self.need\n    \tfor i in range(len(b)):\n            if b[i]&lt;a:\n                return True\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # YOUR CODE, YOU ID\n        #check END here\n        \n        #pass\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nprint &#34;!!!!!!!!!&#34;\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n# total_resources = [6, 5, 7, 6]\n# processes=[]\n# b = Bankers(total_resources)\n#\n# max = [\n#     [3, 3, 2, 2],\n#     [1, 2, 3, 4],\n#     [1, 3, 5, 0],\n# ]\n# allocated = [\n#     [1, 2, 2, 1],\n#     [1, 0, 3, 3],\n#     [1, 2, 1, 0],\n# ]\n#\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;\n#\n#\n# total_resources = [10, 10, 8, 5]\n# processes=[]\n# b = Bankers(total_resources)\n# max = [\n#         [10, 8, 2,5],\n#         [6, 1, 3,1],\n#         [3, 1, 4,2],\n#         [5, 4, 2,1]\n#     ]\n# allocated = [\n#         [3, 0, 0,3],\n#         [1, 1, 2,0],\n#         [2, 1, 2,1],\n#         [0, 0, 2,0]\n#     ]\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i6uji18l8j51ob", "no_answer": 1, "created": "2015-05-11T06:45:18Z", "id": "i9jiz0bodq5148", "updated": "2015-05-11T06:45:18Z", "subject": "<p></p>\n<p>裴中煜 2012010685</p>\n<p>李若愚 2012011353</p>\n<p></p>\n<p>共享内存的设计&#xff1a;</p>\n<p>每一个新创建的共享内存对象都用一个shmid_kernel数据结构来表达&#xff0c;该数据结构中保存共享内存的相关信息、占用的内存页面个数、内存页面数组、attaches等信息。系统中所有的shmid_kernel数据结构都保存在shm_segs向量表中&#xff0c;该向量表的每一个元素都是一个指向shmid_kernel数据结构的指针。</p>\n<p>attaches描述被共享的物理内存对象所映射的各进程的虚拟内存区域。每一个希望共享这块内存的进程都必须通过系统调用将其关联&#xff08;attach&#xff09;到它的虚拟内存中。这一过程将为该进程创建了一个新的描述这块共享内存的vm_area_struct数据结构。vm_area_struct用于维系共享内存和使用它的进程之间的关系。</p>\n<p> </p>\n<p>sharememory的不同进程之间的key是约定的。</p>\n<p>首先是shmget的实现&#xff0c;这个函数是用于得到一个共享内存标识符或创建一个共享内存对象并返回共享内存标识符。参数有key&#xff0c;size和shmflg。key是约定的&#xff0c;当shmflg&amp;IPC_CREAT为真时&#xff0c;如果内核中不存在键值与key相等的共享内存&#xff0c;则新建一个共享内存&#xff1b;如果存在这样的共享内存&#xff0c;返回此共享内存的标识符。返回值是共享内存的标识符。</p>\n<p>shmat用于将共享内存区对象映射到调用进程的地址空间。输入为shmid shmaddr shmflg&#xff0c;连接共享内存标识符为shmid的共享内存&#xff0c;连接成功后将共享内存区对象映射到调用进程的地址空间。返回附加好的共享内存地址。</p>\n<p>shmdt函数&#xff0c;输入为shmaddr&#xff0c;用于断开共享内存连接。</p>\n<p>shmctl函数用于实现对共享内存的控制管理。</p>\n<p> </p>\n<p>共享内存的保护&#xff1a;引入信号量保护共享内存&#xff0c;实现同步互斥。</p>\n<p>线程fork的时候&#xff0c;子线程共用父线程的资源。进程fork的时候&#xff0c;fork后子进程继承已连接的共享内存地址。exec后该子进程与已连接的共享内存地址自动脱离(detach)。进程结束后&#xff0c;已连接的共享内存地址会自动脱离(detach)</p>\n<p>由于共享内存作为进程间通信的交互部分&#xff0c;所以完全可以对其进行锁定&#xff0c;使得不能swap换入换出&#xff0c;从而规避由swap引入的相关问题。具体实现交由shmctl函数对共享内存进行控制。控制操作包括获得共享内存对象的状态&#xff0c;设置共享内存对象的参数&#xff08;如uid、gid、mode、ctime等&#xff09;&#xff0c;将共享内存对象在内存中锁定和释放&#xff08;在对象的mode上增加或去除SHM_LOCKED标志&#xff09;&#xff0c;释放共享内存对象资源等。</p>\n<p>共享内存的释放应该是基于引用计数规则&#xff0c;也即每个进程结束对共享内存的访问之后shmdt断开连接&#xff0c;最后一个断开连接的进程负责释放共享内存。</p>\n<p></p>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [{"uid": "i6uji18l8j51ob", "created": "2015-05-11T07:01:49Z", "id": "i9jjk98xkx86y6", "updated": "2015-05-11T07:01:49Z", "subject": "<p></p>\n<p>银行家算法的实现&#xff1a;</p>\n<p>参见<a target=\"_blank\" href=\"https://github.com/BrieflyX/ucore_lab/blob/master/related_info/lab7/deadlock/bankers-homework.py\">https://github.com/BrieflyX/ucore_lab/blob/master/related_info/lab7/deadlock/bankers-homework.py</a></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i6uuk6b68du319", "no_answer": 1, "created": "2015-05-11T06:49:36Z", "id": "i9jj4jorxl6ug", "updated": "2015-05-11T06:49:36Z", "subject": "<p>王轩 2012011369 石伟男2012011367  </p>\n<p></p>\n<p>银行家算法实现&#xff1a;</p>\n<p></p>\n<p>https://github.com/xWang1994/os_exercises/blob/master/all/bankers-homework.py</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}, {"uid": "i7bfvegt8am5ir", "no_answer": 1, "created": "2015-05-11T06:50:44Z", "id": "i9jj6071ce039k", "updated": "2015-05-11T06:50:44Z", "subject": "<p>杨博文 2012011288</p>\n<p>韩慧阳 2012011276</p>\n<p>应杰夫 2012011293</p>\n<p>闵延泽 2012011291</p>\n<p></p>\n<p>alloc_memchat()--&gt;分配一个地址用于进程地址共享通信</p>\n<p>通信地址一定是在堆栈地址以下<br />proc-&gt;chatmem 该进程共享的通信内存地址<br />proc-&gt;chatmem_avali 该进程共享的通信内存地址是否有效</p>\n<p>在进程新建的时候如果新建一个共享地址通信&#xff0c;则调用alloc_memchar()请求一个新的通信地址<br />在fork的时候可以使用父进程parent-&gt;chatmem来给子进程的共享通信地址赋值</p>\n<p>proc-&gt;write_procmsg(char*) 向该进程记录的通信地址写入信息&#xff0c;失败返回0&#xff0c;成功返回写入字符长度<br />proc-&gt;read_procmsg(char*) 从该进程记录的通信地址读取信息&#xff0c;失败返回0&#xff0c;成功返回读取字符长度</p>\n<p>如果在发现有写入消息但是地址不够的情况&#xff0c;则选择一个已占用的地址&#xff0c;通知所有相关的进程修改标记位表示地址已经无效。<br />并使用换入换出替换消息页地址。</p>\n<p>**未想好通知进程<br />**未想好换入换出策略</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}, {"uid": "i6urr6is7yo3jv", "no_answer": 1, "created": "2015-05-11T06:58:33Z", "id": "i9jjg1ilz6v25u", "updated": "2015-05-11T06:58:33Z", "subject": "<p>鲁逸沁 2012011314</p>\n<p>谢晓晖 2012011315</p>\n<p>林子钏 2012011322</p>\n<p>史佳欣 2012011299</p>\n<p></p>\n<p>信号&#xff1a;</p>\n<p>1. 在初始化的时候&#xff0c;在中断&#xff08;例如键盘输入&#xff09;的服务例程中判断某些特殊键组合&#xff08;比如Ctrl-C&#xff09;&#xff0c;识别为一个信号&#xff0c;产生信号号</p>\n<p>2. 维护一个信号号-进程号-地址的表&#xff0c;在一个进程初始化注册的时候&#xff08;比如调用signal&#xff09;&#xff0c;向表中添加信号号、该进程进程号、信号处理函数的首地址</p>\n<p>3. 在系统捕获中断后&#xff0c;识别为信号&#xff0c;查询表&#xff0c;用currect-&gt;pid和信号号查到信号处理函数的地址x</p>\n<p>4. 在用户栈中虚拟出一个函数调用的假象&#xff0c;return address设为进程当前中断的位置</p>\n<p>5. 修改trapframe中的eip设为信号处理函数的x</p>\n<p>6. 中断结束返回用户态后&#xff0c;进程会从x开始执行信号处理函数&#xff0c;处理完信号处理函数&#xff0c;进程会以正常函数调用返回的方式&#xff0c;返回之前中断的位置继续执行</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [{"uid": "i6vuv0mi6uU", "created": "2015-05-11T07:04:05Z", "id": "i9jjn67td713r6", "updated": "2015-05-11T07:04:05Z", "subject": "<p></p><pre>#银行家算法<br />import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = [] \n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j]) \n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # YOUR CODE, YOUR ID\n        for i in range(len(self.need[index])):\n            if self.need[index][i] &gt; self.avaliable[i]:\n                return False\n        #check END here\n\n        #allocating what they need.\n        # YOUR CODE, YOUR ID\n        for i in range(len(self.allocated[index])):\n            self.allocated[index][i] &#43;= self.need[index][i]\n            self.avaliable[i] -= self.need[index][i]\n            self.need[index][i] = 0\n        return True\n        #allocating END here\n        #pass\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # YOUR CODE, YOU ID\n        for i in range(3):\n            find = True\n            for j in range(4):\n                if self.need[i][j] &gt; self.avaliable[j]:\n                    find = False\n            if find :\n                return True\n        return False\n        #check END here\n        #pass\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n# total_resources = [6, 5, 7, 6]\n# processes=[]\n# b = Bankers(total_resources)\n#\n# max = [\n#     [3, 3, 2, 2],\n#     [1, 2, 3, 4],\n#     [1, 3, 5, 0],\n# ]\n# allocated = [\n#     [1, 2, 2, 1],\n#     [1, 0, 3, 3],\n#     [1, 2, 1, 0],\n# ]\n#\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;\n#\n#\n# total_resources = [10, 10, 8, 5]\n# processes=[]\n# b = Bankers(total_resources)\n# max = [\n#         [10, 8, 2,5],\n#         [6, 1, 3,1],\n#         [3, 1, 4,2],\n#         [5, 4, 2,1]\n#     ]\n# allocated = [\n#         [3, 0, 0,3],\n#         [1, 1, 2,0],\n#         [2, 1, 2,1],\n#         [0, 0, 2,0]\n#     ]\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "d-bucket": "Yesterday", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i8o4iar88jf5mz", "no_answer": 1, "created": "2015-05-11T07:07:13Z", "id": "i9jjr792sxw50s", "updated": "2015-05-11T07:07:13Z", "subject": "<p>银行家算法</p>\n<pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = []\n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j])\n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # YOUR CODE, YOUR ID 2012011288\n\tfor i in range(0,len(self.RESOURCE)):\n            if (self.need[index][i] &gt; self.avaliable[i]):\n                return False\n        #check END here\n\n        #allocating what they need.\n        # YOUR CODE, YOUR ID\n\tfor i in range(0,len(self.RESOURCE)):\n            self.allocated[index][i] &#43;= self.need[index][i]\n\t    self.need[index][i] = 0\n        #allocating END here\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # YOUR CODE, YOU ID 2012011288\n\tcou = 0\n\tfor idx in range(len(self.max)):\n\t    if (not self.finished[idx]):\n\t\tflag = True\n\t\tfor i in range(0,len(self.RESOURCE)):\n\t\t    if (self.need[idx][i] &gt; self.available[i]):\n\t\t\tflag = False;\n\t\t    if (flag):\n\t\t\tcou &#43;= 1\n\t\t\tbreak\n\treturn cou &gt;0\n        #check END here\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n# total_resources = [6, 5, 7, 6]\n# processes=[]\n# b = Bankers(total_resources)\n#\n# max = [\n#     [3, 3, 2, 2],\n#     [1, 2, 3, 4],\n#     [1, 3, 5, 0],\n# ]\n# allocated = [\n#     [1, 2, 2, 1],\n#     [1, 0, 3, 3],\n#     [1, 2, 1, 0],\n# ]\n#\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;\n#\n#\n# total_resources = [10, 10, 8, 5]\n# processes=[]\n# b = Bankers(total_resources)\n# max = [\n#         [10, 8, 2,5],\n#         [6, 1, 3,1],\n#         [3, 1, 4,2],\n#         [5, 4, 2,1]\n#     ]\n# allocated = [\n#         [3, 0, 0,3],\n#         [1, 1, 2,0],\n#         [2, 1, 2,1],\n#         [0, 0, 2,0]\n#     ]\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}, {"uid": "i7bfvegt8am5ir", "no_answer": 1, "created": "2015-05-11T07:07:45Z", "id": "i9jjrvtfid87k5", "updated": "2015-05-11T07:07:45Z", "subject": "<p> 韩慧阳 2012011276</p>\n<p>银行家算法</p>\n<pre>import os\nimport random\nimport numpy as np\nimport itertools\n\nclass Bankers(object):\n    def __init__(self, totalResource):\n        #initiating\n        self.RESOURCE = totalResource\n\n    def SignProcesses(self, max_, allocated_):\n        self.max = max_\n        self.allocated = allocated_\n        self.need = self.CalcNeed()\n        self.avaliable = self.CalcAvaliable()\n        self.finished = [False]*len(self.allocated)\n\n    def Difference(self,a,b):\n        #return matrix subtracted from a by b\n        res = []\n        for i in range(len(a)):\n            tmp = []\n            for j in range(len(a[i])):\n                tmp.append(a[i][j]-b[i][j])\n            res.append(tmp)\n        return res\n\n    def CalcNeed(self):\n        #calc request by subtracting signed matrix from max matrix\n        return self.Difference(self.max,self.allocated)\n\n    def CalcAvaliable(self):\n        &#34;&#34;&#34;Calc Avaliable Resource&#34;&#34;&#34;\n        a = self.allocated\n        res = []\n        for j in range(len(a[0])):\n            tmp = 0\n            for i in range(len(a)):\n                tmp &#43;= a[i][j]\n            res.append(self.RESOURCE[j] - tmp)\n        return res\n\n    def ExecuteProcess(self,index):\n\n        #check if less avaliable than Request\n        # YOUR CODE, 2012011276\n\t\t\n\t\tflag = True\n\t\tfor i in range(len(self.need[index])):\n\t\t\tif self.need[index][i] &gt; self.avaliable[i]:\n\t\t\t\tflag = False\n\t\t\t\tbreak\n        #check END here\n\n        #allocating what they need.\n        # YOUR CODE, 2012011276\n\t\tfor i in range(len(self.need[index])):\n\t\t\tself.allocated[index][i] &#43;= self.need[index][i];\n\t\t\tself.avaliable[i] -= self.need[index][i]\n\t\t\tself.need[index][i] = 0\n\t\t\n        #allocating END here\n\n    def TempSafeCheckAfterRelease(self):\n        #check if at least one request can be done after previous process done. not check whole sequances.\n        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n        # YOUR CODE, 2012011276\n\n\tflag = False\n\tfor idx in range(len(self.max)):\n\t\tfor i in range(len(self.max[idx])):\n\t\t\tif (self.allocated[idx][i] &lt; self.max[idx][i]):\n\t\t\t\tflag = True\n\t\t\t\tbreak;\n\t\tif flag:\n\t\t\tbreak\n\t\n        return flag\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n        pass\n\n    def print_matrixes(self):\n        print &#34;_____________________________________________&#34;\n        print &#34;MAX\\t\\tAllocated\\tNeed&#34;\n        for idx in range(len(self.max)):\n            print &#34;%s\\t%s\\t%s&#34; % (self.max[idx],self.allocated[idx], self.need[idx])\n        print &#34;_____________________________________________&#34;\n        print &#34;Resources:&#34;\n        print &#34;Total: %s\\tAvailable: %s\\n&#34; % (self.RESOURCE, self.avaliable)\n\n    def ReleasingProcess(self,index):\n        for i in range(0,len(self.RESOURCE)):\n            self.finished[index] = True\n            self.allocated[index][i] = 0\n        self.avaliable = self.CalcAvaliable()\n\n    def Execute(self):\n        i = 0\n        # get all permutation of processes\n        perm = itertools.permutations(range(procnum), procnum)\n        permArray = np.asarray(list(perm))\n\n        for arr in permArray:\n            for i in arr:\n                if self.finished[i] == False:\n                    print &#34;Executing...&#34;\n                    print &#34;Request: &#34;\n                    print self.need[i]\n                    #check if less avaliable than Request\n                    if self.ExecuteProcess(i):\n                        print &#34;Dispatching Done...&#34;\n\n                        self.print_matrixes()\n\n                        print &#34;-----Releasing Process------&#34;\n\n                        self.ReleasingProcess(i)\n\n                        self.print_matrixes()\n\n                        #check if at least one request can be done after previous process done. not check whole sequances.\n                        #if every element of Requests can&#39;t accepted after previous process done, this mean it is not safe state\n                        if not (self.TempSafeCheckAfterRelease()):\n                            print &#34;SAFE STATE: NOT SAFE - There are no sequances can avoid Deadlock&#34;\n                            return False\n                        processes.append(i)\n                    else:\n                        print &#34;HOLD: not enough Resource&#34;\n\n                if i == len(self.allocated)-1:\n                    i = 0\n                else:\n                    i &#43;= 1\n\n                check = True\n                for k in range(0,len(self.allocated)):\n                    if self.finished[k] == False:\n                        check = False\n                        break\n                if check == True:\n                    return True\n                    break\n        #every permutation of processes is false\n        return False\n\ndef getmax():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain_max=0\n            if j &gt;0:\n                remain_max=total_resources[i]\n                for k in range(j):\n                    remain_max=remain_max-res[k][i]\n                if remain_max &lt; 0:\n                    remain_max=0\n            else:\n                remain_max=total_resources[i]\n            tmp.append((int)(randnum*remain_max*0.8))\n        res.append(tmp)\n    return res\n\ndef getallocated():\n    res = []\n    for j in range(procnum):\n        tmp = []\n        for i in range(len(total_resources)):\n            randnum=random.random()\n            remain=0\n            if j &gt;0:\n                remain=max[j][i]\n                for k in range(j):\n                    remain=remain-res[k][i]\n                if remain &lt; 0:\n                    remain=0\n            else:\n                remain=max[j][i]\n            tmp.append((int)(randnum*remain))\n        res.append(tmp)\n    return res\n\nprint &#34;start here&#34;\n# random seed\nseed = 2\nrandom.seed(seed)\n# the number of process list\nprocnum = 3\n# the number of type of resource\nresnum =  4\n# the max total value of resource\nrestotalval = 30\n# the total resources list\ntotal_resources=[]\n# the total processes\nprocesses=[]\n# set the real total value of resource in total_resources\nfor i in range(resnum):\n    total_resources.append((int)(restotalval*random.random()))\n# init the Banker\nb = Bankers(total_resources)\n# get the max request values of resources from process\nmax=getmax()\n# get the already gotted values of resources from process\nallocated=getallocated()\n# init need matrix, available vector\nb.SignProcesses(max, allocated)\n# print all theses matrixes\nb.print_matrixes()\n# executing Banker algorithm\nresult=b.Execute()\n# show results\nif result:\n    print &#34;SUCCESS proc lists &#34;,processes\nelse:\n    print &#34;Failed&#34;\n\n# total_resources = [6, 5, 7, 6]\n# processes=[]\n# b = Bankers(total_resources)\n#\n# max = [\n#     [3, 3, 2, 2],\n#     [1, 2, 3, 4],\n#     [1, 3, 5, 0],\n# ]\n# allocated = [\n#     [1, 2, 2, 1],\n#     [1, 0, 3, 3],\n#     [1, 2, 1, 0],\n# ]\n#\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;\n#\n#\n# total_resources = [10, 10, 8, 5]\n# processes=[]\n# b = Bankers(total_resources)\n# max = [\n#         [10, 8, 2,5],\n#         [6, 1, 3,1],\n#         [3, 1, 4,2],\n#         [5, 4, 2,1]\n#     ]\n# allocated = [\n#         [3, 0, 0,3],\n#         [1, 1, 2,0],\n#         [2, 1, 2,1],\n#         [0, 0, 2,0]\n#     ]\n# b.SignProcesses(max, allocated)\n# b.print_matrixes()\n# result=b.Execute()\n# if result:\n#     print &#34;SUCCESS proc lists &#34;,processes\n# else:\n#     print &#34;Failed&#34;</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}, {"uid": "i718aanx0OS", "no_answer": 1, "created": "2015-05-11T07:14:01Z", "id": "i9jjzxe3tab1tw", "updated": "2015-05-11T07:14:01Z", "subject": "<p>2012011359 路云飞</p>\n<p>https://github.com/december/os_exercises/blob/master/all/08-1-spoc-discussion.md</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}, {"uid": "i6rwsr9cEcQ", "no_answer": 1, "created": "2015-05-11T09:34:22Z", "id": "i9jp0f6tcbi6cs", "updated": "2015-05-11T09:34:22Z", "subject": "<p>2012011382 李浩达</p>\n<p>https://git.net9.org/lihaoda/os_exercise/blob/master/all/bankers_hw.py</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}], "type": "note", "unique_views": 70, "created": "2015-05-11T06:18:09Z", "id": "i9ji03253u64wb", "tags": ["instructor-note", "课堂问答"], "nr": 412, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {}, "folders": ["课堂问答"], "bucket_order": 2, "change_log": [{"uid": "hcrrjuyequh4bt", "when": "2015-05-11T06:18:09Z", "data": "i9ji0329x7u4wc", "anon": "no", "type": "create"}, {"uid": "i6vi7mt1I4G", "when": "2015-05-11T06:18:56Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i7oaxkxhxjo3ui", "when": "2015-05-11T06:20:49Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6tezdpdQbq", "when": "2015-05-11T06:21:31Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i7bg4v1keqE", "when": "2015-05-11T06:22:10Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6t7mzhbhwF", "when": "2015-05-11T06:23:36Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i7bfq2txxyw689", "when": "2015-05-11T06:24:46Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6sl02qfUgI", "when": "2015-05-11T06:28:34Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i6utvrywozd2vd", "when": "2015-05-11T06:29:01Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6uswob7jl4242", "when": "2015-05-11T06:29:04Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6t7mzhbhwF", "when": "2015-05-11T06:31:24Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i6ut6cjo5lj4aa", "when": "2015-05-11T06:33:42Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6uji18l8j51ob", "when": "2015-05-11T06:45:18Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i7bq1v7feay2z9", "when": "2015-05-11T06:48:42Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i6uuk6b68du319", "when": "2015-05-11T06:49:36Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i7bfvegt8am5ir", "when": "2015-05-11T06:50:45Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6tezdpdQbq", "when": "2015-05-11T06:53:13Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i6sl02qfUgI", "when": "2015-05-11T06:54:00Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i6urr6is7yo3jv", "when": "2015-05-11T06:58:33Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6uji18l8j51ob", "when": "2015-05-11T07:01:49Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i6vuv0mi6uU", "when": "2015-05-11T07:04:05Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i8o4iar88jf5mz", "when": "2015-05-11T07:07:13Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i7bfvegt8am5ir", "when": "2015-05-11T07:07:45Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6uak1ivjzr1i0", "when": "2015-05-11T07:10:33Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i718aanx0OS", "when": "2015-05-11T07:14:01Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}, {"uid": "i6utvrywozd2vd", "when": "2015-05-11T07:18:34Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i6t7mzhbhwF", "when": "2015-05-11T07:22:00Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i6tawpo5Fm8", "when": "2015-05-11T07:33:09Z", "to": "i9ji03253u64wb", "anon": "no", "type": "feedback"}, {"uid": "i6rwsr9cEcQ", "when": "2015-05-11T09:34:22Z", "to": "i9ji03253u64wb", "anon": "no", "type": "followup"}], "bucket_name": "Today", "request_instructor_me": false, "no_answer_followup": 16, "num_favorites": 2, "tag_good": []}}