{"aid": "j21zvta7p3i1hi", "result": {"status": "active", "unique_views": 88, "request_instructor_me": false, "change_log": [{"data": "i9cbr3d1iv42if", "anon": "no", "when": "2015-05-06T05:48:48Z", "uid": "hcrrjuyequh4bt", "type": "create"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T06:40:16Z", "uid": "i6t1byqz5dE", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T06:40:55Z", "uid": "i6xgf2t8N7w", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:01:13Z", "uid": "i7013x05eSl", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:01:36Z", "uid": "i6uak1ivjzr1i0", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:02:04Z", "uid": "i6ut1sgpijq", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:02:34Z", "uid": "i7bfq2txxyw689", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:03:41Z", "uid": "i7bfvegt8am5ir", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:03:42Z", "uid": "i6ur9e69wzy61w", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:03:49Z", "uid": "i6t7bfshA1d", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:03:53Z", "uid": "i6vi7mt1I4G", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:05:36Z", "uid": "i6unpz8nUza", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:05:58Z", "uid": "i6vuv0mi6uU", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:06:52Z", "uid": "i6ugdh143r52f9", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:06:57Z", "uid": "i6urr6is7yo3jv", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:07:03Z", "uid": "i6t7bfshA1d", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:07:03Z", "uid": "i6utvrywozd2vd", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:07:22Z", "uid": "i6t7mzhbhwF", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:08:05Z", "uid": "i8o4iar88jf5mz", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:08:25Z", "uid": "i71ev8heKQi", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:13:15Z", "uid": "i6tawpo5Fm8", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:14:05Z", "uid": "i6uswob7jl4242", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:20:31Z", "uid": "i7bq1v7feay2z9", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:22:26Z", "uid": "i7w0q2p8Cmz", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:45:22Z", "uid": "i6vi7mt1I4G", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:45:57Z", "uid": "i6uji18l8j51ob", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T07:51:46Z", "uid": "i6vi7mt1I4G", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T08:18:06Z", "uid": "i7013x05eSl", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T09:03:55Z", "uid": "i6utvrywozd2vd", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T09:45:18Z", "uid": "i718mp903qx", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T12:26:03Z", "uid": "i6uak1ivjzr1i0", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T12:38:54Z", "uid": "i6ugdh143r52f9", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T14:29:41Z", "uid": "i718aanx0OS", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T15:13:02Z", "uid": "i6rwsr9cEcQ", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-05-06T17:02:54Z", "uid": "i6urm1j1ynv6sm", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-06-03T12:42:50Z", "uid": "i8o4iar88jf5mz", "type": "followup"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-06-03T12:43:58Z", "uid": "i8o4iar88jf5mz", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2015-06-03T15:14:06Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2016-04-28T09:59:52Z", "uid": "i0nyfgp2bbqig", "type": "feedback"}, {"data": "inkdq556ty21to", "anon": "no", "when": "2016-04-28T14:22:05Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2016-04-28T14:24:23Z", "uid": "hdjonbiyfs62ie", "type": "feedback"}, {"to": "i9cbr3czbdw2ie", "anon": "no", "when": "2017-04-28T08:35:38Z", "type": "followup", "uid": "i7bgifux1OH"}], "upvote_ids": [], "id": "i9cbr3czbdw2ie", "bookmarked": 32, "tags": ["instructor-note", "lecture18", "课堂问答"], "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2015-05-06T06:40:16Z", "no_upvotes": 0, "uid": "i6t1byqz5dE", "created": "2015-05-06T06:40:16Z", "type": "followup", "no_answer": 1, "id": "i9cdl9w94db5rs", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>石伟男 2012011367</p>\n<p>题目&#xff1a;</p>\n<p>在一个盒子里&#xff0c;混装了数量相等的黑白围棋子·现在用自动分拣系统把黑子、白子分开&#xff0c;设分拣系统有二个进程P1 和P2 &#xff0c;其中P1 拣白子&#xff1b;P2 拣黑子。规定每个进程每次拣一子&#xff1b;当一个进程在拣时&#xff0c;不允许另一个进程去拣&#xff1b;当一个进程拣了一子时&#xff0c;必须让另一个进程去拣&#xff0e;试写出两进程P1 和P2 能并发正确执行的程序。</p>\n<p>用信号量实现</p>\n<pre>import threading\ntotnum = 10\nwhitenum = totnum\nblacknum = totnum\n\ndef pick_black():\n    global blacknum    \n    while (blacknum &gt;0):\n        black.acquire()\n        blacknum -= 1\n        print &#34;pick one black,rest:%d&#34; %blacknum\n        white.release()\n\ndef pick_white():\n    global whitenum    \n    while (whitenum &gt;0):\n        white.acquire()\n        whitenum -= 1\n        print &#34;pick one white,rest:%d&#34; %whitenum\n        black.release()\n\nif __name__ == &#39;__main__&#39;:    \n    black = threading.Semaphore(1)\n    white = threading.Semaphore(0)\n    thread1 = threading.Thread(target=pick_black)\n    thread2 = threading.Thread(target=pick_white)\n    thread1.start()\n    thread2.start()\n    thread1.join()\n    thread2.join()</pre>\n<p>用条件变量实现</p>\n<pre>import threading<br />totnum = 10<br />whitenum = totnum<br />blacknum = totnum<br /><br />def pick_black():<br />    global blacknum  <br />    global turn <br />    while (blacknum &gt;0):<br />        cond.acquire()<br />        if (turn == 1):<br />            cond.wait()<br />        blacknum -= 1<br />        print &#34;pick one black,rest:%d&#34; %blacknum<br />        turn = 1<br />        cond.notify()<br />        cond.release()<br /><br />def pick_white():<br />    global whitenum<br />    global turn<br />    while (whitenum &gt;0):<br />        cond.acquire()<br />        if (turn == 0):<br />            cond.wait()<br />        whitenum -= 1<br />        print &#34;pick one white,rest:%d&#34; %whitenum<br />        turn = 0<br />        cond.notify()<br />        cond.release()<br /><br />if __name__ == &#39;__main__&#39;:    <br />    cond = threading.Condition()<br />    turn = 0<br />    thread1 = threading.Thread(target=pick_black)<br />    thread2 = threading.Thread(target=pick_white)<br />    thread1.start()<br />    thread2.start()<br />    thread1.join()<br />    thread2.join()</pre>"}, {"folders": [], "updated": "2015-05-06T06:40:55Z", "no_upvotes": 0, "uid": "i6xgf2t8N7w", "created": "2015-05-06T06:40:55Z", "type": "followup", "no_answer": 1, "id": "i9cdm41g4823bd", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "计21战裕隆 2012011388\n第18题\nhttps://github.com/zhanyl12/os_exercises/blob/master/all/07-2-spoc-pv-problems.md"}, {"folders": [], "updated": "2015-05-06T07:01:13Z", "no_upvotes": 0, "uid": "i7013x05eSl", "created": "2015-05-06T07:01:13Z", "type": "followup", "no_answer": 1, "id": "i9cec7yqy7q24v", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [{"folders": [], "updated": "2015-05-06T08:18:06Z", "uid": "i7013x05eSl", "created": "2015-05-06T08:18:06Z", "type": "feedback", "id": "i9ch33hy7hg55f", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>条件变量实现</p>\n<pre>import threading\nimport random\nimport time\n\ncondition = threading.Condition()\nbusStatus = &#34;&#34;\n\nclass Driver(threading.Thread):\n    def __init__(self,threadName):\n        threading.Thread.__init__(self,name=threadName)\n        self.sleepTime = random.randrange(1,6)\n\n    def run(self):\n        global condition, busStatus\n        while True:\n            if condition.acquire():\n                if busStatus == &#34;Start&#34;:\n                    print &#34;Driver: bus start running&#34;\n                    busStatus = &#34;Running&#34;\n                    time.sleep(self.sleepTime)\n                    print &#34;Driver: bus stop&#34;\n                    busStatus = &#34;Stop&#34;\n                    time.sleep(self.sleepTime)\n                    condition.notify()\n                elif busStatus == &#34;doorOpened&#34;:\n                    time.sleep(self.sleepTime)\n                    print &#34;Driver: door not closed, waiting.&#34;\n                    condition.wait()\n                condition.release()\n\nclass Conductor(threading.Thread):\n    def __init__(self,threadName):\n        threading.Thread.__init__(self,name=threadName)\n        self.sleepTime = random.randrange(1,6)\n\n    def run(self):\n        global condition, busStatus\n        while True:\n            if condition.acquire():\n                if busStatus == &#34;Stop&#34;:\n                    print &#34;Conductor: Bus stopped, open the door,passenger on and off&#34;\n                    busStatus = &#34;doorOpened&#34;\n                    time.sleep(self.sleepTime)\n                    print &#34;Conductor: close the door,sell tickets&#34;\n                    busStatus = &#34;Start&#34;\n                    time.sleep(self.sleepTime)\n                    condition.notify()\n                elif busStatus == &#34;Running&#34;:\n                    time.sleep(self.sleepTime)\n                    print &#34;Condutor: bus not stopped, cannot open the door.&#34;\n                    condition.wait()\n                condition.release()\n\nif __name__ == &#39;__main__&#39;:\n    busStatus = &#34;Start&#34;  \n    Driver(&#34;driver&#34;).start()\n    Conductor(&#34;conductor&#34;).start()</pre>\n<p></p>"}], "subject": "<p>计23班 谢晓晖 2012011315</p>\n<p>第17题</p>\n<p>设公共汽车上&#xff0c;司机和售票员的活动分别如下&#xff1a;司机的活动&#xff1a;启动车辆&#xff1a;正常行车&#xff1b;到站停车。售票员的活动&#xff1a;关车门&#xff1b;售票&#xff1b;开车门。在汽车不断地到站、停车、行驶过程中&#xff0c;这两个活动有什么同步关系&#xff1f;用信号量和P 、V 操作实现它们的同步。<br /> 在汽车行驶过程中&#xff0c;司机活动与售票员活动之间的同步关系为&#xff1a;售票员关车门后&#xff0c;向司机发开车信号&#xff0c;司机接到开车信号后启动车辆&#xff0c;在汽车正常行驶过程中售票员售票&#xff0c;到站时司机停车&#xff0c;售票员在车停后开门让乘客上下车。因此&#xff0c;司机启动车辆的动作必须与售票员关车门的动作取得同步&#xff1b;售票员开车门的动作也必须与司机停车取得同步。应设置两个信号量&#xff1a;S1 、S2 ; <br /> · S1表示是否允许司机启动汽车&#xff08;其初值为0 )<br /> · S2表示是否允许售票员开门&#xff08;其初值为0 &#xff09;<br /><br /></p>\n<p>【实现如下】</p>\n<p>用信号量实现</p>\n<pre>#coding=utf-8\nimport threading \nimport random\nimport time\n\nclass driverThread(threading.Thread):\n\tdef __init__(self,threadName,semaphore1,semaphore2):\n\t\tthreading.Thread.__init__(self,name=threadName)  \n\t\tself.sleepTime=random.randrange(1,6)  \n\t\t#set the semaphore as a data attribute of the class  \n\t\tself.threadSemaphore1 = semaphore1\n\t\tself.threadSemaphore2 = semaphore2\n\tdef run(self):\n\t\twhile True:\n\t\t\tself.threadSemaphore1.acquire() \n\t\t\tprint &#34;bus start running&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;bus is running&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;bus stop running&#34;\n\t\t\tself.threadSemaphore2.release()\n\n\nclass conductorThread(threading.Thread):\n\tdef __init__(self,threadName,semaphore1,semaphore2):\n\t\tthreading.Thread.__init__(self,name=threadName)  \n\t\tself.sleepTime=random.randrange(1,6)  \n\t\t#set the semaphore as a data attribute of the class  \n\t\tself.threadSemaphore1 = semaphore1\n\t\tself.threadSemaphore2 = semaphore2\n\tdef run(self):\n\t\twhile True:\n\t\t\tprint &#34;close the bus door&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tself.threadSemaphore1.release() \n\t\t\tprint &#34;sale ticket&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tself.threadSemaphore2.acquire()\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;open the bus door&#34;\n\t\t\ttime.sleep(self.sleepTime) \n\t\t\tprint &#34;passenger on and off&#34;\n\n\n\nthreadSemaphore1=threading.Semaphore(0)\nthreadSemaphore2=threading.Semaphore(0)\ndriver_thread = driverThread(&#34;driver&#34;,threadSemaphore1,threadSemaphore2)\nconductor_thread = conductorThread(&#34;conductor&#34;,threadSemaphore1,threadSemaphore2)\ndriver_thread.start()\nconductor_thread.start()\n\n</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:01:36Z", "no_upvotes": 0, "uid": "i6uak1ivjzr1i0", "created": "2015-05-06T07:01:36Z", "type": "followup", "no_answer": 1, "id": "i9cecpu2kv059u", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [{"folders": [], "updated": "2015-05-06T12:26:03Z", "uid": "i6uak1ivjzr1i0", "created": "2015-05-06T12:26:03Z", "type": "feedback", "id": "i9cpxyipfo218x", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>用信号量实现</p>\n<pre>import threading\nimport random\nimport time\n\nclass semDriver(threading.Thread):\n    def __init__(self, sem1, sem2):\n        threading.Thread.__init__(self)\n        self.busStartSem = sem1\n        self.doorOpenSem = sem2\n\n    def run(self):\n        while True:\n            self.busStartSem.acquire()\n            print &#39;Driver start the bus and run.&#39;\n            sleepTime = random.randrange(1,5)\n            time.sleep(sleepTime)\n            print &#39;Driver stop the bus after time %s&#39; %(sleepTime)\n            self.doorOpenSem.release()\n\n\nclass semConductor(threading.Thread):\n    def __init__(self, sem1, sem2):\n        threading.Thread.__init__(self)\n        self.busStartSem = sem1\n        self.doorOpenSem = sem2\n\n    def run(self):\n        while True:\n            self.doorOpenSem.acquire()\n            print &#39;Conductor open the door.&#39;\n            sleepTime = random.randrange(1,5)\n            time.sleep(sleepTime)\n            print &#39;Conductor close the door after time %s&#39; %(sleepTime)\n            self.busStartSem.release()\n\n\nbusRunningSem = threading.Semaphore(1)   #At first, the driver can start the bus\nbusOpenDoorSem = threading.Semaphore(0)   #At first, the conductor can&#39;t open the door\ndriver = semDriver(busRunningSem, busOpenDoorSem)\nconductor = semConductor(busRunningSem, busOpenDoorSem)\ndriver.start()\nconductor.start()</pre>\n<p></p>"}], "subject": "<p>计22 徐天宇 2012011275</p>\n<p>32.公交车问题(2002) 在一辆公共汽车上&#xff0c;司机和售票员各行其职&#xff0c;司机负责开车和到站停车&#xff1b;售票员负责售票和开、关门&#xff0c;当售票员关好车门后&#xff0c;司机才能继续开车行驶。试用P、V操作实现司机与售票员之间的同步。</p>\n<p>用条件变量实现&#xff1a;</p>\n<pre>import threading\nimport random\nimport time\n\ncondition = threading.Condition()\nbusStatus = &#39;canGo&#39; #At first, the driver can start the bus ,so the conductor can&#39;t open the door.\n\nclass conditionBusDriver(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self,name=&#39;Driver&#39;)\n        self.sleepTime = random.randrange(1,5)\n\n    def run(self):\n        global condition, busStatus\n        while True:\n            if condition.acquire():\n                if busStatus == &#39;canGo&#39;:\n                    print &#39;Driver: Door closed, bus can go.&#39;\n                    busStatus = &#39;Running&#39;\n                    time.sleep(self.sleepTime)\n                    print &#39;Driver: Bus stopped after running for time %s.&#39; %(self.sleepTime)\n                    busStatus = &#39;canOpenDoor&#39;\n                    condition.notify()\n                elif busStatus == &#39;doorOpened&#39;:\n                    print &#39;Driver: Door not closed, waiting.&#39;\n                    condition.wait()\n                condition.release()\n\n\n\nclass conditionBusConductor(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self,name=&#39;Conductor&#39;)\n        self.sleepTime = random.randrange(1,5)\n\n    def run(self):\n        global condition, busStatus\n        while True:\n            if condition.acquire():\n                if busStatus == &#39;canOpenDoor&#39;:\n                    print &#39;Conductor: Bus stopped, open the door.&#39;\n                    busStatus = &#39;doorOpened&#39;\n                    time.sleep(self.sleepTime)\n                    print &#39;Conductor: Open the door for time %s, then close the door.&#39; %(self.sleepTime)\n                    busStatus = &#39;canGo&#39;\n                    condition.notify()\n                elif busStatus == &#39;Running&#39;:\n                    print &#39;Condutor: Bus not stopped, can\\&#39;t open the door.&#39;\n                    condition.wait()\n                condition.release()\n\nif __name__ == &#39;__main__&#39;:\n    d = conditionBusDriver()\n    d.start()\n    c = conditionBusConductor()\n    c.start()</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:02:04Z", "no_upvotes": 0, "uid": "i6ut1sgpijq", "created": "2015-05-06T07:02:04Z", "type": "followup", "no_answer": 1, "id": "i9cedbh952p2bq", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>计21  王振 2012011397</p>\n<p>题目</p>\n<p>37.招聘问题 现有100名毕业生去甲、乙两公司求职&#xff0c;两公司合用一间接待室&#xff0c;其中甲公司招 收10 人&#xff0c;乙公司准备招收10人&#xff0c;招完为止。两公司各有一位人事主管在接待毕业生&#xff0c; 每位人事主管每次只可接待一人&#xff0c;其他毕业生在接待室外排成一个队伍等待。试用信 号量和P 、v 操作实现人员招聘过程.</p>\n<p>还没完成,下午继续完善.</p>\n<p></p>\n<p>var Sa,Sb,mutex:semaphore;<br />Sa:=Sb:=mnutex:=1;<br />C1,C2,K1,K2&#xff1a;integer;<br />C1:=C2:=K1:=K2:=0;<br />cobegin<br /> process 甲公司<br /> begin<br /> L1: P(mutex);<br /> P(Sa);<br /> C1:==C1&#43;1 ;<br /> V(Sa);<br /> If C1≤100 then<br /> &#xff5b;<br /> 从标识为B 且不为Sn 或<br /> 无标识的毕业生队列中选<br /> 第i 个学生&#xff0c;将学生i 标<br /> 识为A 和Sm<br /> &#xff5d;<br /> V(mutex) ;<br /> 面试&#xff1b;<br /> P(mutex);<br /> if 合格then<br /> {<br /> K1:=K1&#43;1;<br /> if 学生i 的标识不含B then<br /> {<br /> P (Sb);<br /> C2:=C2&#43;1;<br /> V(Sb);<br /> 将学生i 从队列摘除&#xff1b;<br /> }<br /> else 将学生i 从队列摘除&#xff1b;<br /> }<br /> else if 学生i 的标识含B then<br /> 将学生i 从队列摘除;<br /> else<br /> 取消学生i 的Sm 标识&#xff1b;<br /> V(mutex);<br /> If(K1&lt;10)&amp;(C2&lt;100) then<br /> goto L1;<br />end</p>\n<p>process 乙公司<br />begin<br /> L2:P(mutex);<br /> P(Sb);<br /> C2:=C2&#43;1;<br /> V(Sb);<br /> if C2≤100 then<br /> 从标识为A 且不为sm 或无标识的<br /> 毕业生队列中选第i个学生将学生i<br /> 标识为B和Sn<br /> V(mutex);<br /> 面试&#xff1b;<br /> P(mutex);<br /> if 合格then<br /> {<br /> K2:=K2&#43;1;<br /> if 学生i 的标识不含A then<br /> {<br /> P(Sa)<br /> C1:=C1&#43;1;<br /> V(Sa);<br /> 将学生i 从队列摘除&#xff1b;<br /> }<br /> else 将学生i 从队列摘除&#xff1b;<br /> }<br /> else if 学生i 的标识含A then<br /> 将学生i 从队列摘除&#xff1b;<br /> else<br /> 取消学生i 的Sn 标识&#xff1b;<br /> V(mutex);<br /> if(K2&lt;10)&amp;(c1&lt;100&#xff09;then<br /> goto L2;<br />end<br />coend</p>"}, {"folders": [], "updated": "2015-05-06T07:02:34Z", "no_upvotes": 0, "uid": "i7bfq2txxyw689", "created": "2015-05-06T07:02:34Z", "type": "followup", "no_answer": 1, "id": "i9cedygmrac67m", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>覃伟 2012011278 计22</p>\n<p></p>\n<p>题目&#xff1a;33</p>\n<p>打印机问题<br />设系统中有5台类型相同的打印机&#xff0c;依次编号为1&#xff5e;5。又设系统中有n个使用打印机的进程&#xff0c;使用前申请&#xff0c;使用后释放。每个进程有一个进程标识&#xff0c;用于区别不同的进程。每个进程还有一个优先数&#xff0c;不同进程的优先数各异。当有多个进程同时申请时&#xff0c;按照进程优先数由高到低的次序实施分配。试用信号灯和PV操作实现对于打印机资源的管理&#xff0c;即要求编写如下函数和过程:<br />(1)函数require(pid&#xff0c;pri): 申请一台打印机。参数pid为进程标识&#xff0c;其值为1到n的整数; pri为进程优先数&#xff0c;其值为正整数; 函数返回值为所申请到打印机的编号&#xff0c;其值为1到5的整数;<br />(2)过程return(prnt): 释放一台打印机。参数prnt为所释放打印机的编号&#xff0c;其值为1到5的整数。</p>\n<p></p>\n<p>实现了semaphore与condition。</p>\n<p>代码连接&#xff1a;https://github.com/qw540232188/ucore_lab/tree/master/related_info/lab7/semaphore_condition/20150506spoc</p>"}, {"folders": [], "updated": "2015-05-06T07:03:41Z", "no_upvotes": 0, "uid": "i7bfvegt8am5ir", "created": "2015-05-06T07:03:41Z", "type": "followup", "no_answer": 1, "id": "i9cefe9kftr6wb", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>韩慧阳 2012011276</p>\n<p>第十三题&#xff1a;</p>\n<ol><li>\n<p>银行有n个柜员,每个顾客进入银行后先取一个号,并且等着叫号,当一个柜员空闲后,就叫下一个号.</p>\n<pre>&lt;code&gt;将顾客号码排成一个队列,顾客进入银行领取号码后,将号码由队尾插入;柜员空闲\n时,从队首取得顾客号码,并且为这个顾客服务,由于队列为若干进程共享, 所以需要互\n斥.柜员空闲时,若有顾客,就叫下一个顾客为之服务.因此,需要设置一个信号量来记录等\n待服务的顾客数.\nbegin\nvar mutex=1,customer_count=0:semaphore;\ncobegin\nprocess customer\nbegin\nrepeat\n取号码&#xff1b;\np(mutex);\n进入队列&#xff1b;\nv(mutex);\nv(customer_count);\nend\nprocess serversi(i=1,...,n)\nbegin\nrepeat\np(customer_count);\np(mutex);\n从队列中取下一个号码&#xff1b;\nv(mutex);\n为该号码持有者服务&#xff1b;\nend&lt;/code&gt;\n</pre>\n用信号量实现&#xff08;还在调&#xff09;&#xff1a;用条件变量还没实现\n<pre>import threading\n\nmutex = 0\ncustomer_count = 0\nthread_list = list() \n\ndef thread_fun(num):  \n    for n in range(0, int(num)):  \n        print &#34; I come from %s, num: %s&#34; %( threading.currentThread().getName(), n)\n\t\tcustomer(self)\n\t\ndef p(num):\n\tif num &gt; 0:\n\t\tint(num) --\n\t\t\t\ndef v(num):\n\tint(num) &#43;&#43;\n\ndef service(int, threading.Thread):\n\tprint &#34;table %d serve thread %s&#34; %(table, threading.Thread.getName())\n\t\ndef customer(threading.Thread):\n\tself.setName(self.name)  \n\tp(mutex)\n\tservice(self)\n\tv(mutex)\n\tv(customer_count)\n\ndef service(num):\n\tfor i in range(0, int(num)):\n\t\tp(customer_count);\n\t\tp(mutex)\n\t\tcustomer = thread_list.pop()\n\t\tv(mutex)\n\t\tservice(i, customer)\n\tend\ndef main(n, c_num):\n\tfor i in range(0, c_num):\n\t\tthread_list.append(threading.Thread(target = thread_fun, name = string(i), args = (int(c_num),))</pre>\n</li></ol>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:03:42Z", "no_upvotes": 0, "uid": "i6ur9e69wzy61w", "created": "2015-05-06T07:03:42Z", "type": "followup", "no_answer": 1, "id": "i9ceff37kic37g", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [{"folders": [], "updated": "2016-04-28T09:59:52Z", "uid": "i0nyfgp2bbqig", "created": "2016-04-28T09:59:52Z", "type": "feedback", "id": "ink4cx1wlu727z", "anon": "no", "bucket_name": "Week 4/24 - 4/30", "config": {}, "bucket_order": 57, "data": null, "children": [], "subject": "<p>许孝先 2013011423    张建业 2013011419</p>\n<p>https://github.com/xuxx13/XUXX/blob/master/Guoqiao.py</p>"}, {"folders": [], "updated": "2016-04-28T14:24:23Z", "uid": "hdjonbiyfs62ie", "created": "2016-04-28T14:24:23Z", "type": "feedback", "id": "inkdt3a2wcqyp", "anon": "no", "bucket_name": "Week 4/24 - 4/30", "config": {}, "bucket_order": 57, "data": null, "children": [], "subject": "<p>你们交错地方了。这是去年的提交处。</p>"}], "subject": "<p><strong>计21班 杨俊  2012011400</strong></p>\n<p>一座小桥(最多只能承重两个人)横跨南北两岸&#xff0c;任意时刻同一方向只允许一人过桥&#xff0c;南侧桥段和北侧桥段较窄只能通过一人&#xff0c;桥中央一处宽敞&#xff0c;允许两个人通过或歇息。试用信号灯和PV操作写出南、北两岸过桥的同步算法。<br /><br />桥上可能没有人&#xff0c;也可能有一人&#xff0c;也可能有两人。<br />·  两人同时过桥<br />·  两人都到中间<br />·  南(北)来者到北(南)段<br /><br />共需要三个信号量&#xff0c;load用来控制桥上人数&#xff0c;初值为2&#xff0c;表示桥上最多有2人&#xff1b;north用来控制北段桥的使用&#xff0c;初值为1&#xff0c;用于对北段桥互斥&#xff1b;south用来控制南段桥的使用&#xff0c;初值为1&#xff0c;用于对南段桥互斥。</p>\n<p></p>\n<pre>#coding=utf-8<br />#!/usr/bin/env python<br /><br />import threading  <br />import time  <br /><br />north = threading.Condition()<br />south = threading.Condition()<br />road = threading.Condition()<br />people = 2  <br /><br />class North(threading.Thread):  <br />    def __init__(self):  <br />        threading.Thread.__init__(self)  <br /><br />    def run(self):  <br />        global north, people, road  <br />        while True:  <br />            if road.acquire():<br />                if north.acquire():<br />                    if people &lt; 2:  <br />                        people &#43;= 1;  <br />                        print &#34;Nouth(%s):p one, now %s people.&#34; %(self.name, people)  <br />                        north.notify()  <br />                        road.notify()  <br />                    else:<br />                        print &#34;Nouth(%s):already 2, stop pass, now %s people.&#34; %(self.name, people)  <br />                        north.wait()  <br />                        road.wait()  <br />                    north.release()  <br />                road.release()  <br /><br />class South(threading.Thread):  <br />    def __init__(self):  <br />        threading.Thread.__init__(self)  <br /><br />    def run(self):  <br />        global south, people, road  <br />        while True:  <br />            if road.acquire():<br />                if south.acquire():  <br />                    if people &gt;= 1:  <br />                        people -= 1  <br />                        print &#34;sorth(%s): pass one  now %s people.&#34; %(self.name, people)  <br />                        south.notify()  <br />                        road.notify()  <br />                    else:  <br />                        print &#34;sorth(%s):  no one , stop consume now %s people.&#34; %(self.name, people)  <br />                        south.wait()  <br />                        road.wait() <br />                    south.release()  <br />                road.release()<br /><br />if __name__ == &#34;__main__&#34;:  <br />    for p in range(0, 4):  <br />        p = South()  <br />        p.start()  <br /><br />    for c in range(0, 4):  <br />        c = North()  <br />        c.start() </pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:03:49Z", "no_upvotes": 0, "uid": "i6t7bfshA1d", "created": "2015-05-06T07:03:49Z", "type": "followup", "no_answer": 1, "id": "i9cefkgu96m38r", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>裴中煜 2012010685<br /><br />某高校计算机系开设网络课并安排上机实习&#xff0c;假设机房共有2m台机器&#xff0c;有2n名学生选课&#xff08;m&#xff0c;n均大于等于1&#xff09;&#xff0c;规定&#xff1a; (1)每两个学生组成一组&#xff0c;各占一台及其协同完成上机实习&#xff1b; (2)只有一组两个学生到齐&#xff0c;并且此时机房有空闲机器时&#xff0c;该组学生才能进入机房&#xff1b; (3)上机实习由一名教师检查&#xff0c;检查完毕&#xff0c;一组学生同时离开机房 试用P、V实现其过程。 注意&#xff1a; 本题目隐含一个进程(Guard )。<br /><br />信号量实现&#xff1a;</p>\n<p><a href=\"https://github.com/BrieflyX/ucore_lab/blob/master/related_info/lab7/semaphore_condition/ex21-sem.py\" target=\"_blank\">ex21-sem.py</a><br /><br />条件变量实现&#xff1a;<br /><a href=\"https://github.com/BrieflyX/ucore_lab/blob/master/related_info/lab7/semaphore_condition/ex21-cond.py\" target=\"_blank\">ex21-cond.py</a></p>"}, {"folders": [], "updated": "2015-05-06T07:03:53Z", "no_upvotes": 0, "uid": "i6vi7mt1I4G", "created": "2015-05-06T07:03:53Z", "type": "followup", "no_answer": 1, "id": "i9cefn02nin39p", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [{"folders": [], "updated": "2015-05-06T07:45:22Z", "uid": "i6vi7mt1I4G", "created": "2015-05-06T07:45:22Z", "type": "feedback", "id": "i9cfwzq73hd3rq", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p></p><pre>__author__ = &#39;yuan&#39;\n\nimport threading\nimport random\nimport time\n\nclass MyThread(threading.Thread):\n\n    flag = {}\n    flag[0] = False\n    flag[1] = False\n    turn = 0\n\n    def __init__(self, thread_name, threadingsemaphore, pid):\n        threading.Thread.__init__(self, name=thread_name)\n        self.semaphore = threadingsemaphore\n        self.pid = pid\n\n    def run(self):\n        while True:\n            self.semaphore.acquire()\n            MyThread.turn = self.pid\n            MyThread.flag[self.pid] = True\n            MyThread.flag[1-self.pid] = False\n            print &#34;turn: &#34;, MyThread.turn, &#34; flag: &#34;, MyThread.flag\n            self.semaphore.release()\n            time.sleep(random.uniform(0, 1.0))\n\n\nthreadingsemaphore = threading.Semaphore(2)\n\nthreads = []\nfor i in range(2):\n    threads.append(MyThread(&#39;proc &#39;&#43;str(i), threadingsemaphore, i))\nfor t in threads:\n    t.start()</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:51:46Z", "uid": "i6vi7mt1I4G", "created": "2015-05-06T07:51:46Z", "type": "feedback", "id": "i9cg57snupm1s1", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p><a href=\"https://github.com/yuany12/os_exercises/blob/master/all/40_condition.py\">https://github.com/yuany12/os_exercises/blob/master/all/40_condition.py</a></p>\n<p>https://github.com/yuany12/os_exercises/blob/master/all/40_semaphore.py</p>"}], "subject": "<p>袁源2012011294</p>\n<p></p>\n<p>第40题</p>\n<p></p>\n<p>知错能改 进程p0,p1共享变量flag,turn;他们进入临界区的算法如下:</p>\n<pre><code>var flag:array[0..1] of boolean;//初值为false\nturn:01\nprocess i (0或1)\n    while true\n    do begin\n        flag[i] =true;\n        while turn!=i\n        do begin\n            while flag[j]==false\n            do skip;//skip为空语句\n            turn = i\n        end\n        临界区;\n        flag[i] = false;\n        出临界区;\n    end\n</code></pre>\n<p>该算法能否正确地实现互斥?若不能,应该如何修改(假设flag,turn单元内容的修改和访问 是互斥的).</p>\n<pre><code>不能正确实现互斥.考虑如下情况:process0先执行到flag[0] =true,process1开始执行,进入内循环时,将turn设置为1;此时进程调度转到process0, process0可以进入内循环,由于flag[1]的值为true,所以process0再次将turn的值设置为0,重复上述操作,两个进程谁也不能进入临界区.\n</code>\n<code>condition<br /></code>\n__author__ = &#39;yuan&#39;<br /><br />import threading<br />import time<br />import random<br /><br />condition = threading.Condition()<br />flag = {}<br />flag[0] = False<br />flag[1] = False<br />turn = 0<br /><br />class MyProcess(threading.Thread):<br />    def __init__(self, pid):<br />        threading.Thread.__init__(self)<br />        self.pid = pid<br /><br />    def run(self):<br />        global flag, turn<br />        i = self.pid<br />        j = 1 - self.pid<br />        while True:<br />            if condition.acquire():<br />                flag[i] = True<br />                turn = i<br />                condition.notify()<br />                while flag[j] or turn == j:<br />                    condition.wait()<br /><br />                print &#34;turn: &#34;, turn, &#34; flag: &#34;, flag<br />                flag[i] = False<br />                time.sleep(random.uniform(0, 1.0))<br />                condition.release()<br /><br />if __name__ == &#34;__main__&#34;:<br />    for p in range(2):<br />        p = MyProcess(p)<br />        p.start()\n<code> </code></pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:05:36Z", "no_upvotes": 0, "uid": "i6unpz8nUza", "created": "2015-05-06T07:05:36Z", "type": "followup", "no_answer": 1, "id": "i9cehv3h9lh3q5", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>李国豪2012011303</p>\n<p>第22题</p>\n<p>设有A、B、C三组进程&#xff0c;它们互斥地使用某一独占型资源R&#xff0c;使用前申请&#xff0c;使用后释放。资源 分配原则如下&#xff1a;<br />当只有一组申请进程时&#xff0c;该组申请进程依次获得R&#xff1b;<br />(1)当有两组申请进程时&#xff0c;各组申请进程交替获得R&#xff0c;组内申请进程交替获得R&#xff1b;<br />(2)当有三组申请进程时&#xff0c;各组申请进程轮流获得R&#xff0c;组内申请进程交替获得R。<br />(3)试用信号灯和PV操作分别给出各组进程的申请活动程序段和释放活动程序段。</p>\n<p></p>\n<p><a href=\"https://github.com/lgh303/os_exercises/blob/master/all/07-2-spoc-pv-problems/22-condition.py\" target=\"_blank\">22-condition.py</a></p>\n<p><a href=\"https://github.com/lgh303/os_exercises/blob/master/all/07-2-spoc-pv-problems/22-semaphore.py\" target=\"_blank\">22-semaphore.py</a></p>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:05:58Z", "no_upvotes": 0, "uid": "i6vuv0mi6uU", "created": "2015-05-06T07:05:58Z", "type": "followup", "no_answer": 1, "id": "i9ceic3wl9n7p", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p></p><pre>2012011322  林子钏<br />第23题<br />进程A1、A2、...、An1通过m个缓冲区向进程B1、B2、...、Bn2不断发送消息。发送和接收 工作遵循下列规则&#xff1a; 每个发送进程一次发送一个消息&#xff0c;写入一个缓冲区&#xff0c;缓冲区大小等于消息长度&#xff1b; 对每个消息&#xff0c;B1&#xff0c;B2&#xff0c;Bn2都须各接收一次&#xff0c;读入各自的数据区内&#xff1b; m个缓冲区都满时&#xff0c;发送进程等待&#xff0c;没有可读消息时&#xff0c;接收进程等待。 试用P、V操作组织正确的发送和接收工作。<br />用条件变量实现&#xff1a;<br />#coding=utf-8\n#!/usr/bin/env python\n\nimport threading\nimport time\n\nm = 5\ncondition = threading.Condition()\nbuffer_num = 0\nbuf = [&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;,&#39;0&#39;]\n\nclass Send(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n    def run(self):\n        global condition, buffer_num\n        while True:\n            if condition.acquire():\n                if buffer_num &lt; m:\n                    buffer_num &#43;= 1\n                    print &#34;put into buffer %s&#34; %(buffer_num)\n                    buf[buffer_num-1] = self.name         ## write in buffer \n                    condition.notify()\n                else:\n                    print &#34;no buffer space! waiting...&#34;\n                    condition.wait()\n                condition.release()\n                time.sleep(1)\n\n\nclass Recv(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n    def run(self):\n        global condition, buffer_num\n        while True:\n            if condition.acquire(): \n                if buffer_num &gt; 0:\n                    buffer_num -= 1\n                    print &#34;get from buffer %s, get content is %s&#34; %(buffer_num, buf[buffer_num])  ##get the content of the buffer \n                    condition.notify()\n                else :\n                    print &#34;no content! waiting...&#34;\n                    condition.wait()\n                condition.release()\n                time.sleep(2)\n\nif __name__ == &#34;__main__&#34;:\n    for s in range(0, 6):\n        s = Send()\n        s.start()\n\n    for r in range(0, 6):\n        r = Recv()\n        r.start()</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:06:52Z", "no_upvotes": 0, "uid": "i6ugdh143r52f9", "created": "2015-05-06T07:06:52Z", "type": "followup", "no_answer": 1, "id": "i9cejhkm48l4dx", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [{"folders": [], "updated": "2015-05-06T12:38:54Z", "uid": "i6ugdh143r52f9", "created": "2015-05-06T12:38:54Z", "type": "feedback", "id": "i9cqehg9tq7545", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p></p>"}], "subject": "<p>杨皓 第6题 2012013320</p>\n<p>设有一个可以装A、B两种物品的仓库&#xff0c;其容量无限大&#xff0c;但要求仓库中A、B两种物品的数量满足下述不等式&#xff1a; -M≤A物品数量-B物品数量≤N 其中M和N为正整数。试用信号量和PV操作描述A、B两种物品的入库过程。</p>\n<p></p>\n<p>Semaphore</p>\n<p><a href=\"https://github.com/Alex-YH/os_exercises/blob/master/all/Semaphore.py\" target=\"_blank\">https://github.com/Alex-YH/os_exercises/blob/master/all/Semaphore.py</a></p>"}, {"folders": [], "updated": "2015-05-06T07:06:57Z", "no_upvotes": 0, "uid": "i6urr6is7yo3jv", "created": "2015-05-06T07:06:57Z", "type": "followup", "no_answer": 1, "id": "i9cejlbmzmeip", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>鲁逸沁</p>\n<p>2012011314</p>\n<p></p>\n<p>9. 此问题是对读者-写者问题的一个扩展&#xff0c;既如果读者写者均是平等的即二者都不优先情况下。 此问题的一个更高的版本是说&#xff0c;每个资源可以同时读取的人的个数也是有限的&#xff08;限制数RN&#xff09;。</p>\n<p></p>\n<p>信号量</p>\n<pre>#coding=utf-8\n\nimport random\nimport threading\nimport time\n\n\n#\t限定读上限为3\nCanRead = threading.Semaphore(3)\n\n#\t写锁&#xff0c;在读的时候打开&#xff0c;保证不能写\nCanWrite = threading.Semaphore(1)\n\n#\t读进入等待队列的锁&#xff0c;在写进入的时候打开&#xff0c;保证读不会跳到写的前面\nCanReadIn = threading.Semaphore(1)\n\n#\t读个数\nreaderCnt = 0\n\n\n#\t暂停\ndef rest():\n\ttime.sleep(random.randrange(1, 4))\n\n\n#\t读\nclass Reader(threading.Thread):\n\tdef __init__(self, threadName):\n\t\tthreading.Thread.__init__(self, name = threadName)\n\tdef run(self):\n\t\tglobal CanRead, CanWrite, CanReadIn, readerCnt\n\t\twhile True:\n\t\t\t#\t判断读能进等待队列\n\t\t\tCanReadIn.acquire()\n\t\t\tCanReadIn.release()\n\t\t\t\n\t\t\t#\t判断当前能否读\n\t\t\tCanRead.acquire()\n\t\t\t\n\t\t\t#\t在读者数从0变成1的时候打开写锁\n\t\t\tif readerCnt == 0:\n\t\t\t\tCanWrite.acquire()\n\t\t\treaderCnt &#43;= 1\n\t\t\t\n\t\t\tprint &#34;%s read start\\n&#34; % (self.name)\n\t\t\trest()\n\t\t\tprint &#34;%s read end\\n&#34; % (self.name)\n\t\t\t\n\t\t\t#\t在读者数从1变成0的时候关闭写锁\n\t\t\treaderCnt -= 1\n\t\t\tif readerCnt == 0:\n\t\t\t\tCanWrite.release()\n\t\t\t\n\t\t\tCanRead.release()\n\t\t\trest()\n\n\n#\t写\nclass Writer(threading.Thread):\n\tdef __init__(self, threadName):\n\t\tthreading.Thread.__init__(self,name = threadName)\n\tdef run(self):\n\t\tglobal CanRead, CanWrite, CanReadIn, readerCnt\n\t\twhile True:\n\t\t\t#\t打开锁防止读进入等待队列\n\t\t\tCanReadIn.acquire()\n\t\t\t\n\t\t\t#\t判断是否可写\n\t\t\tCanWrite.acquire()\n\t\t\t\n\t\t\tprint &#34;%s write start\\n&#34; % (self.name)\n\t\t\trest()\n\t\t\tprint &#34;%s write end\\n&#34; % (self.name)\n\t\t\t\n\t\t\tCanWrite.release()\n\t\t\tCanReadIn.release()\n\t\t\trest()\n\nif __name__ == &#34;__main__&#34;:\n\tfor i in range(1, 5):\n\t\tthread = Reader(&#34;reader &#34; &#43; str(i))\n\t\tthread.start()\n\tfor i in range(1, 2):\n\t\tthread = Writer(&#34;writer &#34; &#43; str(i))\n\t\tthread.start()<br /><br /><br /><br /></pre>\n<p></p>\n<p>条件变量</p>\n<pre>#coding=utf-8\n\nimport random\nimport threading\nimport time\n\n\n#\t锁\nLock = threading.Condition()\n\n#\t活动读的个数\nAR = 0\n\n#\t活动写的个数\nAW = 0\n\n#\t等待读的个数\nWR = 0\n\n#\t等待写的个数\nWW = 0\n\n\n#\t暂停\ndef rest():\n\ttime.sleep(random.randrange(1, 4))\n\n\n#\t读\nclass Reader(threading.Thread):\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self)\n\tdef run(self):\n\t\tglobal Lock, AR, AW, WR, WW\n\t\twhile True:\n\t\t\tLock.acquire()\n\t\t\t\n\t\t\t#\t变成等待读&#xff0c;直到没有写以及活动读小于等于2个\n\t\t\twhile (AW &#43; WW) &gt; 0 or AR &gt; 2:\n\t\t\t\tWR = WR &#43; 1\n\t\t\t\tLock.wait()\n\t\t\t\tWR = WR - 1\n\t\t\t\n\t\t\t#\t转化为活动读\n\t\t\tAR = AR &#43; 1\n\t\t\tLock.release()\n\t\t\t\n\t\t\tprint &#34;%s read start\\n&#34; % (self.name)\n\t\t\trest()\n\t\t\tprint &#34;%s read end\\n&#34; % (self.name)\n\t\t\t\n\t\t\t#\t结束\n\t\t\tLock.acquire()\n\t\t\tAR = AR - 1\n\t\t\tLock.notifyAll()\n\t\t\tLock.release()\n\t\t\t\n\t\t\trest()\n\t\t\t\n\nclass Writer(threading.Thread):\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self)\n\tdef run(self):\n\t\tglobal Lock, AR, AW, WR, WW\n\t\twhile True:\n\t\t\tLock.acquire()\n\t\t\t\n\t\t\t#\t变成等待写&#xff0c;直到没有活动读和活动写\n\t\t\twhile (AW &#43; AR) &gt; 0:\n\t\t\t\tWW = WW &#43; 1\n\t\t\t\tLock.wait()\n\t\t\t\tWW = WW - 1\n\t\t\t\t\n\t\t\t#\t变成活动写\n\t\t\tAW = AW &#43; 1\n\t\t\tLock.release()\n\t\t\t\n\t\t\tprint &#34;%s write start\\n&#34; % (self.name)\n\t\t\trest()\n\t\t\tprint &#34;%s write end\\n&#34; % (self.name)\n\t\t\t\n\t\t\t#\t结束\n\t\t\tLock.acquire()\n\t\t\tAW = AW - 1\n\t\t\tLock.notifyAll()\n\t\t\tLock.release()\n\t\t\t\n\t\t\trest()\n\nif __name__ == &#34;__main__&#34;:\n\tfor r in range(0, 5):\n\t\tr = Reader()\n\t\tr.start()\n\n\tfor w in range(0, 2):\n\t\tw = Writer()\n\t\tw.start() </pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:07:03Z", "no_upvotes": 0, "uid": "i6t7bfshA1d", "created": "2015-05-06T07:07:03Z", "type": "followup", "no_answer": 1, "id": "i9cejps7a9u3wk", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [{"folders": [], "updated": "2015-05-06T07:45:57Z", "uid": "i6uji18l8j51ob", "created": "2015-05-06T07:45:57Z", "type": "feedback", "id": "i9cfxqnqe8u30c", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>谢菊苣帮占坑</p>\n<p>题目&#xff1a;</p>\n<p>20.两人公用一个账号&#xff0c;每次限存或取10元&#xff1b;</p>\n<p></p>\n<p>信号量&#xff1a;</p>\n<p>#coding=utf-8<br />import threading  <br />import random  <br />import time  <br /><br />money = 0<br /><br />class Save(threading.Thread):<br />    def __init__(self,threadName,semaphore):<br />       threading.Thread.__init__(self,name=threadName)<br />       self.threadSemaphore=semaphore<br />    def run(self):<br />       global money<br />       while True:<br />           self.threadSemaphore.acquire()  <br />           money &#43;= 10  <br />           print &#34;%s save:now money is %s.&#34; %(self.getName(),money)<br />           self.threadSemaphore.release()<br />           time.sleep(random.randrange(1, 5))<br /><br />class Load(threading.Thread):<br />    def __init__(self,threadName,semaphore):<br />       threading.Thread.__init__(self,name=threadName)<br />       self.threadSemaphore=semaphore<br />    def run(self):<br />       global money<br />       while True:<br />           self.threadSemaphore.acquire()  <br />           if money&gt;0:<br />               money -= 10  <br />               print &#34;%s load:now money is %s.&#34; %(self.getName(),money)<br />           else:<br />               print &#34;%s load:no money now.&#34; %(self.getName())<br />           self.threadSemaphore.release()<br />           time.sleep(random.randrange(1, 5))<br /><br />threads=[]<br />threadSemaphore=threading.Semaphore(1)<br />for i in range(1,6):  <br />   threads.append(Save(&#34;save&#34;&#43;str(i),threadSemaphore))  <br />for i in range(1,8):<br />    threads.append(Load(&#34;load&#34;&#43;str(i),threadSemaphore))<br />for thread in threads: <br />   thread.start()   <br /><br /></p>\n<p>条件变量&#xff1a;</p>\n<p>#coding=utf-8<br />#!/usr/bin/env python<br />import threading<br />import time<br /><br />condition = threading.Condition()<br />money = 0<br /><br />class Save(threading.Thread):<br />    def __init__(self):<br />        threading.Thread.__init__(self)<br /><br />    def run(self):<br />        global condition, money<br />        while True:<br />            if condition.acquire():<br />                money &#43;= 10<br />                print &#34;save money(%s): now money is %s&#34; %(self.name, money)<br />                condition.notify()<br />            condition.release()<br />            time.sleep(1)<br /><br />class Load(threading.Thread):<br />    def __init__(self):<br />        threading.Thread.__init__(self)<br /><br />    def run(self):<br />        global condition, money<br />        while True:<br />            if condition.acquire():<br />                if money&gt;0:<br />                    money -= 10<br />                    print &#34;load money(%s): now money is %s&#34; %(self.name, money)<br />                    condition.notify()<br />                else:<br />                    print &#34;load money(%s): no money now&#34; %(self.name)<br />                    condition.wait()<br />            condition.release()<br />            time.sleep(2)<br /><br />if __name__ == &#34;__main__&#34;:<br />    for s in range(0,2):<br />        s = Save()<br />        s.start()<br />    for l in range(0,4):<br />        l = Load()<br />        l.start()<br /><br /></p>"}], "subject": "李若愚 2012011353\n\n代码由badpoem给出"}, {"folders": [], "updated": "2015-05-06T07:07:03Z", "no_upvotes": 0, "uid": "i6utvrywozd2vd", "created": "2015-05-06T07:07:03Z", "type": "followup", "no_answer": 1, "id": "i9cejpxwo6s6", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [{"folders": [], "updated": "2015-05-06T09:03:55Z", "uid": "i6utvrywozd2vd", "created": "2015-05-06T09:03:55Z", "type": "feedback", "id": "i9ciq06lxeldn", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>题目是&#xff1a;</p>\n<p></p>\n<p>三个吸烟者在一间房间内&#xff0c;还有一个香烟供应者。为了制造并抽掉香烟&#xff0c;每个吸烟者需要三 样东西&#xff1a;烟草、纸和火柴。供应者有丰富的货物提供。三个吸烟者中&#xff0c;第一个有自己的烟草&#xff0c; 第二个有自己的纸&#xff0c;第三个有自己的火柴。供应者将两样东西放在桌子上&#xff0c;允许一个吸烟者进行对健康不利 (°_°) 的吸烟。当吸烟者完成吸烟后唤醒供应者&#xff0c;供应者再放两样东西&#xff08;随机地&#xff09; 在桌面上&#xff0c;然后唤醒另一个吸烟者。试为吸烟者和供应者编写程序解决问题。</p>"}], "subject": "<p>计 24 陈天昱 2012011348</p>\n<p></p>\n<p>吸烟者问题</p>\n<p></p>\n<p>semaphore:</p>\n<p></p>\n<p><a href=\"https://github.com/cty12/os_exercises/blob/master/src/07-2-spoc-coding/smoker_semaphore.py\">https://github.com/cty12/os_exercises/blob/master/src/07-2-spoc-coding/smoker_semaphore.py</a><a href=\"https://github.com/cty12/os_exercises/blob/master/src/07-2-spoc-coding/smoker_semaphore.py\"></a></p>\n<p></p>\n<p>condition:</p>\n<p></p>\n<p><a href=\"https://github.com/cty12/os_exercises/blob/master/src/07-2-spoc-coding/smoker_condition.py\">https://github.com/cty12/os_exercises/blob/master/src/07-2-spoc-coding/smoker_condition.py</a></p>\n<p></p>\n<p></p>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:07:22Z", "no_upvotes": 0, "uid": "i6t7mzhbhwF", "created": "2015-05-06T07:07:22Z", "type": "followup", "no_answer": 1, "id": "i9cek4wl6kyqm", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>周界 计21 2012011394</p>\n<p>题目&#xff1a;35</p>\n<p>桔子汁生产线问题 现有三个生产者P1 、P2 、P3&#xff0c;他们都要生产水&#xff0c;每个生产者都已分别购得两种不同原料&#xff0c;待购得第三种原料后就可配制成桔子水&#xff0c;装瓶出售。有一供应商能源源不断地供应糖、水、桔子精&#xff0c;但每次只拿出一种原料放入容器中供给生产者。当容器中有原料时需要该原料的生产者可取走&#xff0c;当容器空时供应商又可放入一种原料。假定&#xff1a;生产者P1已购得糖和水&#xff1b;生产者P2 已购得水和桔子精&#xff1b;生产者P3已购得糖和桔子精&#xff1b;试用&#xff1a;信号量与P、V操作&#xff0c;写出供应商和三个生产者之间能正确同步的程序。</p>\n<p>Semaphore</p>\n<pre>import threading\nimport random\nimport time\n\ncritical = threading.Semaphore(1)\ncritical_product = -1\n\nclass Consumer(threading.Thread):\n    def __init__(self, number):\n        self.number = number\n        self.ingredient = [1, 1, 1]\n        self.ingredient[number] = 0\n        threading.Thread.__init__(self)\n\n    def run(self):\n        #print &#34;I am %s %d&#34; % (self.name,self.number)\n        # random sleep\n        time.sleep(2)\n        global critical\n        global critical_product\n        while True:\n            critical.acquire()\n            print &#34;I am %s in critical!&#34; % (self.name)\n            if critical_product == self.number:\n                print &#34;My require ingredient is %d and I get %d now!&#34; % (self.number, critical_product)\n                critical_product = -1\n                critical.release()\n                break\n            critical.release()\n            time.sleep(random.randrange(1, 5))\n        print &#34;I am %s, I&#39;m finished.&#34; % (self.name)\n\nclass Producer(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n    def run(self):\n        global critical\n        global critical_product\n        count = 0\n        while (count &lt; 3):\n            critical.acquire()\n            print &#34;I am %s in critical!&#34; % (self.name)\n            if critical_product == -1:\n                critical_product = count\n                count &#43;= 1\n            critical.release()\n            time.sleep(random.randrange(1, 5))\n\n\nif __name__ == &#39;__main__&#39;:\n    my = Producer()\n    my.start()\n\n    for i in range(0, 3):\n        my = Consumer(i)\n        my.start()\n        time.sleep(1)</pre>\n<p>Condition</p>\n<pre>import threading\nimport random\nimport time\n\ncondition = threading.Condition()\nproduct = -1\n\nclass Consumer(threading.Thread):\n    def __init__(self, number):\n        self.number = number\n        #self.ingredient = [1, 1, 1]\n        #self.ingredient[number] = 0\n        threading.Thread.__init__(self)\n\n    def run(self):\n        #print &#34;I am %s %d&#34; % (self.name,self.number)\n        # random sleep\n        while True:\n            global condition\n            global product\n            if condition.acquire():\n                if product == self.number:\n                    print &#34;My require ingredient is %d and I get %d now!&#34; % (self.number, product)\n                    product = -1\n                    condition.notify()\n                    condition.release()\n                    break\n                else:\n                    condition.wait()\n                condition.release()\n        \n        print &#34;I am %s, I&#39;m finished.&#34; % (self.name)\n\nclass Producer(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n    def run(self):\n        global condition\n        global product\n        count = 0\n        while (count &lt; 3):\n            if condition.acquire():\n                if product == -1:\n                    product = count\n                    print &#34;I an producing ingredient %d now!&#34; % (product)\n                    count &#43;= 1\n                    condition.notify()\n                else:\n                    condition.wait()\n                condition.release()\n\n\nif __name__ == &#39;__main__&#39;:\n    my = Producer()\n    my.start()\n\n    for i in range(0, 3):\n        my = Consumer(i)\n        my.start()\n        time.sleep(1)</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:08:05Z", "no_upvotes": 0, "uid": "i8o4iar88jf5mz", "created": "2015-05-06T07:08:05Z", "type": "followup", "no_answer": 1, "id": "i9cel1smgaw4pd", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>杨博文 2012011288</p>\n<pre>题目 14<br />假设缓冲区buf1和缓冲区buf2无限大&#xff0c;进程p1向buf1写数据&#xff0c;进程p2向buf2写数据&#xff0c; 要求buf1数据个数和buf2数据个数的差保持在(m,n)之间(m&lt;n,m,n都是正数)。\n\n题中没有给出两个进程执行顺序之间的制约关系&#xff0c;只给出了一个数量上的制约\n关系&#xff0c;即m≤|buf1数据个数&#xff0d;buf2数据个数≤n&#xff0e;不需要考虑缓冲区的大小&#xff0c;只需要考\n虑两个进程的同步和互斥&#xff0e;p2向buf2写数据比p1向buf1写数据的次数最少不超过m次&#xff0c;\n最多不能超过n次&#xff0c;反之也成立&#xff0e;所以是一个生产者和消费者问题。将等式展开得&#xff1a;\n(1)m≤(buf1数据个数&#xff0d;buf2数据个数)≤n; (2)m≤(buf2数据个数&#xff0d;buf1数据个数)≤n;由\n于m,n都是正数&#xff0c;等式只有一个成立&#xff0c;不妨设(1)成立&#xff0e;在进程p1和p2都没有运行时&#xff0c;\n两个缓冲区数据个数之差为0,因此&#xff0c;p1必须先运行&#xff0c;向buf1至少写m&#43;1个数据后再唤\n醒p2运行&#xff0e;信号量s1表示p1一次写入的最大量,初值为n&#xff0c;s2表示p2一次写入的最大量,初\n值为-m.\nbegin\nvar mutex1=1,mutex2=1,s1=n,s2=-m:semaphore;\ncobegin\nprocess p1\nbegin\nrepeat\nget data;\np(s1);\np(mutex1);\n写数据到buf1;\nv(mutex1);\nv(s2);\nend\nprocess p2\nbegin\nrepeat;\nget data;\np(s2);\np(mutex2);\n写数据到buf2;\nv(mutex2);\nv(s1);\nend\n信号&#xff1a;<br />#coding=utf-8\n&#34;&#34;&#34;\nsemaphore\nSTU CODE 2012011288\nEX NO 14\n&#34;&#34;&#34;\nimport threading\nimport time\n\nsemaphore;\ncou1=0;\ncou2=0;\nm=1;\nn=6;\n\nclass WrireThread1(threading.Thread):\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self);\n\t\n\tdef run(self):\n\t\tglobal semaphore, cou1, cou2, n, m;\n\t\tprint &#34;This is Thread 1.&#34;;\n\t\twhile (True):\n                        semaphore.acquire();\n                        if (cou1&lt;m):\n                                semaphore.release();\n                        cou1&#43;=1;\n                        print &#34;Thread1 write to buf1. Now buf1 is %d, buf2 is %d, minus is %d&#34; %(cou1, cou2, cou1-cou2);\n                        sleep(1);\n                        \n\nclass WrireThread2(threading.Thread):\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self);\n\t\n\tdef run(self):\n\t\tglobal semaphore, cou1, cou2, n, m;\n\t\tprint &#34;This is Thread 2.&#34;;\n\t\twhile (True):\n                        semaphore.release();\n                        cou2&#43;=1;\n                        print &#34;Thread2 write to buf2. Now buf1 is %d, buf2 is %d, minus is %d&#34; %(cou1, cou2, cou1-cou2);\n                        sleep(1);\n                        \nif __name__ == &#34;__main__&#34;:\n        samephore=threading.Semaphore(n-m);\n\tt1=WrireThread1();\n\tt2=WrireThread2();\n\tt1.start();\n\tt2.start();\n条件&#xff1a;<br />#coding=utf-8\n&#34;&#34;&#34;\ncondition\nSTU CODE 2012011288\nEX NO 14\n&#34;&#34;&#34;\nimport threading\nimport time\n\ncondition=threading.Condition();\ncou1=0;\ncou2=0;\nm=1;\nn=6;\n\nclass WrireThread1(threading.Thread):\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self);\n\t\n\tdef run(self):\n\t\tglobal condition, cou1, cou2, n, m;\n\t\tprint &#34;This is Thread 1.&#34;;\n\t\twhile (True):\n                        if (condition.acquire()):\n                                if (cou1&#43;1-cou2)&lt;n:\n                                        cou1&#43;=1;\n                                        print &#34;Thread1 write to buf1. Now buf1 is %d, buf2 is %d, minus is %d&#34; %(cou1, cou2, cou1-cou2);\n                                        condition.notify();\n                                else:\n                                        condition.wait();\n                                condition.release();\n                                time.sleep(1);\n\n\nclass WrireThread2(threading.Thread):\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self);\n\t\n\tdef run(self):\n\t\tglobal condition, cou1, cou2, n, m;\n\t\tprint &#34;This is Thread 2.&#34;;\n\t\twhile (True):\n                        if (condition.acquire()):\n                                if (cou1-cou2-1)&gt;m:\n                                        cou2&#43;=1;\n                                        print &#34;Thread2 write to buf2. Now buf1 is %d, buf2 is %d, minus is %d&#34; %(cou1, cou2, cou1-cou2);\n                                        condition.notify();\n                                else:\n                                        condition.wait();\n                                condition.release();\n                                time.sleep(1);\n\nif __name__ == &#34;__main__&#34;:\n\tt1=WrireThread1();\n\tt2=WrireThread2();\n\tt1.start();\n\tt2.start();</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:08:25Z", "no_upvotes": 0, "uid": "i71ev8heKQi", "created": "2015-05-06T07:08:25Z", "type": "followup", "no_answer": 1, "id": "i9celh68a8oc5", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>计22班 应杰夫 2012011293</p>\n<p>第24题 题目&#xff1a;</p>\n<p>设有8个程序prog1&#xff0c;prog2&#xff0c;...&#xff0c;prog8。它们在并发系统中执行时有如下所示的制约关系&#xff0c; 使用P、V操作实现这些程序间的同步。</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i71ev8heKQi/i9cwfut0roaa/temp.PNG\" /></p>\n<p>分别给出了条件变量与信号量的实现 代码如下&#xff1a;</p>\n<p>条件变量实现&#xff1a;</p>\n<pre>import threading  \nimport time\n\ncondition12 = threading.Condition()\nprog1 = 0\nprog2 = 0\nprog3 = 0\nprog4 = 0\nprog5 = 0\nprog6 = 0\nprog7 = 0\nprog8 = 0\ncount = 0\n\nclass Prog1(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global prog1  \n        print &#34;Program1_finish\\n&#34;\n        prog1=1\n\nclass Prog2(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global prog2  \n        print &#34;Program2_finish\\n&#34;\n        prog2=1\n\nclass Prog3(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global condition12,prog1,prog2,prog3\n        while True:\n            if condition12.acquire():\n                if prog1&amp;prog2 &gt; 0:\n                    print &#34;Program3_finish\\n&#34;\n                    prog3=1\n                    condition12.notify()\n                    condition12.release()\n                    break\n                else:\n                    print &#34;Program 3 Waiting for Program1&amp;2\\n&#34;\n                    condition12.wait();\n                    condition12.release()\n                time.sleep(1)\n\nclass Prog4(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global condition12,prog1,prog2,prog4  \n        while True:\n            if condition12.acquire():\n                if prog1&amp;prog2 &gt; 0:\n                    print &#34;Program4_finish\\n&#34;\n                    prog4=1\n                    condition12.notify()\n                    condition12.release()\n                    break\n                else:\n                    print &#34;Program 4 Waiting for Program1&amp;2\\n&#34;\n                    condition12.wait()\n                    condition12.release()\n                time.sleep(1)\n\nclass Prog5(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global condition12,prog1,prog2,prog5\n        while True:\n            if condition12.acquire():\n                if prog1&amp;prog2 &gt; 0:\n                    print &#34;Program5_finish\\n&#34;\n                    prog5=1\n                    condition12.notify()\n                    condition12.release()\n                    break\n                else:\n                    print &#34;Program 5 Waiting for Program1&amp;2\\n&#34;\n                    condition12.wait()\n                    condition12.release()\n                time.sleep(1)\n               \nclass Prog6(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global prog3,prog6 \n        while True:\n            if  prog3  &gt; 0:\n                print &#34;Program6_finish\\n&#34;\n                prog6=1\n                break;\n            else:\n                print &#34;Program 6 Waiting for Program3\\n&#34;\n            time.sleep(1)\n\nclass Prog7(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global prog5,prog7 \n        while True:\n            if  prog5  &gt; 0:\n                print &#34;Program7_finish\\n&#34;\n                prog7=1\n                break;\n            else:\n                print &#34;Program 7 Waiting for Program5\\n&#34;\n            time.sleep(1)\n                \n\nclass Prog8(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n       global prog4,prog6,prog7,prog8\n       while True:\n            if  prog4&amp;prog6&amp;prog7  &gt; 0:\n                print &#34;Program8_finish\\n&#34;\n                prog8=1\n                break;\n            else:\n                print &#34;Program 8 Waiting for Program4&amp;6&amp;7\\n&#34;\n            time.sleep(1)\n                    \nclass Prog9(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n\n    def run(self):  \n        global count,prog1,prog2,prog3,prog4,prog5,prog6,prog7,prog8 \n        while True:\n            print &#34;count:&#34;&#43;str(count)&#43;&#34; &#34;&#43;str(prog1)&#43;&#34; &#34;&#43;str(prog2)&#43;&#34; &#34;&#43;str(prog3)&#43;&#34; &#34;&#43;str(prog4)&#43;&#34; &#34;&#43;str(prog5)&#43;&#34; &#34;&#43;str(prog6)&#43;&#34; &#34;&#43;str(prog7)&#43;&#34; &#34;&#43;str(prog8)\n            count=count&#43;1\n            time.sleep(2)\n\nif __name__ == &#34;__main__&#34;:  \n\n    pprog4=Prog4()\n    pprog4.start()\n\n    pprog6=Prog6()\n    pprog6.start()\n    \n    pprog1=Prog1()\n    pprog1.start()\n\n    pprog8=Prog8()\n    pprog8.start()\n    \n    pprog2=Prog2()\n    pprog2.start()\n\n    pprog7=Prog7()\n    pprog7.start()\n    \n    pprog3=Prog3()\n    pprog3.start()\n\n    pprog5=Prog5()\n    pprog5.start()\n\n    #pprog9=Prog9()\n    #pprog9.start()</pre>\n<p>信号量实现&#xff1a;</p>\n<pre>import threading  \nimport time\n\ntS13=threading.Semaphore(1)\ntS14=threading.Semaphore(1)\ntS15=threading.Semaphore(1)\ntS23=threading.Semaphore(1)\ntS24=threading.Semaphore(1)\ntS25=threading.Semaphore(1)\ntS36=threading.Semaphore(1)\ntS57=threading.Semaphore(1)\ntS68=threading.Semaphore(1)\ntS48=threading.Semaphore(1)\ntS78=threading.Semaphore(1)\n\nclass Prog1Thread(threading.Thread):  \n    \n    def __init__(self):  \n        threading.Thread.__init__(self)\n\n    def run(self): \n        global tS13,tS14,tS15\n        print &#34;Program1_finish\\n&#34;\n        tS13.release()\n        tS14.release()\n        tS15.release()\n\nclass Prog2Thread(threading.Thread):  \n    \n    def __init__(self):  \n        threading.Thread.__init__(self) \n       \n    def run(self):\n        global tS23,tS24,tS25\n        print &#34;Program2_finish\\n&#34;\n        tS23.release()\n        tS24.release()\n        tS25.release()\n\nclass Prog3Thread(threading.Thread):  \n    \n    def __init__(self):  \n        threading.Thread.__init__(self) \n       \n    def run(self):\n        global tS13,tS23,tS36\n        tS13.acquire()\n        tS23.acquire()\n        print &#34;Program3_finish\\n&#34;\n        tS13.release()\n        tS23.release()\n        tS36.release()\n\nclass Prog4Thread(threading.Thread):  \n    \n    def __init__(self):  \n        threading.Thread.__init__(self) \n       \n    def run(self):\n        global tS14,tS24,tS48\n        tS14.acquire()\n        tS24.acquire()\n        print &#34;Program4_finish\\n&#34;\n        tS14.release()\n        tS24.release()\n        tS48.release()\n\nclass Prog5Thread(threading.Thread):  \n    \n    def __init__(self):  \n        threading.Thread.__init__(self) \n       \n    def run(self):\n        global tS15,tS25,tS57\n        tS15.acquire()\n        tS25.acquire()\n        print &#34;Program5_finish\\n&#34;\n        tS15.release()\n        tS25.release()\n        tS57.release()\n\nclass Prog6Thread(threading.Thread):  \n    \n    def __init__(self):  \n        threading.Thread.__init__(self) \n       \n    def run(self):\n        global tS36,tS68\n        tS36.acquire()\n        print &#34;Program6_finish\\n&#34;\n        tS36.release()\n        tS68.release()\n\nclass Prog7Thread(threading.Thread):  \n    \n    def __init__(self):  \n        threading.Thread.__init__(self) \n       \n    def run(self):\n        global tS57,tS78\n        tS57.acquire()\n        print &#34;Program7_finish\\n&#34;\n        tS57.release()\n        tS78.release()\n\nclass Prog8Thread(threading.Thread):  \n    \n    def __init__(self):  \n        threading.Thread.__init__(self) \n       \n    def run(self):\n        global tS48,tS68,tS78\n        tS48.acquire()\n        tS68.acquire()\n        tS78.acquire()\n        print &#34;Program8_finish\\n&#34;\n        tS48.release()\n        tS68.release()\n        tS78.release()\n\ntS13.acquire()\ntS14.acquire()\ntS15.acquire()\ntS23.acquire()\ntS24.acquire()\ntS25.acquire()\ntS36.acquire()\ntS57.acquire()\ntS48.acquire()\ntS68.acquire()\ntS78.acquire()\n\npt3=Prog3Thread()\npt3.start()\n\npt1=Prog1Thread()\npt1.start()\n\npt2=Prog2Thread()\npt2.start()\n\npt4=Prog4Thread()\npt4.start()\n\npt8=Prog8Thread()\npt8.start()\n\npt5=Prog5Thread()\npt5.start()\n\npt7=Prog7Thread()\npt7.start()\n\npt6=Prog6Thread()\npt6.start()</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:13:15Z", "no_upvotes": 0, "uid": "i6tawpo5Fm8", "created": "2015-05-06T07:13:15Z", "type": "followup", "no_answer": 1, "id": "i9cerok67um5kj", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "张梦豪 2012011401 \nimport threading\nimport time\nimport random\n\ncondition1 = threading.Condition()\ncondition2 = threading.Condition()\nlist[]\n\nclass input(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)    \n    \n    def run(self):\n        global condition, list\n        while True:\n            rand=random.random()\n            if condition1.acquire():\n                if rand%3==0:\n                    rand=rand\n                    print &#39;input %s&#39;%(rand)\n                    condition2.acquire()\n                    list.append(rand)\n                    condition2.release()\n                else:\n                    condition1.wait();\n                condition1.release()\n                time.sleep(1)\n\nclass dispatch(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n        \n    def run(self):"}, {"folders": [], "updated": "2015-05-06T07:14:05Z", "no_upvotes": 0, "uid": "i6uswob7jl4242", "created": "2015-05-06T07:14:05Z", "type": "followup", "no_answer": 1, "id": "i9cesrgfpl76ww", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>马晓彬 2012011402</p>\n<pre>26.我们将只读数据的进程称为“读者”进程&#xff0c;而写或者修改数据的进程称为“写者”进程&#xff0c;允许多 个“读者”同时读数据&#xff0c;但不运行写者与其它读者或者写者进程同时访问数据。另外&#xff0c;要保证&#xff1a; 一旦有写者等待&#xff0c;新到达的读者必须等待&#xff0c;直到该写者完成数据访问为止&#xff0c;用P,V 操作实现 读者&#xff0c;写者同步。\n\n26题 condition方法\n\n\nimport threading  \nimport time  \n   \nhas_writer = threading.Condition()  \nreader_num_lock = threading.Condition()  \nbook = 0  \nreader_num = 0\n\nclass Writer(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n          \n    def run(self):  \n        global has_writer, book, reader_num  ,reader_num_lock\n        while True:  \n            if reader_num_lock.acquire():\n                if reader_num &lt; 0:  \n                    reader_num_lock.release();\n                    if has_writer.acquire():\n                        book = int(Math.random() * 100);\n                        print &#34;Reader(%s):writing, now book:%s&#34; %(self.name, book)  \n                        has_writer.notify();\n                        has_writer.release();\n                        time.sleep(2)  \n                    else :\n\n                else:\n                    reader_num_lock.release();\n          \nclass Reader(threading.Thread):  \n    def __init__(self):  \n        threading.Thread.__init__(self)  \n          \n    def run(self):  \n        global has_writer, book, reader_num  ,reader_num_lock\n        while True:  \n            if has_writer.acquire():  \n                has_writer.release();\n                reader_num = reader_num &#43;1;\n                print &#34;Reader(%s):reading, now book:%s&#34; %(self.name, book)  \n                reader_num = reader_num -1;\n                has_writer.notify();\n                time.sleep(2)  \n                  \nif __name__ == &#34;__main__&#34;:  \n    for p in range(0, 2):  \n        p = Producer()  \n        p.start()  \n          \n    for c in range(0, 10):  \n        c = Consumer()  \n        c.start()  \n        \n        \nsemaphore方法&#xff1a;\n#coding=utf-8\nimport threading  \nimport random  \nimport time  \n\nbook = 0\n\nclass Writer(threading.Thread):  \n    def __init__(self,rsemaphore, wsemaphore):  \n        threading.Thread.__init__(self)\n        self.writeSemaphone = wsemaphore;  \n        self.readSemaphore = rsemaphore;\n        self.sleepTime=random.randrange(1,6);\n\n    def run(self):  \n        while True:\n            self.writeSemaphone.acquire()  \n            book = int(Math.random() * 100);\n            print &#34;Reader(%s):writing, now book:%s&#34; %(self.name, book)  \n            self.writeSemaphone.release();\n            sleep(self.sleepTime);\n\nclass Reader(threading.Thread):  \n    def __init__(self,rsemaphore, wsemaphore):  \n        threading.Thread.__init__(self)  \n        self.writeSemaphone = wsemaphore;  \n        self.readSemaphore = rsemaphore;\n        self.sleepTime=random.randrange(1,6);\n\n    def run(self):  \n        while True:\n            if self.readSemaphore.acquire()  \n            book = int(Math.random() * 100);\n            print &#34;Reader(%s):writing, now book:%s&#34; %(self.name, book)  \n            self.writeSemaphone.release();\n            sleep(self.sleepTime);\n            \nif __name__ == &#34;__main__&#34;:  \n    for p in range(0, 2):  \n        p = Writer()  \n        p.start()  \n          \n    for c in range(0, 10):  \n        c = Reader()  \n        c.start()  \n</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:20:31Z", "no_upvotes": 0, "uid": "i7bq1v7feay2z9", "created": "2015-05-06T07:20:31Z", "type": "followup", "no_answer": 1, "id": "i9cf11ejmpg20o", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>楼华哲 2012011327</p>\n<p>题目12</p>\n<p>信号量&#xff1a;</p>\n<pre>import threading\nimport time\nimport os\nimport random\n\npeople = [0, 0, 0]\nmovie = -1\ncount = 100\nmutex = threading.Lock()\n\nsemaphore = threading.Semaphore()\n\nclass Movie1(threading.Thread):\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self)\n\n\tdef run(self):\n\t\tglobal semaphore, movie, count, people\n\t\twhile True:\n\t\t\tif semaphore.acquire():\n\t\t\t\tif (count == 0):\n\t\t\t\t\tprint &#34;the time is over\\n&#34;\n\t\t\t\t\tbreak\n\t\t\t\tprint &#34;now is the movie 1\\nthere are %d people is watch\\n&#34; %(people[0])\n\t\t\t\tmovie = 1\n\t\t\t\twhile (people[0] != 0):\n\t\t\t\t\tcontinue\n\t\t\t\tmovie = -1\n\t\t\t\tprint &#34;the movie 1 is over\\n&#34;\n\t\t\t\tsemaphore.release()\n\t\t\t\ttime.sleep(2)\n\nclass Movie2(threading.Thread):\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self)\n\n\tdef run(self):\n\t\tglobal semaphore, movie, count, people\n\t\twhile True:\n\t\t\tif semaphore.acquire():\n\t\t\t\tif (count == 0):\n\t\t\t\t\tprint &#34;the time is over\\n&#34;\n\t\t\t\t\tbreak\n\t\t\t\tprint &#34;now is the movie 2\\nthere are %d people is watch\\n&#34; %(people[1])\n\t\t\t\tmovie = 2\n\t\t\t\twhile (people[1] != 0):\n\t\t\t\t\tcontinue\n\t\t\t\tmovie = -1\n\t\t\t\tprint &#34;the movie 2 is over\\n&#34;\n\t\t\t\tsemaphore.release()\n\t\t\t\ttime.sleep(2)\n\nclass Movie3(threading.Thread):\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self)\n\n\tdef run(self):\n\t\tglobal semaphore, movie, count, people\n\t\twhile True:\n\t\t\tif semaphore.acquire():\n\t\t\t\tif (count == 0):\n\t\t\t\t\tprint &#34;the time is over\\n&#34;\n\t\t\t\t\tbreak\n\t\t\t\tprint &#34;now is the movie 3\\nthere are %d people is watch\\n&#34; %(people[2])\n\t\t\t\tmovie = 3\n\t\t\t\twhile (people[2] != 0):\n\t\t\t\t\tcontinue\n\t\t\t\tmovie = -1\n\t\t\t\tprint &#34;the movie 3 is over\\n&#34;\n\t\t\t\tsemaphore.release()\n\t\t\t\ttime.sleep(2)\n\nclass People(threading.Thread):\n\n\tnum = 0\n\n\tdef __init__(self):\n\t\tthreading.Thread.__init__(self)\n\n\tdef run(self):\n\t\tglobal count, people, movie\n\t\tnum = random.randint(0, 2)\n\t\tif mutex.acquire():\n\t\t\tpeople[num] &#43;= 1\n\t\t\tmutex.release()\n\t\twhile(movie != (num&#43;1)):\n\t\t\tcontinue\n\t\tprint &#34;i will leave\\n&#34;\n\t\tif mutex.acquire():\n\t\t\tpeople[num] -= 1\n\t\t\tcount -= 1\n\t\t\tmutex.release()\n\nif __name__ == &#34;__main__&#34;:\t\t\n\n\tp1 = Movie1()\n\tp1.start()\n\tp2 = Movie2()\n\tp2.start()\n\tp3 = Movie3()\n\tp3.start()\n\n\tfor i in range(0, 100):\n\t\tc = People()\n\t\tc.start()\n\t\ttime.sleep(0.1)\n</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T07:22:26Z", "no_upvotes": 0, "uid": "i7w0q2p8Cmz", "created": "2015-05-06T07:22:26Z", "type": "followup", "no_answer": 1, "id": "i9cf3i4l8gq6c", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>丁延卓 计21 2012011395 </p>\n<p>题目10</p>\n<p></p>\n<p>有一个许多进程共享的数据区&#xff0c;有一些只读这个数据区的进程(reader)和一些只往数据区中写数据的进程(writer)&#xff1b;此外还需满足如下条件&#xff1a; (1)任意多的读进程可以同时读这个文件。<br />(2)一次只有一个写进程可以往文件中写。<br />(3)如果一个写进程正在往文件中写时&#xff0c;则禁止任何读进程和其他写进程。<br />实现基于先来先服务策略的读者&#xff0d;写者的问题&#xff0c;具体要求描述如下&#xff1a; (1)存在m个读者和n个写者&#xff0c;共享同一个缓冲区。 (2)当没有读者在读&#xff0c;写者在写时&#xff0c;读者写者均可进入读或写。 (3)当有读者在读时&#xff1a;</p>\n<ul><li>写者来了&#xff0c;则写者等待。</li><li>读者来了&#xff0c;则分两种情况处理&#xff1a;无写者等待&#xff0c;则读者可以直接进入读操作&#xff0c;如果有写者等待&#xff0c;则读者必须依次等待(4)当有写者在写时&#xff0c;写者或读者来了&#xff0c;均需等待。<br />(5)当写者写完后&#xff0c;如果等待队列中第一个是写者&#xff0c;则唤醒该写者&#xff1b;如果等待队列中第一个是读者&#xff0c;则唤醒该队列中从读者开始连续的所有读者。<br />(6)当最后一个读者读后&#xff0c;如果有写者在等待&#xff0c;则唤醒第一个等待的写者。</li></ul>\n<p>信号量&#xff1a;</p>\n<pre>#!/usr/bin/env python\nimport threading\nimport random\nimport time\n\ncountMutex = threading.Semaphore(1)\n\nwriteMutex = threading.Semaphore(1)\n\ncanReadMutex = threading.Semaphore(1)\n\nrCount = 0\n\nclass Reader(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n        \n    def run(self):\n        global countMutex, rCount, writeMutex,canReadMutex\n        canReadMutex.acquire()\n        canReadMutex.release()\n        \n        countMutex.acquire()\n        if rCount == 0:\n            writeMutex.acquire()\n        rCount &#43;= 1\n        countMutex.release()\n        print(&#34;proc(%s) start  reading&#34; %(self.name))\n        time.sleep(random.randrange(1,2))\n        print(&#34;proc(%s) end  reading&#34; %(self.name))\n        countMutex.acquire()\n        rCount -= 1\n        if rCount == 0:\n            writeMutex.release()\n        countMutex.release()\nclass Writer(threading.Thread):\n    def __init(self):\n        threading.Thread.__init__(self)\n        \n    def run(self):\n        global countMutex,rCount,writeMutex,canReadMutex\n        canReadMutex.acquire()\n        writeMutex.acquire()\n\n        print(&#34;proc(%s) start writing &#34; %(self.name))\n        time.sleep(random.randrange(1,2))\n        print(&#34;proc(%s) end writing &#34; %(self.name))\n\n        writeMutex.release()\n        canReadMutex.release()\nif __name__ == &#34;__main__&#34;:\n    for p in range(1,15):\n        i = random.randint(1,4)%2\n        if i == 0:\n            p = Reader()\n            p.start()\n        else:\n            p = Writer()\n            p.start()\n        </pre>\n<p>条件变量&#xff1a; </p>\n<pre>#!/usr/bin/env python\nimport threading\nimport random\nimport time\n\ncondw = threading.Condition()\ncondr = threading.Condition()\ncond = threading.Condition()\nwr = 0\nar = 0\nww = 0 \naw = 0\n\na_list = []\na_num = 0\n\nclass Reader(threading.Thread):\n    def __init__(self):\n        threading.Thread.__init__(self)\n       \n    def run(self):\n        #print(self.name)\n        global condw, condr,cond, wr, ar, ww, aw, a_list\n        \n        if cond.acquire():\n            while ww &#43; aw &gt; 0: \n                wr &#43;=1\n                a_list.append(0)\n                condr.acquire()\n                cond.release()\n                condr.wait()\n                cond.acquire()\n                condr.release()\n\n                wr-=1\n            ar = ar &#43; 1\n            #print(&#34;proc(%s) ar(&#43;&#43;) is: %s&#34; %(self.name,ar))\n            cond.release()\n\n        print(&#34;Reader(%s) is reading, active reader is %s&#34; %(self.name, ar))\n        time.sleep(1)\n        #print(self.name)\n        if cond.acquire():\n            ar = ar - 1\n            #print(&#34;proc(%s) ar(--) is: %s&#34; %(self.name,ar))\n            if ar == 0 and ww &gt;0 :\n                condw.acquire()\n                a_list.pop()\n                #print(&#34;condw notify&#34;)\n                condw.notify()\n                condw.release()\n            cond.release()\n    \nclass Writer(threading.Thread):\n    def __init(self):\n        threading.Thread.__init__(self)\n    \n    def run(self):\n        global condw, condr,cond, wr, ar, ww, aw, a_list\n        if cond.acquire():\n            while aw &#43; ar &gt; 0 :\n                ww &#43;=1\n                a_list.append(1)\n                \n                condw.acquire()\n                #print(&#34;W1%s&#34; %self.name)  \n                cond.release()              \n                condw.wait()\n                #cond.release()\n                #print(&#34;W2%s&#34; %self.name) \n\n                #print(&#34;W1%s&#34; %self.name) \n                ww -=1\n            aw &#43;=1\n            condw.release()\n        print(&#34;Writer(%s) is writing, now wait write %s&#34; %(self.name,ww))\n        time.sleep(1)\n        if cond.acquire():\n            aw -=1\n            while len(a_list) != 0 :\n                #print(a_list)\n                l = a_list.pop()\n                #print(l)\n                if l == 1 :\n                    condw.acquire()\n                    condw.notify()\n                    condw.release()\n                    #a_list.pop()\n                    break\n                else:\n                    condr.acquire()\n                    condr.notify()\n                    condr.release()\n                    #a_list.pop()\n            cond.release()\n            \n            \nif __name__ == &#34;__main__&#34;:\n    #0 reader 1 writer\n    \n    list_t = [0,0,0,0,1,0,1]\n    for i in list_t:\n        if i == 1:\n            p = Writer()\n            p.start()\n        else:\n            p = Reader()\n            p.start()\n            </pre>"}, {"folders": [], "updated": "2015-05-06T09:45:18Z", "no_upvotes": 0, "uid": "i718mp903qx", "created": "2015-05-06T09:45:18Z", "type": "followup", "no_answer": 1, "id": "i9ck77ycuuw79d", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p><strong>抱歉上课时交到向勇老师的帖子里去了~刚刚交github时才发现</strong></p>\n<p></p>\n<p>李日灵 2012011332  第7题</p>\n<p>题目描述如下&#xff1a;(操作系统之PV金典)设有一个可以装A、B两种物品的仓库,其容量有限(分别为N),但要求仓库中A、B两种物品的数量满足下述不等式: -M≤A物品数量-B物品数量≤N 其中M和N为正整数。另外,还有一个进程消费A,B,一次取一个A,B组装成C。 试用信号量和PV操作描述A、B两种物品的入库过程。</p>\n<p>因为0&lt;=A,B&lt;=N,所以A-B&lt;=恒成立&#xff0c;所以可以去掉一个条件。另&#xff0c;原题所附的伪代码有误&#xff0c;修改后semaphore和lock两种方式的伪代码如下&#xff1a;</p>\n<p>1、semaphore</p>\n<p>semaphore mutex=1,diff=m,empty1=N,empty2=N,full1,full2=0;<br />cobegin<br />process(A);<br />process(B);<br />process(C)<br />coend<br />// A物品入库<br />process A<br />begin<br />while(TRUE)<br />begin<br />p(empty1);<br />p(mutex);<br />A物品入库;<br />v(mutex);<br />v(full1);</p>\n<p>v(diff);<br />end<br />end<br />// B物品入库&#xff1a;<br />process B<br />begin<br />while(TRUE)<br />begin<br />p(empty2);<br />p(diff);<br /><br />p(mutex);<br />B物品入库;<br />v(mutex);<br />v(full2);<br />end<br />end<br />// process C<br />begin<br />while(TRUE)<br />begin<br />p(full1);<br />p(full2);<br />p(mutex);<br />组装;<br />v(mutex);<br />v(empty1);<br />v(empty2);<br />end<br />end</p>\n<p></p>\n<p>2、lock伪代码</p>\n<p><br />procedure producerA() {<br />lock-&gt;Acquire();<br />while (countA == n)<br />admit_A.Wait(&amp;lock);<br /><br />Add A to the buffer;<br />countA&#43;&#43;;<br /><br />admit_B.Signal();<br />admit_C.signal();<br />lock-&gt;Release();<br />}</p>\n<p><br />procedure producerB() {<br />lock-&gt;Acquire();<br />while (countB == n || countA-countB&lt;=-M)<br />admit_B.Wait(&amp;lock);<br /><br />Add B to the buffer;<br />countB&#43;&#43;;</p>\n<p>admit_A.Signal();<br />admit_C.signal();<br />lock-&gt;Release();<br />}</p>\n<p>procedure consumer() {<br />lock-&gt;Acquire();<br />while (countA==0 || countB == 0)<br />admit_C.Signal();<br />countA--;<br />countB--;</p>\n<p>admit_A.Signal();<br />admit_B.signal();<br />lock-&gt;Release(); <br />}</p>\n<p></p>\n<p><em><strong>对应的python代码</strong></em></p>\n<p>semaphore方法&#xff1a;</p>\n<pre>import multiprocessing\nimport time\ndef producerA(mutex,empty1,full1,diff,i):\n    print(&#34;ready to produce A&#34;)\n    empty1.acquire()\n    mutex.acquire()\n    # print(multiprocessing.current_process().name &#43; &#34; acquire&#34;)\n    print(&#34;producing A succeed&#34;)\n    time.sleep(i)\n    # print(multiprocessing.current_process().name &#43; &#34; release&#34;)\n    mutex.release()\n    full1.release()\n\n    diff.release()\n\ndef producerB(mutex,empty2,full2,diff,i):\n    print(&#34;ready to produce B&#34;)\n    empty2.acquire()\n    diff.acquire()\n    mutex.acquire()\n\n    print(&#34;producing B succeed&#34;)\n    time.sleep(i)\n    \n    mutex.release()\n    full2.release()\n\ndef consumer(mutex,empty1,empty2,full1,full2,i):\n    print(&#34;ready to cosume&#34;)\n    full1.acquire()\n    full2.acquire()\n    mutex.acquire()\n    \n    print(&#34;cosuming suceed&#34;)\n    time.sleep(i)\n\n    mutex.release()\n    empty1.release()\n    empty2.release()\n    \nif __name__ == &#34;__main__&#34;:\n    N = 10\n    m = 5\n    full1 = multiprocessing.Semaphore(0)\n    full2 = multiprocessing.Semaphore(0)\n    empty1 = multiprocessing.Semaphore(N)\n    empty2 = multiprocessing.Semaphore(N)\n    \n    diff = multiprocessing.Semaphore(m)\n    mutex = multiprocessing.Semaphore(1)\n\n    for i in range(5):\n        pa = multiprocessing.Process(target=producerA, args=(mutex,empty1,full1,diff,i*2))\n        pa.start()\n        pb = multiprocessing.Process(target=producerB, args=(mutex,empty2,full2,diff,i*2))\n        pb.start()\n        c = multiprocessing.Process(target=consumer, args=(mutex,empty1,empty2,full1,full2,i*2))</pre>\n<p>condition代码&#xff1a;</p>\n<pre>import threading  <br />import time  <br /><br />#countA means the amounts of A in storage. samely,countB means the amount of B.<br />condition = threading.Condition()<br />countA = 0<br />countB = 0<br />N = 10<br />M = 5<br /><br />#threadA: add one A to the storage<br />class ProducerA(threading.Thread):  <br />    def __init__(self):  <br />        threading.Thread.__init__(self)  <br />          <br />    def run(self):  <br />        global condition, countA, N, M<br />        while True:  <br />            if condition.acquire():  <br />                if countA &lt; N:  <br />                    countA &#43;= 1;  <br />                    print &#34;ProducerA():deliver one, now countA:%s&#34; %countA  <br />                    condition.notify()  <br />                else:  <br />                    print &#34;ProducerA():already %s, stop deliver, now countA:%s&#34; %(N, countA)  <br />                    condition.wait();  <br />                condition.release()  <br />                time.sleep(2)  <br /><br />#threadB: add one B to the storage<br />class ProducerB(threading.Thread):  <br />    def __init__(self):  <br />        threading.Thread.__init__(self)  <br />          <br />    def run(self):  <br />        global condition,countA,countB,N,M<br />        while True:  <br />            if condition.acquire():  <br />                if (countB &lt; N and countA-countB &gt; -M):  <br />                    countB &#43;= 1;  <br />                    print &#34;ProducerB():deliver one, now countB:%s&#34; %countB  <br />                    condition.notify()  <br />                else:  <br />                    print &#34;ProducerB():already %s, stop deliver, now countA:%s&#34; %(N, countB)  <br />                    condition.wait();  <br />                condition.release()  <br />                time.sleep(2)  <br />          <br />      <br />#threadC: consume one A and one B in storage,then create one C   <br />class Consumer(threading.Thread):  <br />    def __init__(self):  <br />        threading.Thread.__init__(self)  <br />          <br />    def run(self):  <br />        global condition,countA,countB<br />        while True:  <br />            if condition.acquire():  <br />                if (countA&gt;0 and countB&gt;0):  <br />                \t# consume a pair of A&amp;B<br />                    countA -= 1;<br />                    countB -= 1;<br />                    print &#34;Consumer():consume one A and one B, now countA:%s countB:%s&#34; %(countA, countB)  <br />                    condition.notify()  <br />                else:  <br />                \t# lack of A or B in storage<br />                    print &#34;Consumer():lack of resource,not runnable&#34; %(self.name, products)  <br />                    condition.wait();  <br />                condition.release()  <br />                time.sleep(2)  <br />                  <br />if __name__ == &#34;__main__&#34;:<br />    for i in range(0,10):<br />        pa = ProducerA()<br />        pa.start()<br />        pb = ProducerB()  <br />        pb.start()  <br />          <br />    for c in range(0, 8):  <br />        c = Consumer()  <br />        c.start() </pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T14:29:41Z", "no_upvotes": 0, "uid": "i718aanx0OS", "created": "2015-05-06T14:29:41Z", "type": "followup", "no_answer": 1, "id": "i9cucxvhno9zv", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>2012011359 路云飞</p>\n<p></p>\n<p>31.  面包店(2001) 面包师有很多面包&#xff0c;由n个销售人员推销。每人顾客进店后先取一个号&#xff0c;并且等待叫号。当一个销售人员空闲下来时&#xff0c;就叫下一个号。试设计一个使销售人员和顾客同步的算法。</p>\n<p></p>\n<p>信号量&#xff1a;</p>\n<p></p>\n<pre>#coding=utf-8<br />import threading<br />import Queue<br />import time<br />import random  <br /><br />n = 5<br />m = 20<br />total = 0<br />q = Queue.Queue(0);<br /><br />class Customer(threading.Thread)<br />    def __init__(self, sem):<br />       threading.Thread.__init__(self)<br />       self.threadSemaphore = sem<br />    def run(self):<br />    \tglobal customer_count<br />    \twhile True:<br />    \t\tself.number = total&#43;&#43;<br />    \t\tself.threadSemaphore.acquire()  <br />    \t\tq.put(self.number)<br />    \t\tprint &#34;Customer %d now waiting in the queue...&#34; % (int(self.number))<br />    \t\tself.threadSemaphore.release()<br /><br />class Saler(threading.Thread)<br />    def __init__(self, sem, n):<br />       threading.Thread.__init__(self)<br />       self.threadSemaphore = sem<br />       self.number = n<br />    def run(self):<br />    \twhile True:<br />    \t\tself.threadSemaphore.acquire()  <br />    \t\tself.serve = q.pop()<br />    \t\tprint &#34;Saler %d now saling bread to Customer %d...&#34; % (int(self.number), int(self.serve))<br />    \t\tself.threadSemaphore.release()<br />          \ttime.sleep(random.randrange(1, 3))<br /><br />threads = []<br />semaphore = threading.Semaphore(1)<br />for i in range(1, n):  <br />   threads.append(Customer(semaphore))  <br />for i in range(1, m):<br />    threads.append(Saler(semaphore, i))<br />for t in threads: <br />   thread.start()</pre>\n<p></p>\n<p>条件变量</p>\n<p></p>\n<pre>#coding=utf-8\nimport threading\nimport Queue\nimport time\nimport random  \n\nn = 5\nm = 20\ntotal = 0\ncond = threading.Condition()\nq = Queue.Queue(0);\n\nclass Customer(threading.Thread)\n    def __init__(self):\n       threading.Thread.__init__(self)\n    def run(self):\n    \tglobal customer_count\n    \twhile True:\n    \t\tself.number = total&#43;&#43;\n        if cond.acquire():\n    \t\t  q.put(self.number)\n    \t\t  print &#34;Customer %d now waiting in the queue...&#34; % (int(self.number))\n          cond.notify()\n    \t\tcond.release()\n\nclass Saler(threading.Thread)\n    def __init__(self, n):\n       threading.Thread.__init__(self)\n       self.number = n\n    def run(self):\n    \twhile True:\n    \t\tif cond.acquire(): \n    \t\t  self.serve = q.pop()\n    \t\t  print &#34;Saler %d now saling bread to Customer %d...&#34; % (int(self.number), int(self.serve))\n    \t\t  cond.notify()\n        cond.release()\n        time.sleep(random.randrange(1, 3))\n\nthreads = []\nsemaphore = threading.Semaphore(1)\nfor i in range(1, n):  \n   threads.append(Customer())  \nfor i in range(1, m):\n    threads.append(Saler(i))\nfor t in threads: \n   thread.start()</pre>\n<p></p>"}, {"folders": [], "updated": "2015-05-06T15:13:02Z", "no_upvotes": 0, "uid": "i6rwsr9cEcQ", "created": "2015-05-06T15:13:02Z", "type": "followup", "no_answer": 1, "id": "i9cvwp18hsa20v", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>2012011382   李浩达</p>\n<p>38题:博物馆-公园问题</p>\n<p>Condition:<br />&#96;&#96;&#96;<br />#coding=utf-8<br />import threading <br />import random <br />import time</p>\n<p><br />taxi_num = 3;<br />person_num = 8;</p>\n<p><br />per_sem = Cond(0);<br />tax_sem = Cond(taxi_num);<br />mutex_sem = Cond(1);<br />start_sem = Cond(0);</p>\n<p><br />class Cond():</p>\n<p>def __init__(self,num):<br /> self.num = num<br /> self.condition = threading.Condition()<br /> def acquire(self):<br /> if self.condition.acquire():<br /> if self.num&gt;=1:<br /> self.num=self.num-1<br /> self.condition.notify()<br /> else:<br /> self.condition.wait()<br /> self.condition.release()<br /> def release(self):<br /> if self.condition.acquire():<br /> self.num=self.num&#43;1<br /> self.condition.notify()<br /> self.condition.release()</p>\n<p>class Taxi(threading.Thread): <br /> def __init__(self): <br /> threading.Thread.__init__(self)<br /> <br /> def run(self):</p>\n<p>global per_sem<br /> global tax_sem<br /> global mutex_sem<br /> global start_sem<br /> while True:<br /> print &#34;taxi %s waiting\\n&#34; % self.name,<br /> per_sem.acquire();<br /> mutex_sem.release();<br /> print &#34;taxi %s start\\n&#34; % self.name,<br /> time.sleep(1);<br /> start_sem.release();</p>\n<p>class Person(threading.Thread): <br /> def __init__(self):<br /> threading.Thread.__init__(self) <br /> <br /> def run(self):<br /> global per_sem<br /> global tax_sem<br /> global mutex_sem<br /> global start_sem</p>\n<p>print &#34;preson %s wait for taxi\\n&#34; % self.name,<br /> tax_sem.acquire();<br /> mutex_sem.acquire();<br /> per_sem.release();<br /> print &#34;preson %s start\\n&#34; % self.name,<br /> start_sem.acquire();<br /> print &#34;preson %s end\\n&#34; % self.name,<br /> tax_sem.release();</p>\n<p><br />if __name__ == &#34;__main__&#34;:<br /> for p in range(0, person_num): <br /> per = Person() <br /> per.start()</p>\n<p>for t in range(0, tax_num): <br /> tax = Taxi() <br /> tax.start()<br />&#96;&#96;&#96;</p>\n<p>Semaphore:<br />&#96;&#96;&#96;<br />#coding=utf-8<br />import threading <br />import random <br />import time</p>\n<p>tax_num = 2;<br />person_num = 5;</p>\n<p>per_sem=threading.Semaphore(0);<br />tax_sem=threading.Semaphore(tax_num);<br />mutex_sem =threading.Semaphore(1);<br />start_sem = threading.Semaphore(0);</p>\n<p>class Taxi(threading.Thread): <br /> def __init__(self): <br /> threading.Thread.__init__(self)<br /> <br /> def run(self):</p>\n<p>global per_sem<br /> global tax_sem<br /> global mutex_sem<br /> global start_sem<br /> while True:<br /> print &#34;taxi %s waiting\\n&#34; % self.name,<br /> per_sem.acquire();<br /> mutex_sem.release();<br /> print &#34;taxi %s start\\n&#34; % self.name,<br /> time.sleep(1);<br /> start_sem.release();</p>\n<p>class Person(threading.Thread): <br /> def __init__(self):<br /> threading.Thread.__init__(self) <br /> <br /> def run(self):<br /> global per_sem<br /> global tax_sem<br /> global mutex_sem<br /> global start_sem</p>\n<p>print &#34;preson %s wait for taxi\\n&#34; % self.name,<br /> tax_sem.acquire();<br /> mutex_sem.acquire();<br /> per_sem.release();<br /> print &#34;preson %s start\\n&#34; % self.name,<br /> start_sem.acquire();<br /> print &#34;preson %s end\\n&#34; % self.name,<br /> tax_sem.release();<br /> <br />if __name__ == &#34;__main__&#34;:<br /> <br /> for p in range(0, person_num): <br /> p = Person() <br /> p.start()</p>\n<p>for c in range(0, tax): <br /> c = Taxi() <br /> c.start() <br />&#96;&#96;&#96;</p>"}, {"folders": [], "updated": "2015-05-06T17:02:54Z", "no_upvotes": 0, "uid": "i6urm1j1ynv6sm", "created": "2015-05-06T17:02:54Z", "type": "followup", "no_answer": 1, "id": "i9cztzf86z74mr", "anon": "no", "bucket_name": "Week 5/3 - 5/9", "config": {}, "bucket_order": 108, "data": null, "children": [], "subject": "<p>2012011308 陆喆</p>\n<p>30题 P,V改错&#xff08;2001&#xff09;</p>\n<p>condition: <a href=\"https://github.com/lbx6z/ucore_lab/blob/master/related_info/lab7/condition.py\" target=\"_blank\">https://github.com/lbx6z/ucore_lab/blob/master/related_info/lab7/condition.py</a></p>\n<p>semaphore: <a href=\"https://github.com/lbx6z/ucore_lab/blob/master/related_info/lab7/semaphore.py\" target=\"_blank\">https://github.com/lbx6z/ucore_lab/blob/master/related_info/lab7/semaphore.py</a></p>"}, {"folders": [], "updated": "2015-06-03T12:42:50Z", "no_upvotes": 0, "uid": "i8o4iar88jf5mz", "created": "2015-06-03T12:42:50Z", "type": "followup", "no_answer": 1, "id": "iagqvdrt7g51oh", "anon": "no", "bucket_name": "Week 5/31 - 6/6", "config": {}, "bucket_order": 104, "data": null, "children": [{"folders": [], "updated": "2015-06-03T12:43:58Z", "uid": "i8o4iar88jf5mz", "created": "2015-06-03T12:43:58Z", "type": "feedback", "id": "iagqwus1zpc1wg", "anon": "no", "bucket_name": "Week 5/31 - 6/6", "config": {}, "bucket_order": 104, "data": null, "children": [], "subject": "<p>读者优先输出&#xff1a;</p>\n<pre>================Test Case1================\nQueue:\nWriter 100\nReader 50\nReader 50\nReader 50\nWriter 100\nReader 100\n:                                      :\n/--------------Write Begin---------------\\\n\t* Writer 0 is writing...\n\t[-Read 0 go to wait-]\n\t[-Read 1 go to wait-]\n\t[-Read 2 go to wait-]\n\t[-Writer 1 go to wait-]\n\t[-Read 3 go to wait-]\n\t* Writer 0 finished writing...\n\\--------------Write Finish--------------/\n\t[-Read 1 go out wait-]\n/--------------Read Begin---------------\\\n\t* Read 1 is reading...\n\t[-Read 3 go out wait-]\n\t* Read 3 is reading...\n\t[-Read 2 go out wait-]\n\t* Read 2 is reading...\n\t[-Read 0 go out wait-]\n\t* Read 0 is reading...\n\t* Read 0 finished reading...\n\t* Read 2 finished reading...\n\t* Read 1 finished reading...\n\t* Read 3 finished reading...\n\\--------------Read Finish--------------/\n\t[-Writer 1 go out wait-]\n/--------------Write Begin---------------\\\n\t* Writer 1 is writing...\n\t* Writer 1 finished writing...\n\\--------------Write Finish--------------/\n========================================\n\n================Test Case2================\nQueue:\nReader 100\nReader 100\nWriter 200\nWriter 300\nReader 50\nWriter 100\nReader 300\n:                                      :\n/--------------Read Begin---------------\\\n\t* Read 0 is reading...\n\t* Read 1 is reading...\n\t[-Writer 0 go to wait-]\n\t[-Writer 1 go to wait-]\n\t* Read 2 is reading...\n\t[-Writer 2 go to wait-]\n\t* Read 3 is reading...\n\t* Read 2 finished reading...\n\t* Read 0 finished reading...\n\t* Read 1 finished reading...\n\t* Read 3 finished reading...\n\\--------------Read Finish--------------/\n\t[-Writer 0 go out wait-]\n/--------------Write Begin---------------\\\n\t* Writer 0 is writing...\n\t* Writer 0 finished writing...\n\\--------------Write Finish--------------/\n\t[-Writer 1 go out wait-]\n/--------------Write Begin---------------\\\n\t* Writer 1 is writing...\n\t* Writer 1 finished writing...\n\\--------------Write Finish--------------/\n\t[-Writer 2 go out wait-]\n/--------------Write Begin---------------\\\n\t* Writer 2 is writing...\n\t* Writer 2 finished writing...\n\\--------------Write Finish--------------/\n========================================\n</pre>\n<p></p>"}, {"folders": [], "updated": "2015-06-03T15:14:06Z", "uid": "hdjonbiyfs62ie", "created": "2015-06-03T15:14:06Z", "type": "feedback", "id": "iagw9wvu4ma5ur", "anon": "no", "bucket_name": "Week 5/31 - 6/6", "config": {}, "bucket_order": 104, "data": null, "children": [], "subject": "<p>在 2015年6月3日&#xff0c;下午11:11&#xff0c;xyong &lt;xyong&#64;mail.tsinghua.edu.cn&gt; 写道&#xff1a;</p>\n<p>我也看了你的读者写者问题实现&#xff0c;认为基本是正确的。如果可能&#xff0c;请尝试对比教材上对写者优先的实现方法&#xff0c;并给出一组尽可能全面的测试用例来理解这种区别。如何&#xff1f;</p>\n<p>--向勇</p>\n<p></p>\n<p>在 2015年6月3日&#xff0c;下午8:45&#xff0c;杨博文 &lt;vanhex&#64;163.com&gt; 写道&#xff1a;</p>\n<p></p>\n<p>这里我完成了已经提交到piazza以及gitlab<br /> https://piazza.com/class/i5j09fnsl7k5x0?cid=390<br /> http://south.cs.tsinghua.edu.cn/dc9d37e59d104e819c2b/spoc/blob/master/all/reader_writer.md<br /> 请老师查看一下。<br /> 谢谢&#xff01;</p>"}], "subject": "<p>读者写者问题&#xff1a;</p>\n<pre>写者优先&#xff1a;<br />#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nusing namespace std;\n#define NTHREAD 110\n#define MAX_REANDER 10\n#define MAX_WRITER 1\n#define NWRITER 1000\n#define NREADER 1000\n#define MAXQUE 1000\n\nint reading, writing, wait2read, wait2write;\nHANDLE lock, s_write, s_read;\nint cou_writer, cou_reader;\nclass Queue{\npublic:\n\tint cou;\n\tint rec[MAXQUE][2];\n\tQueue(){\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tcou=0;\n\t}\n\tint insert(int p, int time){\n\t\tif (cou &gt;= MAXQUE) return 1;\n\t\tthis-&gt;rec[cou][0]=p;\n\t\tthis-&gt;rec[cou][1]=time;\n\t\tcou&#43;&#43;;\n\t\treturn 0;\n\t}\n\tint getP(int t){\n\t\tif (t &gt;= cou) return -1;\n\t\treturn this-&gt;rec[t][0];\n\t}\n\tint getTime(int t){\n\t\tif (t &gt;= cou) return -1;\n\t\treturn this-&gt;rec[t][1];\n\t}\n};\nQueue queue;\nclass Reader{\n\tint no, time;\npublic:\n\tReader(int no, int time){\n\t\tthis-&gt;no = no;\n\t\tthis-&gt;time = time;\n\t}\n\t\n\tstatic DWORD WINAPI deal(void* para){\n\t\tReader* reader = (Reader *)para;\n\t\tWaitForSingleObject(lock, INFINITE);\n\t\tif (wait2write&#43;writing &gt; 0){\n\t\t\twait2read&#43;&#43;;\n\t\t\tprintf(&#34;\\t[-Read %d go to wait-]\\n&#34;, reader-&gt;no);\n\t\t\tReleaseSemaphore(lock, 1, NULL);\n\t\t\tWaitForSingleObject(s_read, INFINITE);\n\t\t\tWaitForSingleObject(lock, INFINITE);\n\t\t\twait2read--;\n\t\t\tprintf(&#34;\\t[-Read %d go out wait-]\\n&#34;, reader-&gt;no);\n\t\t}\n\t\tif (reading&#43;&#43; == 0){\n\t\t\tprintf(&#34;/--------------Read Begin---------------\\\\\\n&#34;);\n\t\t}\n\t\tReleaseSemaphore(lock, 1, NULL);\n\t\t\n\t\tprintf(&#34;\\t* Read %d is reading...\\n&#34;, reader-&gt;no);\n\t\tSleep(reader-&gt;time);\n\t\tprintf(&#34;\\t* Read %d finished reading...\\n&#34;, reader-&gt;no);\n\t\t\n\t\tWaitForSingleObject(lock, INFINITE);\n\t\tif (--reading == 0){\n\t\t\tprintf(&#34;\\\\--------------Read Finish--------------/\\n&#34;);\n\t\t}\n\t\tif (reading ==0 &amp;&amp; wait2write &gt; 0){\n\t\t\tReleaseSemaphore(s_write, 1, NULL);\n\t\t}\n\t\tReleaseSemaphore(lock, 1, NULL);\n\t}\n\t\n};\nclass Writer{\n\tint no, time;\npublic:\n\tWriter(int no, int time){\n\t\tthis-&gt;no = no;\n\t\tthis-&gt;time = time;\n\t}\n\t\n\tstatic DWORD WINAPI deal(void* para){\n\t\tWriter* writer = (Writer *)para;\n\t\tWaitForSingleObject(lock, INFINITE);\n\t\tif (reading&#43;writing &gt;0){\n\t\t\twait2write&#43;&#43;;\n\t\t\tprintf(&#34;\\t[-Writer %d go to wait-]\\n&#34;, writer-&gt;no);\n\t\t\tReleaseSemaphore(lock, 1, NULL);\n\t\t\tWaitForSingleObject(s_write, INFINITE);\n\t\t\tWaitForSingleObject(lock, INFINITE);\n\t\t\twait2write--;\n\t\t\tprintf(&#34;\\t[-Writer %d go out wait-]\\n&#34;, writer-&gt;no);\n\t\t}\n\t\twriting&#43;&#43;;\n\t\tReleaseSemaphore(lock, 1, NULL);\n\t\tprintf(&#34;/--------------Write Begin---------------\\\\\\n&#34;);\n\t\tprintf(&#34;\\t* Writer %d is writing...\\n&#34;, writer-&gt;no);\n\t\tSleep(writer-&gt;time);\n\t\tprintf(&#34;\\t* Writer %d finished writing...\\n&#34;, writer-&gt;no);\n\t\tprintf(&#34;\\\\--------------Write Finish--------------/\\n&#34;);\n\t\t\n\t\tWaitForSingleObject(lock, INFINITE);\n\t\twriting--;\n\t\tif (wait2write &gt; 0){\n\t\t\tReleaseSemaphore(s_write, 1, NULL);\n\t\t}else{\n\t\t\tif (wait2read &gt; 0){\n\t\t\t\tReleaseSemaphore(s_read, wait2read, NULL);\n\t\t\t}\n\t\t}\n\t\tReleaseSemaphore(lock, 1, NULL);\n\t}\n\t\n\tint getNo(){\n\t\treturn this-&gt;no;\n\t}\n};\nvoid init(){\n\tlock = CreateSemaphore(NULL, 1, 1, NULL);\n\ts_read = CreateSemaphore(NULL, 0, MAX_REANDER, NULL);\n\ts_write = CreateSemaphore(NULL, 0, MAX_WRITER, NULL);\n}\nvoid run(){\n\tcou_writer=0;\n\tcou_reader=0;\n\tint p, time;\n\tHANDLE thread[NTHREAD];\n\tReader* reader[NREADER];\n\tWriter* writer[NWRITER];\n\tint nthread = 0;\n\tprintf(&#34;Queue:\\n&#34;);\n\tfor (int i=0; i&lt;queue.cou; i&#43;&#43;){\n\t\tp = queue.getP(i);\n\t\ttime = queue.getTime(i);\n\t\tif (p) printf(&#34;Writer %d\\n&#34;, time);\n\t\telse printf(&#34;Reader %d\\n&#34;, time);\n\t}\n\tprintf(&#34;:                                      :\\n&#34;);\n\tfor (int i=0; i&lt;queue.cou; i&#43;&#43;){\n\t\tp = queue.getP(i);\n\t\ttime = queue.getTime(i);\n\t\tif (p==0){\n\t\t\treader[cou_reader] = new Reader(cou_reader, time);\n\t\t\tthread[nthread&#43;&#43;] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Reader::deal, (void*) reader[cou_reader&#43;&#43;], 0, NULL);\n\t\t}else{\n\t\t\twriter[cou_writer] = new Writer(cou_writer, time);\n\t\t\tthread[nthread&#43;&#43;] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Writer::deal, (void*) writer[cou_writer&#43;&#43;], 0, NULL);\n\t\t}\n\t\tSleep(10);\n\t}\n\tfor (int i=0; i&lt;nthread; i&#43;&#43;)\n\t\tWaitForSingleObject(thread[i], INFINITE);\n\tfor (int i=0; i&lt;nthread; i&#43;&#43;)\n\t\tCloseHandle(thread[i]);\n}\nvoid testcase1(){\n\tprintf(&#34;================Test Case1================\\n&#34;);\n\tqueue.init();\n\tqueue.insert(1, 100);\n\tqueue.insert(0, 50);\n\tqueue.insert(0, 50);\n\tqueue.insert(0, 50);\n\tqueue.insert(1, 100);\n\tqueue.insert(0, 100);\n\trun();\n\tprintf(&#34;========================================\\n\\n&#34;);\n}\nvoid testcase2(){\n\tprintf(&#34;================Test Case2================\\n&#34;);\n\tqueue.init();\n\tqueue.insert(0, 100);\n\tqueue.insert(0, 100);\n\tqueue.insert(1, 200);\n\tqueue.insert(1, 300);\n\tqueue.insert(0, 50);\n\tqueue.insert(1, 100);\n\tqueue.insert(0, 300);\n\trun();\n\tprintf(&#34;========================================\\n\\n&#34;);\n}\nint main(){\n\tinit();\n\ttestcase1();\n\ttestcase2();\n\tsystem(&#34;pause&#34;);\n\treturn 0;\n}\n输出&#xff1a;<br />================Test Case1================\nQueue:\nWriter 100\nReader 50\nReader 50\nReader 50\nWriter 100\nReader 100\n:                                      :\n/--------------Write Begin---------------\\\n\t* Writer 0 is writing...\n\t[-Read 0 go to wait-]\n\t[-Read 1 go to wait-]\n\t[-Read 2 go to wait-]\n\t[-Writer 1 go to wait-]\n\t[-Read 3 go to wait-]\n\t* Writer 0 finished writing...\n\\--------------Write Finish--------------/\n\t[-Writer 1 go out wait-]\n/--------------Write Begin---------------\\\n\t* Writer 1 is writing...\n\t* Writer 1 finished writing...\n\\--------------Write Finish--------------/\n\t[-Read 3 go out wait-]\n/--------------Read Begin---------------\\\n\t* Read 3 is reading...\n\t[-Read 2 go out wait-]\n\t* Read 2 is reading...\n\t[-Read 1 go out wait-]\n\t* Read 1 is reading...\n\t[-Read 0 go out wait-]\n\t* Read 0 is reading...\n\t* Read 1 finished reading...\n\t* Read 2 finished reading...\n\t* Read 0 finished reading...\n\t* Read 3 finished reading...\n\\--------------Read Finish--------------/\n========================================\n\n================Test Case2================\nQueue:\nReader 100\nReader 100\nWriter 200\nWriter 300\nReader 50\nWriter 100\nReader 300\n:                                      :\n/--------------Read Begin---------------\\\n\t* Read 0 is reading...\n\t* Read 1 is reading...\n\t[-Writer 0 go to wait-]\n\t[-Writer 1 go to wait-]\n\t[-Read 2 go to wait-]\n\t[-Writer 2 go to wait-]\n\t[-Read 3 go to wait-]\n\t* Read 0 finished reading...\n\t* Read 1 finished reading...\n\\--------------Read Finish--------------/\n\t[-Writer 0 go out wait-]\n/--------------Write Begin---------------\\\n\t* Writer 0 is writing...\n\t* Writer 0 finished writing...\n\\--------------Write Finish--------------/\n\t[-Writer 1 go out wait-]\n/--------------Write Begin---------------\\\n\t* Writer 1 is writing...\n\t* Writer 1 finished writing...\n\\--------------Write Finish--------------/\n\t[-Writer 2 go out wait-]\n/--------------Write Begin---------------\\\n\t* Writer 2 is writing...\n\t* Writer 2 finished writing...\n\\--------------Write Finish--------------/\n\t[-Read 2 go out wait-]\n/--------------Read Begin---------------\\\n\t* Read 2 is reading...\n\t[-Read 3 go out wait-]\n\t* Read 3 is reading...\n\t* Read 2 finished reading...\n\t* Read 3 finished reading...\n\\--------------Read Finish--------------/\n========================================\n\n读者优先&#xff1a;<br />#include &lt;windows.h&gt;\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nusing namespace std;\n#define NTHREAD 110\n#define MAX_REANDER 10\n#define MAX_WRITER 1\n#define NWRITER 1000\n#define NREADER 1000\n#define MAXQUE 1000\n\nint reading, writing, wait2read, wait2write;\nHANDLE lock, s_write, s_read;\nint cou_writer, cou_reader;\nclass Queue{\npublic:\n\tint cou;\n\tint rec[MAXQUE][2];\n\tQueue(){\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tcou=0;\n\t}\n\tint insert(int p, int time){\n\t\tif (cou &gt;= MAXQUE) return 1;\n\t\tthis-&gt;rec[cou][0]=p;\n\t\tthis-&gt;rec[cou][1]=time;\n\t\tcou&#43;&#43;;\n\t\treturn 0;\n\t}\n\tint getP(int t){\n\t\tif (t &gt;= cou) return -1;\n\t\treturn this-&gt;rec[t][0];\n\t}\n\tint getTime(int t){\n\t\tif (t &gt;= cou) return -1;\n\t\treturn this-&gt;rec[t][1];\n\t}\n};\nQueue queue;\nclass Reader{\n\tint no, time;\npublic:\n\tReader(int no, int time){\n\t\tthis-&gt;no = no;\n\t\tthis-&gt;time = time;\n\t}\n\t\n\tstatic DWORD WINAPI deal(void* para){\n\t\tReader* reader = (Reader *)para;\n\t\tWaitForSingleObject(lock, INFINITE);\n\t\tif (writing &gt; 0){\n\t\t\twait2read&#43;&#43;;\n\t\t\tprintf(&#34;\\t[-Read %d go to wait-]\\n&#34;, reader-&gt;no);\n\t\t\tReleaseSemaphore(lock, 1, NULL);\n\t\t\tWaitForSingleObject(s_read, INFINITE);\n\t\t\tWaitForSingleObject(lock, INFINITE);\n\t\t\twait2read--;\n\t\t\tprintf(&#34;\\t[-Read %d go out wait-]\\n&#34;, reader-&gt;no);\n\t\t}\n\t\tif (reading&#43;&#43; == 0){\n\t\t\tprintf(&#34;/--------------Read Begin---------------\\\\\\n&#34;);\n\t\t}\n\t\tReleaseSemaphore(lock, 1, NULL);\n\t\t\n\t\tprintf(&#34;\\t* Read %d is reading...\\n&#34;, reader-&gt;no);\n\t\tSleep(reader-&gt;time);\n\t\tprintf(&#34;\\t* Read %d finished reading...\\n&#34;, reader-&gt;no);\n\t\t\n\t\tWaitForSingleObject(lock, INFINITE);\n\t\tif (--reading == 0){\n\t\t\tprintf(&#34;\\\\--------------Read Finish--------------/\\n&#34;);\n\t\t}\n\t\tif (reading &#43; wait2read ==0 &amp;&amp; wait2write &gt; 0){\n\t\t\tReleaseSemaphore(s_write, 1, NULL);\n\t\t}\n\t\tReleaseSemaphore(lock, 1, NULL);\n\t}\n\t\n};\nclass Writer{\n\tint no, time;\npublic:\n\tWriter(int no, int time){\n\t\tthis-&gt;no = no;\n\t\tthis-&gt;time = time;\n\t}\n\t\n\tstatic DWORD WINAPI deal(void* para){\n\t\tWriter* writer = (Writer *)para;\n\t\tWaitForSingleObject(lock, INFINITE);\n\t\tif (reading&#43;wait2read&#43;writing &gt;0){\n\t\t\twait2write&#43;&#43;;\n\t\t\tprintf(&#34;\\t[-Writer %d go to wait-]\\n&#34;, writer-&gt;no);\n\t\t\tReleaseSemaphore(lock, 1, NULL);\n\t\t\tWaitForSingleObject(s_write, INFINITE);\n\t\t\tWaitForSingleObject(lock, INFINITE);\n\t\t\twait2write--;\n\t\t\tprintf(&#34;\\t[-Writer %d go out wait-]\\n&#34;, writer-&gt;no);\n\t\t}\n\t\twriting&#43;&#43;;\n\t\tReleaseSemaphore(lock, 1, NULL);\n\t\tprintf(&#34;/--------------Write Begin---------------\\\\\\n&#34;);\n\t\tprintf(&#34;\\t* Writer %d is writing...\\n&#34;, writer-&gt;no);\n\t\tSleep(writer-&gt;time);\n\t\tprintf(&#34;\\t* Writer %d finished writing...\\n&#34;, writer-&gt;no);\n\t\tprintf(&#34;\\\\--------------Write Finish--------------/\\n&#34;);\n\t\t\n\t\t</pre>"}, {"folders": [], "updated": "2017-04-28T08:35:38Z", "no_upvotes": 0, "uid": "i7bgifux1OH", "created": "2017-04-28T08:35:38Z", "type": "followup", "no_answer": 1, "id": "j21l2j3gocp5i", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>进程同步问题&#xff1a;P,V改错(2001)</p>\n<p>牛行知 2014011313</p>\n<p>张光耀 2012011403</p>\n<p>测试代码&#xff1a;<a href=\"https://github.com/Brightzh/os_spoc/blob/master/PV.c\" target=\"_blank\">https://github.com/Brightzh/os_spoc/blob/master/PV.c</a></p>\n<p>输出结果&#xff1a;<a href=\"https://github.com/Brightzh/os_spoc/blob/master/output\" target=\"_blank\">https://github.com/Brightzh/os_spoc/blob/master/output</a></p>\n<p>//TODO</p>"}], "nr": 390, "bucket_order": 2, "type": "note", "folders": ["lecture18", "课堂问答"], "no_answer_followup": 29, "num_favorites": 2, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2015-05-06T05:48:48Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1493393419519, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p></p>", "anon": "no", "created": "2016-04-28T14:22:05Z", "uid": "hdjonbiyfs62ie", "subject": "lec18 spoc 提交处"}, {"content": "<p></p>", "anon": "no", "created": "2015-05-06T05:48:48Z", "uid": "hcrrjuyequh4bt", "subject": "lec18 spoc 提交处"}]}, "error": null}