{"aid": "igkp1rutszp4ja", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 6, "request_instructor": 0, "history": [{"uid": "i76zykkduDo", "anon": "no", "created": "2015-03-17T05:18:24Z", "content": "<p>本章将给出xv6多处理器支持的实现概貌。读者将学习以下一些内容: </p>\n<ul><li>什么是SMP系统&#xff1f; </li><li>什么是PIC&#xff0c;LAPIC&#xff0c;IOAPIC?</li><li>xv6是如何识别一个计算机系统中的多个CPU的&#xff1f; </li><li>xv6是如何支持CPU之间的中断信息传递的&#xff1f; </li><li>xv6如何初始化主处理器&#xff08;BP&#xff09;和从处理器&#xff08;AP&#xff09;的&#xff1f; </li></ul>\n<p> </p>\n<p>    xv6的一个独特之处在于它支持基于多处理器的计算机系统&#xff0c;即对称多处理计算机系统。SMP是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。它是应用十分广泛的并行技术。在这种架构中&#xff0c;一台电脑不再由单个处理器组成&#xff0c;而同时由多个处理器运行操作系统的单一复本&#xff0c;并共享内存和一台计算机的其他资源。虽然同时使用多个处理器&#xff0c;但是从管理的角度来看&#xff0c;它们的表现就像一台单处理器的计算机一样。系统将任务队列对称地分布于多个处理器之上&#xff0c;从而极大地提高了整个系统的数据处理能力。所有的处理器都可以平等地访问内存、I/O和外部中断。在对称多处理系统中&#xff0c;系统资源被系统中所有CPU共享&#xff0c;工作负载能够均匀地分配到所有可用处理器之上。在xv6中&#xff0c;每一个核上都可以独立地运行一个进程。本章侧重介绍与多处理器有关的内容&#xff1b;在本章内&#xff0c;读者可以了解到xv6是如何支持多处理器的。</p>\n<h2>2. APIC </h2>\n<p>APIC&#xff08;Advanced Programmable Interrupt Controller&#xff09;是一个与8259A兼容的高级中断处理器。它不但实现了中断处理的功能&#xff0c;还实现了以下功能&#xff1a;</p>\n<p>1. 提供与中断相关的设备通讯 </p>\n<p>2. 提供多处理器&#xff08;或多CPU&#xff09;之间的中断共享与中断通讯 </p>\n<p>事实上&#xff0c;xv6与外部设备的很大一部分通讯处理&#xff0c;都是通过APIC来实现的。<br /><br />APIC分为两层&#xff1a;Local APIC和I/O APIC。 </p>\n<p> </p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/hcrrjuyequh4bt/i76yevpeclj3/图片1.jpg\" /></p>\n<p> </p>\n<p> </p>\n<h3>a. I/O APIC </h3>\n<p>I/O APIC是用来与外部设备通讯的&#xff0c;它完成了APIC最主要的功能&#xff1a;中断处理。 </p>\n<p>I/O APIC提供了两个模式&#xff0c;普通模式和8259A兼容模式。xv6在单核环境下&#xff0c;会选择使用8259A兼容模式&#xff0c;而在多处理器环境下&#xff0c;则会使用普通模式。 </p>\n<h3>b. Local APIC </h3>\n<p>Local APIC是APIC的顶层&#xff0c;每个核都有一个对应的Local APIC。它负责进行多处理器之间的中断传输&#xff0c;屏蔽中断&#xff0c;还提供了一个可编程的Timer。由于I/O APIC已经提供了中断处理的功能&#xff0c;Local APIC只是起辅助作用&#xff0c;可以屏蔽不用。 </p>\n<p>xv6在单核环境中&#xff0c;Local APIC被屏蔽不用&#xff1b;而只有在多处理器环境中&#xff0c;Local APIC才被打开&#xff0c;完成初始化每个核、开关中断、Timer等功能。 </p>\n<h3>c. Timer </h3>\n<p>如上文所提到的&#xff0c;Local APIC提供了一个可编程的Timer。所以xv6在多处理器环境下&#xff0c;每个核使用其对应的Local APIC提供的Timer。 </p>\n<p>而在单核环境下&#xff0c;Local APIC并没有被打开。xv6使用了8253PIT(Programmable Interval Timer)来实现时钟中断。 </p>\n<p>相关代码&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>if(ismp) </p>\n<p>  lapic_timerinit(); </p>\n<p>else </p>\n<p>  pit8253_timerinit(); </p>\n</td></tr></tbody></table>\n<p></p>\n<p>注&#xff1a;github中最新的xv6已经移除了lapic_timerinit()和pit8253_timerinit()&#xff0c;目前和时钟中断有关的函数仅剩下timerinit()&#xff0c;并且默认在多核情况下是不调用的&#xff0c;如下main函数中的代码&#xff1a;</p>\n<p></p>\n<table border=\"1\" cellpadding=\"6px\" cellspacing=\"0\"><tbody><tr><td>36 if(!ismp)<br />37   timerinit(); // uniprocessor timer</td></tr></tbody></table>\n<p> </p>\n<p>picirq.c<br /><br />该文件提供了与8259A兼容的中断处理函数&#xff0c;包括&#xff1a;<br />picinit:  初始化8259A中断控制器<br />picenable: 打开指定的中断<br />picsetmask: 更改IRQ mask寄存器<br /><br />ioapic.c<br /><br />该文件提供了xv6与I/O APIC使用普通模式通讯的函数&#xff0c;包括&#xff1a;<br />ioapicinit: 初始化I/O APIC<br />ioapicread: 读I/O APIC寄存器<br />ioapicwrite: 写I/O APIC寄存器<br />该文件还包括了函数ioapicenable&#xff0c;带有两个参数&#xff0c;irq和cpunum。它用来在cpunum号核上&#xff0c;打开irq所指的中断。<br />在整个xv6中&#xff0c;这个函数被调用了两次&#xff0c;分别是打开键盘在第一个核上的中断&#xff0c;和打开IDE在最后一个核上的中断。 </p>\n<p>在多处理器的环境下&#xff0c;I/O APIC开中断之后&#xff0c;指定的核并不能收到指定的中断。只有在指定的核的Local APIC中开中断后&#xff0c;才能收到指定的中断。<br />值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。<br /><br />lapic.c<br /><br />该文件提供了xv6与Local APIC通讯的函数&#xff0c;包括&#xff1a; </p>\n<p>lapicw: 写Local APIC寄存器 </p>\n<p>lapicinit: 初始化某个核的Local APIC&#xff0c;其中关键操作&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>lapicw(SVR, ENABLE | (T_IRQ0 &#43; IRQ_SPURIOUS)); // 打开APIC<br /><br />lapicw(ICRHI, 0);<br />lapicw(ICRLO, BCAST | INIT | LEVEL); // 发送init命令<br />while(lapic[ICRLO] &amp; DELIVS); // 等待init完成 </p>\n</td></tr></tbody></table>\n<p>lapiceoi: 响应中断(Acknowledge Interrupt)&#xff0c;向EOI寄存器发送0 </p>\n<p></p>\n<p>另外还有两个函数cpunum和lapicstartap&#xff0c;将在下一节Multi Processor中介绍。 </p>\n<p>值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。 </p>\n<p> </p>\n<p></p>\n<p>在多处理器环境下&#xff0c;xv6会在每个核上运行scheduler&#xff0c;平等地分配进程。关于进程调度&#xff0c;上文中已经有详细的介绍。而本节的内容主要是介绍xv6对于多处理器的初始化。APIC可以认为是xv6与多处理器硬件之间的接口&#xff0c;几乎所有与多处理器有关的操作都要通过APIC来实现。下面是有关多处理器的一下基本概念和初始化分析。 </p>\n<h3>a. BSP和AP </h3>\n<p>APIC将核分为了两类&#xff1a;BSP(Bootstrap Processor)和AP(Application Processor)。顾名思义&#xff0c;前者是操作系统启动时第一个使用的核&#xff0c;而后者是随后将使用的核。在实际的多处理器环境中&#xff0c;BSP只有一个&#xff08;编号为0&#xff09;&#xff0c;xv6启动时就运行在它上面&#xff0c;完成基本的初始化工作&#xff0c;识别出其他的AP。AP可能有很多个&#xff0c;每个需要使用类似初始化BSP的代码来启动。在xv6中&#xff0c;只有在初始化时&#xff0c;这两类核才有区别&#xff1b;操作系统多处理初始化&#xff0c;并正常运行后&#xff0c;它们便不再有区别了。 </p>\n<h3>b. MP Configuration Table </h3>\n<p>MP Configuration Table是硬件提供给操作系统&#xff0c;用来描述多处理器信息的一个结构&#xff0c;在BSP上运行的xv6首先需要找到它&#xff0c;完成对AP、LAPIC、IOAPIC的查找和基本的初始化。该表由三部分组成&#xff1a; </p>\n<p>  </p>\n<p>1. Floating Point Structure: 作为一个指针&#xff0c;给出Configuration Table在内存中的位置 </p>\n<p>2. Configuration Table Header: 表头&#xff0c;在xv6中提供Local APIC寄存器的位置 </p>\n<p>3. Table Entry: 表项&#xff0c;一共有4种&#xff1a; </p>\n<ul><li>Processor Table Entry </li><li>Bus Table Entry</li><li>I/O APIC Table Entry</li><li>Interrupt Table Entry</li></ul>\n<p>        其中唯一对xv6真正有价值的是Processor Table Entry。其中apicid以及flag中的MPBP标志位&#xff0c;前者是每一个核的编号&#xff0c;而后者用来识别哪个核是BP。</p>\n<h3>c. Processor的编号 </h3>\n<p>在xv6中&#xff0c;使用到两种核的编号。第一种是apicid&#xff0c;也就是上文中从Processor Table Entry中获得的&#xff1b;而第二种是核在cpus数组中的下标。 </p>\n<p>前一种在初始化启动AP时会使用到(lapicstartap函数)。而后一种只使用过一次&#xff1a;在初始化Local APIC时&#xff0c;只有BSP使用了cpus数组的下标作为lapicinit的参数&#xff0c;而AP则使用了apicid作为lapicinit的参数。幸好lapicinit函数中并没有用到这个参数&#xff0c;不然可是会出大乱子的。 </p>\n<h3>d. Inter-processor Interrupt </h3>\n<p>IPI(Inter-processor Interrupt)是多处理器之间通讯的一种方式。在xv6中&#xff0c;它用来在BSP和各个AP之间通讯&#xff0c;以启动AP。它是通过读写Local APIC的寄存器来实现的。 </p>\n<h3>e. 初始化顺序</h3>\n<p>在多处理器环境下&#xff0c;xv6按照以下顺序来初始化BSP和各个AP&#xff1a; </p>\n<p>  </p>\n<p>1. 查找并读取MP Configuration Table&#xff0c;获取LAPIC配置起始地址&#xff0c;填写与CPU相关的mpproc结构和与IOAPIC相关的mpioapic结构的信息&#xff1b;&#xff08; mp.c文件的mpinit函数&#xff09;&#xff3b;Q&#xff3d;mp.c的139&#xff5e;142行有什么作用&#xff1f;</p>\n<p>2. 初始化BSP的Local APIC&#xff1b;&#xff08;lapic文件的lapicinit函数&#xff09; </p>\n<p>3. 在此还初始化了内核中的许多关键数据结构&#xff0c;包括对ioapic的初始化&#xff0c;函数为ioapicinit()&#xff0c;不过与AP没有直接关系&#xff1b;&#xff08;main.c文件的main函数的24~36行&#xff09;</p>\n<p>4. 设置AP的启动代码的起始函数start(位于entryother.S)和此函数结束后将跳转继续执行的函数mpmain&#xff08;位于main.c&#xff09;和堆栈&#xff0c;通过IPI中断来启动各个AP&#xff1b;&#xff08;main.c文件的startothers函数&#xff09;</p>\n<p>5. 运行scheduler。&#xff08;main.c文件的mpmain函数&#xff09; </p>\n<p></p>\n<p>在每个AP中&#xff0c;xv6按照如下顺序来执行&#xff1a; </p>\n<p>  </p>\n<p>1. 进入保护模式 </p>\n<p>2. 初始化AP的Local APIC </p>\n<p>3. 运行scheduler </p>\n<p> </p>\n<p>函数分析</p>\n<p> </p>\n<p>由于上文中已经介绍过系统启动的大部分内容&#xff0c;故下文中只介绍与多处理器相关的代码。 </p>\n<p> </p>\n<p>mp.c </p>\n<p> </p>\n<p>该文件用来获得MP Configuration Table&#xff0c;启动各个AP。下面是相关函数的分析说明&#xff1a; </p>\n<p>mpsearch: 寻找Floating Point Structure </p>\n<p>在不同的计算机上&#xff0c;Floating Point Structure并不在同一个位置。根据intel的文档&#xff0c;应该按顺序在如下三个位置查找&#xff1a; </p>\n<p>  </p>\n<p>1. 在Extended BIOS Data Area的第一个KB中 </p>\n<p>2. 在System Base Memory的最后一个KB中 </p>\n<p>3. 在BIOS ROM中&#xff0c;地址0xE0000~0xFFFFF </p>\n<p> </p>\n<p>mpsearch: 判断指定内存位置是否为Floating Point Structure&#xff0c;并调用mp_search1查找mp数据结构</p>\n<p>mpsearch1: 根据“_MP_”和checksum来查找mp数据结构</p>\n<p>mpconfig: 在调用mp_search的基础上&#xff0c;进一步检测找到的MP Configuration Table是否合法 </p>\n<p>mpinit: 找到MP Configuration Table&#xff0c;并获取相关信息。[Q]ncpu的初始值为多少&#xff1f;原因是&#xff1f; </p>\n<p>mpbcpu: 返回当前cpu在cpus数组中的下标作为编号 </p>\n<p> </p>\n<p>entryother.S </p>\n<p> </p>\n<p>AP的启动代码在entryother.S的start函数&#xff0c;具体操作为&#xff1a; </p>\n<p>29~32行&#xff0c;在实模式下初始化各个寄存器 </p>\n<p>34~40行&#xff0c;进入保护模式 </p>\n<p>44~50行&#xff0c;在保护模式下初始化各个段寄存器 </p>\n<p>65~67行&#xff0c;设置esp并跳转到指定函数地址(mpenter函数) </p>\n<p>值得一提的是&#xff0c;start之前的12个字节用来在start和entryother.S中传递数据。start-4为栈的地址&#xff0c;而start-8为要执行的函数地址,start-12是页目录的物理地址</p>\n<p> </p>\n<p>lapic.c </p>\n<p> </p>\n<p>cpunum: 读取Local APIC的ID寄存器&#xff0c;给出当前核的第一种编号 </p>\n<p>lapicstartap: 使用Inter-processor Interrupt来启动指定的AP </p>\n<p> </p>\n<p>main.c </p>\n<p> </p>\n<p>main: BSP的初始化&#xff0c;其中&#xff1a; </p>\n<p>22行(mpinit)&#xff0c;获取MP Configuration Table的信息 ,并初始化相关结构体</p>\n<p>23行(lapicinit)&#xff0c;获得apicid&#xff0c;初始化BSP的Local APIC</p>\n<p>27行(ioapicinit)&#xff0c;ioapic中断控制器相关</p>\n<p>38行(startothers)&#xff0c;启动各个AP </p>\n<p>89行(mpmain)&#xff0c;调用mpmain&#xff0c;运行scheduler </p>\n<p> </p>\n<p>该文件中与Multi Processor有关的有三个函数&#xff1a; </p>\n<p>mpenter: AP的初始化函数&#xff0c;在entryother.S进入保护模式后执行&#xff0c;其中&#xff1a;</p>\n<p>49行&#xff1a;切换到内核页表</p>\n<p>50行&#xff1a;初始化cpu的内核段描述符</p>\n<p>51行&#xff1a;初始化local apic</p>\n<p>52行&#xff1a;调用函数mpmain</p>\n<p></p>\n<p>mpmain&#xff1a;被mpenter所调用&#xff0c;其中&#xff1a; </p>\n<p>59行&#xff0c;显示输出cpuid </p>\n<p>60行&#xff0c;加载idt</p>\n<p>61行&#xff0c;设置标志&#xff0c;表示AP已经启动完毕</p>\n<p>62行&#xff0c;启动scheduler </p>\n<p> </p>\n<p>startothers: 循环启动每一个AP&#xff0c;具体操作为&#xff1a; </p>\n<p>71行&#xff0c;引用了entryother.S中的启动代码 </p>\n<p>79~80行&#xff0c;将启动代码复制入内存地址为0x7000的地方 </p>\n<p>83~84行&#xff0c;排除BSP </p>\n<p>89行&#xff1a;为ap分配栈地址</p>\n<p>90~92行&#xff0c;将mpenter地址与栈地址写入entryother.S代码之前&#xff0c;由entryother.S负责初始化栈和跳转至mpenter函数 </p>\n<p>94行&#xff0c;执行lapicstartap </p>\n<p>97行&#xff0c;等待AP初始化完毕 </p>", "subject": "[INFO]xv6多处理器支持的初步分析"}, {"uid": "i76zykkduDo", "anon": "no", "created": "2015-03-13T13:12:27Z", "content": "<p>本章将给出xv6多处理器支持的实现概貌。读者将学习以下一些内容: </p>\n<ul><li>什么是SMP系统&#xff1f; </li><li>什么是PIC&#xff0c;LAPIC&#xff0c;IOAPIC?</li><li>xv6是如何识别一个计算机系统中的多个CPU的&#xff1f; </li><li>xv6是如何支持CPU之间的中断信息传递的&#xff1f; </li><li>xv6如何初始化主处理器&#xff08;BP&#xff09;和从处理器&#xff08;AP&#xff09;的&#xff1f; </li></ul>\n<p> </p>\n<p>    xv6的一个独特之处在于它支持基于多处理器的计算机系统&#xff0c;即对称多处理计算机系统。SMP是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。它是应用十分广泛的并行技术。在这种架构中&#xff0c;一台电脑不再由单个处理器组成&#xff0c;而同时由多个处理器运行操作系统的单一复本&#xff0c;并共享内存和一台计算机的其他资源。虽然同时使用多个处理器&#xff0c;但是从管理的角度来看&#xff0c;它们的表现就像一台单处理器的计算机一样。系统将任务队列对称地分布于多个处理器之上&#xff0c;从而极大地提高了整个系统的数据处理能力。所有的处理器都可以平等地访问内存、I/O和外部中断。在对称多处理系统中&#xff0c;系统资源被系统中所有CPU共享&#xff0c;工作负载能够均匀地分配到所有可用处理器之上。在xv6中&#xff0c;每一个核上都可以独立地运行一个进程。本章侧重介绍与多处理器有关的内容&#xff1b;在本章内&#xff0c;读者可以了解到xv6是如何支持多处理器的。</p>\n<h2>2. APIC </h2>\n<p>APIC&#xff08;Advanced Programmable Interrupt Controller&#xff09;是一个与8259A兼容的高级中断处理器。它不但实现了中断处理的功能&#xff0c;还实现了以下功能&#xff1a;</p>\n<p>1. 提供与中断相关的设备通讯 </p>\n<p>2. 提供多处理器&#xff08;或多CPU&#xff09;之间的中断共享与中断通讯 </p>\n<p>事实上&#xff0c;xv6与外部设备的很大一部分通讯处理&#xff0c;都是通过APIC来实现的。<br /><br />APIC分为两层&#xff1a;Local APIC和I/O APIC。 </p>\n<p> </p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/hcrrjuyequh4bt/i76yevpeclj3/图片1.jpg\" /></p>\n<p> </p>\n<p> </p>\n<h3>a. I/O APIC </h3>\n<p>I/O APIC是用来与外部设备通讯的&#xff0c;它完成了APIC最主要的功能&#xff1a;中断处理。 </p>\n<p>I/O APIC提供了两个模式&#xff0c;普通模式和8259A兼容模式。xv6在单核环境下&#xff0c;会选择使用8259A兼容模式&#xff0c;而在多处理器环境下&#xff0c;则会使用普通模式。 </p>\n<h3>b. Local APIC </h3>\n<p>Local APIC是APIC的顶层&#xff0c;每个核都有一个对应的Local APIC。它负责进行多处理器之间的中断传输&#xff0c;屏蔽中断&#xff0c;还提供了一个可编程的Timer。由于I/O APIC已经提供了中断处理的功能&#xff0c;Local APIC只是起辅助作用&#xff0c;可以屏蔽不用。 </p>\n<p>xv6在单核环境中&#xff0c;Local APIC被屏蔽不用&#xff1b;而只有在多处理器环境中&#xff0c;Local APIC才被打开&#xff0c;完成初始化每个核、开关中断、Timer等功能。 </p>\n<h3>c. Timer </h3>\n<p>如上文所提到的&#xff0c;Local APIC提供了一个可编程的Timer。所以xv6在多处理器环境下&#xff0c;每个核使用其对应的Local APIC提供的Timer。 </p>\n<p>而在单核环境下&#xff0c;Local APIC并没有被打开。xv6使用了8253PIT(Programmable Interval Timer)来实现时钟中断。 </p>\n<p>相关代码&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>if(ismp) </p>\n<p>  lapic_timerinit(); </p>\n<p>else </p>\n<p>  pit8253_timerinit(); </p>\n</td></tr></tbody></table>\n<p></p>\n<p>注&#xff1a;github中最新的xv6已经移除了lapic_timerinit()和pit8253_timerinit()&#xff0c;目前和时钟中断有关的函数仅剩下timerinit()&#xff0c;并且默认在多核情况下是不调用的&#xff0c;如下main函数中的代码&#xff1a;</p>\n<p></p>\n<table border=\"1\" cellpadding=\"6px\" cellspacing=\"0\"><tbody><tr><td>36 if(!ismp)<br />37   timerinit(); // uniprocessor timer</td></tr></tbody></table>\n<p> </p>\n<p>picirq.c<br /><br />该文件提供了与8259A兼容的中断处理函数&#xff0c;包括&#xff1a;<br />picinit:  初始化8259A中断控制器<br />picenable: 打开指定的中断<br />picsetmask: 更改IRQ mask寄存器<br /><br />ioapic.c<br /><br />该文件提供了xv6与I/O APIC使用普通模式通讯的函数&#xff0c;包括&#xff1a;<br />ioapicinit: 初始化I/O APIC<br />ioapicread: 读I/O APIC寄存器<br />ioapicwrite: 写I/O APIC寄存器<br />该文件还包括了函数ioapicenable&#xff0c;带有两个参数&#xff0c;irq和cpunum。它用来在cpunum号核上&#xff0c;打开irq所指的中断。<br />在整个xv6中&#xff0c;这个函数被调用了两次&#xff0c;分别是打开键盘在第一个核上的中断&#xff0c;和打开IDE在最后一个核上的中断。 </p>\n<p>在多处理器的环境下&#xff0c;I/O APIC开中断之后&#xff0c;指定的核并不能收到指定的中断。只有在指定的核的Local APIC中开中断后&#xff0c;才能收到指定的中断。<br />值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。<br /><br />lapic.c<br /><br />该文件提供了xv6与Local APIC通讯的函数&#xff0c;包括&#xff1a; </p>\n<p>lapicw: 写Local APIC寄存器 </p>\n<p>lapicinit: 初始化某个核的Local APIC&#xff0c;其中关键操作&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>lapicw(SVR, ENABLE | (T_IRQ0 &#43; IRQ_SPURIOUS)); // 打开APIC<br /><br />lapicw(ICRHI, 0);<br />lapicw(ICRLO, BCAST | INIT | LEVEL); // 发送init命令<br />while(lapic[ICRLO] &amp; DELIVS); // 等待init完成 </p>\n</td></tr></tbody></table>\n<p>lapiceoi: 响应中断(Acknowledge Interrupt)&#xff0c;向EOI寄存器发送0 </p>\n<p></p>\n<p>另外还有两个函数cpunum和lapicstartap&#xff0c;将在下一节Multi Processor中介绍。 </p>\n<p>值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。 </p>\n<p> </p>\n<p></p>\n<p>在多处理器环境下&#xff0c;xv6会在每个核上运行scheduler&#xff0c;平等地分配进程。关于进程调度&#xff0c;上文中已经有详细的介绍。而本节的内容主要是介绍xv6对于多处理器的初始化。APIC可以认为是xv6与多处理器硬件之间的接口&#xff0c;几乎所有与多处理器有关的操作都要通过APIC来实现。下面是有关多处理器的一下基本概念和初始化分析。 </p>\n<h3>a. BSP和AP </h3>\n<p>APIC将核分为了两类&#xff1a;BSP(Bootstrap Processor)和AP(Application Processor)。顾名思义&#xff0c;前者是操作系统启动时第一个使用的核&#xff0c;而后者是随后将使用的核。在实际的多处理器环境中&#xff0c;BSP只有一个&#xff08;编号为0&#xff09;&#xff0c;xv6启动时就运行在它上面&#xff0c;完成基本的初始化工作&#xff0c;识别出其他的AP。AP可能有很多个&#xff0c;每个需要使用类似初始化BSP的代码来启动。在xv6中&#xff0c;只有在初始化时&#xff0c;这两类核才有区别&#xff1b;操作系统多处理初始化&#xff0c;并正常运行后&#xff0c;它们便不再有区别了。 </p>\n<h3>b. MP Configuration Table </h3>\n<p>MP Configuration Table是硬件提供给操作系统&#xff0c;用来描述多处理器信息的一个结构&#xff0c;在BSP上运行的xv6首先需要找到它&#xff0c;完成对AP、LAPIC、IOAPIC的查找和基本的初始化。该表由三部分组成&#xff1a; </p>\n<p>  </p>\n<p>1. Floating Point Structure: 作为一个指针&#xff0c;给出Configuration Table在内存中的位置 </p>\n<p>2. Configuration Table Header: 表头&#xff0c;在xv6中提供Local APIC寄存器的位置 </p>\n<p>3. Table Entry: 表项&#xff0c;一共有4种&#xff1a; </p>\n<ul><li>Processor Table Entry </li><li>Bus Table Entry</li><li>I/O APIC Table Entry</li><li>Interrupt Table Entry</li></ul>\n<p>        其中唯一对xv6真正有价值的是Processor Table Entry。其中apicid以及flag中的MPBP标志位&#xff0c;前者是每一个核的编号&#xff0c;而后者用来识别哪个核是BP。</p>\n<h3>c. Processor的编号 </h3>\n<p>在xv6中&#xff0c;使用到两种核的编号。第一种是apicid&#xff0c;也就是上文中从Processor Table Entry中获得的&#xff1b;而第二种是核在cpus数组中的下标。 </p>\n<p>前一种在初始化启动AP时会使用到(lapicstartap函数)。而后一种只使用过一次&#xff1a;在初始化Local APIC时&#xff0c;只有BSP使用了cpus数组的下标作为lapicinit的参数&#xff0c;而AP则使用了apicid作为lapicinit的参数。幸好lapicinit函数中并没有用到这个参数&#xff0c;不然可是会出大乱子的。 </p>\n<h3>d. Inter-processor Interrupt </h3>\n<p>IPI(Inter-processor Interrupt)是多处理器之间通讯的一种方式。在xv6中&#xff0c;它用来在BSP和各个AP之间通讯&#xff0c;以启动AP。它是通过读写Local APIC的寄存器来实现的。 </p>\n<h3>e. 初始化顺序</h3>\n<p>在多处理器环境下&#xff0c;xv6按照以下顺序来初始化BSP和各个AP&#xff1a; </p>\n<p>  </p>\n<p>1. 查找并读取MP Configuration Table&#xff0c;获取LAPIC配置起始地址&#xff0c;填写与CPU相关的mpproc结构和与IOAPIC相关的mpioapic结构的信息&#xff1b;&#xff08; mp.c文件的mpinit函数&#xff09;&#xff3b;Q&#xff3d;mp.c的139&#xff5e;142行有什么作用&#xff1f;</p>\n<p>2. 初始化BSP的Local APIC&#xff1b;&#xff08;lapic文件的lapicinit函数&#xff09; </p>\n<p>3. 在此还初始化了内核中的许多关键数据结构&#xff0c;包括对ioapic的初始化&#xff0c;函数为ioapicinit()&#xff0c;不过与AP没有直接关系&#xff1b;&#xff08;main.c文件的main函数的24~36行&#xff09;</p>\n<p>4. 设置AP的启动代码的起始函数start(位于entryother.S)和此函数结束后将跳转继续执行的函数mpmain&#xff08;位于main.c&#xff09;和堆栈&#xff0c;通过IPI中断来启动各个AP&#xff1b;&#xff08;main.c文件的startothers函数&#xff09;</p>\n<p>5. 运行scheduler。&#xff08;main.c文件的mpmain函数&#xff09; </p>\n<p></p>\n<p>在每个AP中&#xff0c;xv6按照如下顺序来执行&#xff1a; </p>\n<p>  </p>\n<p>1. 进入保护模式 </p>\n<p>2. 初始化AP的Local APIC </p>\n<p>3. 运行scheduler </p>\n<p> </p>\n<p>函数分析</p>\n<p> </p>\n<p>由于上文中已经介绍过系统启动的大部分内容&#xff0c;故下文中只介绍与多处理器相关的代码。 </p>\n<p> </p>\n<p>mp.c </p>\n<p> </p>\n<p>该文件用来获得MP Configuration Table&#xff0c;启动各个AP。下面是相关函数的分析说明&#xff1a; </p>\n<p>mpsearch: 寻找Floating Point Structure </p>\n<p>在不同的计算机上&#xff0c;Floating Point Structure并不在同一个位置。根据intel的文档&#xff0c;应该按顺序在如下三个位置查找&#xff1a; </p>\n<p>  </p>\n<p>1. 在Extended BIOS Data Area的第一个KB中 </p>\n<p>2. 在System Base Memory的最后一个KB中 </p>\n<p>3. 在BIOS ROM中&#xff0c;地址0xE0000~0xFFFFF </p>\n<p> </p>\n<p>mpsearch: 判断指定内存位置是否为Floating Point Structure&#xff0c;并调用mp_search1查找mp数据结构</p>\n<p>mpsearch1: 根据“_MP_”和checksum来查找mp数据结构</p>\n<p>mpconfig: 在调用mp_search的基础上&#xff0c;进一步检测找到的MP Configuration Table是否合法 </p>\n<p>mpinit: 找到MP Configuration Table&#xff0c;并获取相关信息。[Q]ncpu的初始值为多少&#xff1f;原因是&#xff1f; </p>\n<p>mpbcpu: 返回当前cpu在cpus数组中的下标作为编号 </p>\n<p> </p>\n<p>entryother.S </p>\n<p> </p>\n<p>AP的启动代码在entryother.S的start函数&#xff0c;具体操作为&#xff1a; </p>\n<p>29~32行&#xff0c;在实模式下初始化各个寄存器 </p>\n<p>34~40行&#xff0c;进入保护模式 </p>\n<p>44~50行&#xff0c;在保护模式下初始化各个段寄存器 </p>\n<p>65~67行&#xff0c;设置esp并跳转到指定函数地址(mpenter函数) </p>\n<p>值得一提的是&#xff0c;在这里定义的start的地址在0x7000&#xff0c;由Makefile中进行规定&#xff0c;start之前的12个字节用来在start和entryother.S中传递数据。start-4为栈的地址&#xff0c;而start-8为要执行的函数地址,start-12是页目录的物理地址</p>\n<p> </p>\n<p>lapic.c </p>\n<p> </p>\n<p>cpunum: 读取Local APIC的ID寄存器&#xff0c;给出当前核的第一种编号 </p>\n<p>lapicstartap: 使用Inter-processor Interrupt来启动指定的AP </p>\n<p> </p>\n<p>main.c </p>\n<p> </p>\n<p>main: BSP的初始化&#xff0c;其中&#xff1a; </p>\n<p>22行(mpinit)&#xff0c;获取MP Configuration Table的信息 ,并初始化相关结构体</p>\n<p>23行(lapicinit)&#xff0c;获得apicid&#xff0c;初始化BSP的Local APIC</p>\n<p>27行(ioapicinit)&#xff0c;ioapic中断控制器相关 </p>\n<p>38行(startothers)&#xff0c;启动各个AP </p>\n<p>89行(mpmain)&#xff0c;调用mpmain&#xff0c;运行scheduler </p>\n<p> </p>\n<p>该文件中与Multi Processor有关的有三个函数&#xff1a; </p>\n<p>mpenter: AP的初始化函数&#xff0c;在entryother.S进入保护模式后执行&#xff0c;其中&#xff1a;</p>\n<p>49行&#xff1a;切换到内核页表</p>\n<p>50行&#xff1a;初始化cpu的内核段描述符</p>\n<p>51行&#xff1a;初始化local apic</p>\n<p>52行&#xff1a;调用函数mpmain</p>\n<p></p>\n<p>mpmain&#xff1a;被mpenter所调用&#xff0c;其中&#xff1a; </p>\n<p>59行&#xff0c;显示输出cpuid </p>\n<p>60行&#xff0c;加载idt</p>\n<p>61行&#xff0c;设置标志&#xff0c;表示AP已经启动完毕</p>\n<p>62行&#xff0c;启动scheduler </p>\n<p> </p>\n<p>startothers: 循环启动每一个AP&#xff0c;具体操作为&#xff1a; </p>\n<p>71行&#xff0c;引用了entryother.S中的启动代码 </p>\n<p>79~80行&#xff0c;将启动代码复制入内存地址为0x7000的地方 </p>\n<p>83~84行&#xff0c;排除BSP </p>\n<p>89行&#xff1a;为ap分配栈地址</p>\n<p>90~92行&#xff0c;将mpenter地址与栈地址写入entryother.S代码之前&#xff0c;由entryother.S负责初始化栈和跳转至mpenter函数 </p>\n<p>94行&#xff0c;执行lapicstartap </p>\n<p>97行&#xff0c;等待AP初始化完毕 </p>", "subject": "[INFO]xv6多处理器支持的初步分析"}, {"uid": "i76zykkduDo", "anon": "no", "created": "2015-03-13T11:34:22Z", "content": "<p>本章将给出xv6多处理器支持的实现概貌。读者将学习以下一些内容: </p>\n<ul><li>什么是SMP系统&#xff1f; </li><li>什么是PIC&#xff0c;LAPIC&#xff0c;IOAPIC?</li><li>xv6是如何识别一个计算机系统中的多个CPU的&#xff1f; </li><li>xv6是如何支持CPU之间的中断信息传递的&#xff1f; </li><li>xv6如何初始化主处理器&#xff08;BP&#xff09;和从处理器&#xff08;AP&#xff09;的&#xff1f; </li></ul>\n<p> </p>\n<p>    xv6的一个独特之处在于它支持基于多处理器的计算机系统&#xff0c;即对称多处理计算机系统。SMP是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。它是应用十分广泛的并行技术。在这种架构中&#xff0c;一台电脑不再由单个处理器组成&#xff0c;而同时由多个处理器运行操作系统的单一复本&#xff0c;并共享内存和一台计算机的其他资源。虽然同时使用多个处理器&#xff0c;但是从管理的角度来看&#xff0c;它们的表现就像一台单处理器的计算机一样。系统将任务队列对称地分布于多个处理器之上&#xff0c;从而极大地提高了整个系统的数据处理能力。所有的处理器都可以平等地访问内存、I/O和外部中断。在对称多处理系统中&#xff0c;系统资源被系统中所有CPU共享&#xff0c;工作负载能够均匀地分配到所有可用处理器之上。在xv6中&#xff0c;每一个核上都可以独立地运行一个进程。本章侧重介绍与多处理器有关的内容&#xff1b;在本章内&#xff0c;读者可以了解到xv6是如何支持多处理器的。</p>\n<h2>2. APIC </h2>\n<p>APIC&#xff08;Advanced Programmable Interrupt Controller&#xff09;是一个与8259A兼容的高级中断处理器。它不但实现了中断处理的功能&#xff0c;还实现了以下功能&#xff1a;</p>\n<p>1. 提供与中断相关的设备通讯 </p>\n<p>2. 提供多处理器&#xff08;或多CPU&#xff09;之间的中断共享与中断通讯 </p>\n<p>事实上&#xff0c;xv6与外部设备的很大一部分通讯处理&#xff0c;都是通过APIC来实现的。<br /><br />APIC分为两层&#xff1a;Local APIC和I/O APIC。 </p>\n<p> </p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/hcrrjuyequh4bt/i76yevpeclj3/图片1.jpg\" /></p>\n<p> </p>\n<p> </p>\n<h3>a. I/O APIC </h3>\n<p>I/O APIC是用来与外部设备通讯的&#xff0c;它完成了APIC最主要的功能&#xff1a;中断处理。 </p>\n<p>I/O APIC提供了两个模式&#xff0c;普通模式和8259A兼容模式。xv6在单核环境下&#xff0c;会选择使用8259A兼容模式&#xff0c;而在多处理器环境下&#xff0c;则会使用普通模式。 </p>\n<h3>b. Local APIC </h3>\n<p>Local APIC是APIC的顶层&#xff0c;每个核都有一个对应的Local APIC。它负责进行多处理器之间的中断传输&#xff0c;屏蔽中断&#xff0c;还提供了一个可编程的Timer。由于I/O APIC已经提供了中断处理的功能&#xff0c;Local APIC只是起辅助作用&#xff0c;可以屏蔽不用。 </p>\n<p>xv6在单核环境中&#xff0c;Local APIC被屏蔽不用&#xff1b;而只有在多处理器环境中&#xff0c;Local APIC才被打开&#xff0c;完成初始化每个核、开关中断、Timer等功能。 </p>\n<h3>c. Timer </h3>\n<p>如上文所提到的&#xff0c;Local APIC提供了一个可编程的Timer。所以xv6在多处理器环境下&#xff0c;每个核使用其对应的Local APIC提供的Timer。 </p>\n<p>而在单核环境下&#xff0c;Local APIC并没有被打开。xv6使用了8253PIT(Programmable Interval Timer)来实现时钟中断。 </p>\n<p>相关代码&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>if(ismp) </p>\n<p>  lapic_timerinit(); </p>\n<p>else </p>\n<p>  pit8253_timerinit(); </p>\n</td></tr></tbody></table>\n<p></p>\n<p>注&#xff1a;github中最新的xv6已经移除了lapic_timerinit()和pit8253_timerinit()&#xff0c;目前和时钟中断有关的函数仅剩下timerinit()&#xff0c;并且默认在多核情况下是不调用的&#xff0c;如下main函数中的代码&#xff1a;</p>\n<p></p>\n<table border=\"1\" cellpadding=\"6px\" cellspacing=\"0\"><tbody><tr><td>36 if(!ismp)<br />37   timerinit(); // uniprocessor timer</td></tr></tbody></table>\n<p> </p>\n<p>picirq.c<br /><br />该文件提供了与8259A兼容的中断处理函数&#xff0c;包括&#xff1a;<br />picinit:  初始化8259A中断控制器<br />picenable: 打开指定的中断<br />picsetmask: 更改IRQ mask寄存器<br /><br />ioapic.c<br /><br />该文件提供了xv6与I/O APIC使用普通模式通讯的函数&#xff0c;包括&#xff1a;<br />ioapicinit: 初始化I/O APIC<br />ioapicread: 读I/O APIC寄存器<br />ioapicwrite: 写I/O APIC寄存器<br />该文件还包括了函数ioapicenable&#xff0c;带有两个参数&#xff0c;irq和cpunum。它用来在cpunum号核上&#xff0c;打开irq所指的中断。<br />在整个xv6中&#xff0c;这个函数被调用了两次&#xff0c;分别是打开键盘在第一个核上的中断&#xff0c;和打开IDE在最后一个核上的中断。 </p>\n<p>在多处理器的环境下&#xff0c;I/O APIC开中断之后&#xff0c;指定的核并不能收到指定的中断。只有在指定的核的Local APIC中开中断后&#xff0c;才能收到指定的中断。<br />值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。<br /><br />lapic.c<br /><br />该文件提供了xv6与Local APIC通讯的函数&#xff0c;包括&#xff1a; </p>\n<p>lapicw: 写Local APIC寄存器 </p>\n<p>lapicinit: 初始化某个核的Local APIC&#xff0c;其中关键操作&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>lapicw(SVR, ENABLE | (T_IRQ0 &#43; IRQ_SPURIOUS)); // 打开APIC<br /><br />lapicw(ICRHI, 0);<br />lapicw(ICRLO, BCAST | INIT | LEVEL); // 发送init命令<br />while(lapic[ICRLO] &amp; DELIVS); // 等待init完成 </p>\n</td></tr></tbody></table>\n<p>lapiceoi: 响应中断(Acknowledge Interrupt)&#xff0c;向EOI寄存器发送0 </p>\n<p></p>\n<p>另外还有两个函数cpunum和lapicstartap&#xff0c;将在下一节Multi Processor中介绍。 </p>\n<p>值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。 </p>\n<p> </p>\n<p></p>\n<p>在多处理器环境下&#xff0c;xv6会在每个核上运行scheduler&#xff0c;平等地分配进程。关于进程调度&#xff0c;上文中已经有详细的介绍。而本节的内容主要是介绍xv6对于多处理器的初始化。APIC可以认为是xv6与多处理器硬件之间的接口&#xff0c;几乎所有与多处理器有关的操作都要通过APIC来实现。下面是有关多处理器的一下基本概念和初始化分析。 </p>\n<h3>a. BSP和AP </h3>\n<p>APIC将核分为了两类&#xff1a;BSP(Bootstrap Processor)和AP(Application Processor)。顾名思义&#xff0c;前者是操作系统启动时第一个使用的核&#xff0c;而后者是随后将使用的核。在实际的多处理器环境中&#xff0c;BSP只有一个&#xff08;编号为0&#xff09;&#xff0c;xv6启动时就运行在它上面&#xff0c;完成基本的初始化工作&#xff0c;识别出其他的AP。AP可能有很多个&#xff0c;每个需要使用类似初始化BSP的代码来启动。在xv6中&#xff0c;只有在初始化时&#xff0c;这两类核才有区别&#xff1b;操作系统多处理初始化&#xff0c;并正常运行后&#xff0c;它们便不再有区别了。 </p>\n<h3>b. MP Configuration Table </h3>\n<p>MP Configuration Table是硬件提供给操作系统&#xff0c;用来描述多处理器信息的一个结构&#xff0c;在BSP上运行的xv6首先需要找到它&#xff0c;完成对AP、LAPIC、IOAPIC的查找和基本的初始化。该表由三部分组成&#xff1a; </p>\n<p>  </p>\n<p>1. Floating Point Structure: 作为一个指针&#xff0c;给出Configuration Table在内存中的位置 </p>\n<p>2. Configuration Table Header: 表头&#xff0c;在xv6中提供Local APIC寄存器的位置 </p>\n<p>3. Table Entry: 表项&#xff0c;一共有4种&#xff1a; </p>\n<ul><li>Processor Table Entry </li><li>Bus Table Entry</li><li>I/O APIC Table Entry</li><li>Interrupt Table Entry</li></ul>\n<p>        其中唯一对xv6真正有价值的是Processor Table Entry。其中apicid以及flag中的MPBP标志位&#xff0c;前者是每一个核的编号&#xff0c;而后者用来识别哪个核是BP。</p>\n<h3>c. Processor的编号 </h3>\n<p>在xv6中&#xff0c;使用到两种核的编号。第一种是apicid&#xff0c;也就是上文中从Processor Table Entry中获得的&#xff1b;而第二种是核在cpus数组中的下标。 </p>\n<p>前一种在初始化启动AP时会使用到(lapicstartap函数)。而后一种只使用过一次&#xff1a;在初始化Local APIC时&#xff0c;只有BSP使用了cpus数组的下标作为lapicinit的参数&#xff0c;而AP则使用了apicid作为lapicinit的参数。幸好lapicinit函数中并没有用到这个参数&#xff0c;不然可是会出大乱子的。 </p>\n<h3>d. Inter-processor Interrupt </h3>\n<p>IPI(Inter-processor Interrupt)是多处理器之间通讯的一种方式。在xv6中&#xff0c;它用来在BSP和各个AP之间通讯&#xff0c;以启动AP。它是通过读写Local APIC的寄存器来实现的。 </p>\n<h3>e. 初始化顺序</h3>\n<p>在多处理器环境下&#xff0c;xv6按照以下顺序来初始化BSP和各个AP&#xff1a; </p>\n<p>  </p>\n<p>1. 查找并读取MP Configuration Table&#xff0c;获取LAPIC配置起始地址&#xff0c;填写与CPU相关的mpproc结构和与IOAPIC相关的mpioapic结构的信息&#xff1b;&#xff08; mp.c文件的mpinit函数&#xff09;&#xff3b;Q&#xff3d;mp.c的139&#xff5e;142行有什么作用&#xff1f;</p>\n<p>2. 初始化BSP的Local APIC&#xff1b;&#xff08;lapic文件的lapicinit函数&#xff09; </p>\n<p>3. 在此还初始化了内核中的许多关键数据结构&#xff0c;包括对ioapic的初始化&#xff0c;函数为ioapicinit()&#xff0c;不过与AP没有直接关系&#xff1b;&#xff08;main.c文件的main函数的24~36行&#xff09;</p>\n<p>4. 设置AP的启动代码的起始函数start(位于entryother.S)和此函数结束后将跳转继续执行的函数mpmain&#xff08;位于main.c&#xff09;和堆栈&#xff0c;通过IPI中断来启动各个AP&#xff1b;&#xff08;main.c文件的startothers函数&#xff09;</p>\n<p>5. 运行scheduler。&#xff08;main.c文件的mpmain函数&#xff09; </p>\n<p></p>\n<p>在每个AP中&#xff0c;xv6按照如下顺序来执行&#xff1a; </p>\n<p>  </p>\n<p>1. 进入保护模式 </p>\n<p>2. 初始化AP的Local APIC </p>\n<p>3. 运行scheduler </p>\n<p> </p>\n<p>函数分析</p>\n<p> </p>\n<p>由于上文中已经介绍过系统启动的大部分内容&#xff0c;故下文中只介绍与多处理器相关的代码。 </p>\n<p> </p>\n<p>mp.c </p>\n<p> </p>\n<p>该文件用来获得MP Configuration Table&#xff0c;启动各个AP。下面是相关函数的分析说明&#xff1a; </p>\n<p>mpsearch: 寻找Floating Point Structure </p>\n<p>在不同的计算机上&#xff0c;Floating Point Structure并不在同一个位置。根据intel的文档&#xff0c;应该按顺序在如下三个位置查找&#xff1a; </p>\n<p>  </p>\n<p>1. 在Extended BIOS Data Area的第一个KB中 </p>\n<p>2. 在System Base Memory的最后一个KB中 </p>\n<p>3. 在BIOS ROM中&#xff0c;地址0xE0000~0xFFFFF </p>\n<p> </p>\n<p>mpsearch: 判断指定内存位置是否为Floating Point Structure&#xff0c;并调用mp_search1查找mp数据结构</p>\n<p>mpsearch1: 根据“_MP_”和checksum来查找mp数据结构</p>\n<p>mpconfig: 在调用mp_search的基础上&#xff0c;进一步检测找到的MP Configuration Table是否合法 </p>\n<p>mpinit: 找到MP Configuration Table&#xff0c;并获取相关信息。[Q]ncpu的初始值为多少&#xff1f;原因是&#xff1f; </p>\n<p>mpbcpu: 返回当前cpu在cpus数组中的下标作为编号 </p>\n<p> </p>\n<p>entryother.S </p>\n<p> </p>\n<p>AP的启动代码在entryother.S的start函数&#xff0c;具体操作为&#xff1a; </p>\n<p>29~32行&#xff0c;在实模式下初始化各个寄存器 </p>\n<p>34~40行&#xff0c;进入保护模式 </p>\n<p>44~50行&#xff0c;在保护模式下初始化各个段寄存器 </p>\n<p>65~67行&#xff0c;设置esp并跳转到指定函数地址(mpenter函数) </p>\n<p>值得一提的是&#xff0c;在这里定义的start的地址在0x7000&#xff0c;由Makefile中进行规定&#xff0c;start之前的12个字节用来在start和entryother.S中传递数据。start-4为栈的地址&#xff0c;而start-8为要执行的函数地址,start-12是页目录的物理地址</p>\n<p> </p>\n<p>lapic.c </p>\n<p> </p>\n<p>cpunum: 读取Local APIC的ID寄存器&#xff0c;给出当前核的第一种编号 </p>\n<p>lapicstartap: 使用Inter-processor Interrupt来启动指定的AP </p>\n<p> </p>\n<p>main.c </p>\n<p> </p>\n<p>main: BSP的初始化&#xff0c;其中&#xff1a; </p>\n<p>18行&#xff0c;把BSS清零</p>\n<p>20行&#xff0c;获取MP Configuration Table的信息 </p>\n<p>21行&#xff0c;获得apicid&#xff0c;初始化BSP的Local APIC </p>\n<p>37行&#xff0c;启动各个AP </p>\n<p>89行&#xff0c;调用mpmain&#xff0c;运行scheduler </p>\n<p> </p>\n<p>该文件中与Multi Processor有关的有三个函数&#xff1a; </p>\n<p>mpenter: AP的初始化函数&#xff0c;在entryother.S进入保护模式后执行&#xff0c;其中&#xff1a;</p>\n<p>49行&#xff1a;切换到内核页表</p>\n<p>50行&#xff1a;初始化cpu的内核段描述符</p>\n<p>51行&#xff1a;初始化lapic</p>\n<p>52行&#xff1a;调用函数mpmain</p>\n<p></p>\n<p>mpmain&#xff1a;被mpenter所调用&#xff0c;其中&#xff1a; </p>\n<p>59行&#xff0c;显示输出cpuid </p>\n<p>60行&#xff0c;加载idt</p>\n<p>61行&#xff0c;设置标志&#xff0c;表示AP已经启动完毕</p>\n<p>62行&#xff0c;启动scheduler </p>\n<p> </p>\n<p>startothers: 循环启动每一个AP&#xff0c;具体操作为&#xff1a; </p>\n<p>71行&#xff0c;引用了entryother.S中的启动代码 </p>\n<p>79~80行&#xff0c;将启动代码复制入内存地址为0x7000的地方 </p>\n<p>83~84行&#xff0c;排除BSP </p>\n<p>91行&#xff1a;为ap分配栈地址</p>\n<p>90~92行&#xff0c;将mpenter地址与栈地址写入entryother.S代码之前&#xff0c;由entryother.S负责初始化栈和跳转至mpenter函数 </p>\n<p>79行&#xff0c;执行lapicstartap </p>\n<p>82行&#xff0c;等待AP初始化完毕 </p>", "subject": "[INFO]xv6多处理器支持的初步分析"}, {"uid": "i76zykkduDo", "anon": "no", "created": "2015-03-13T11:33:46Z", "content": "<p>本章将给出xv6多处理器支持的实现概貌。读者将学习以下一些内容: </p>\n<ul><li>什么是SMP系统&#xff1f; </li><li>什么是PIC&#xff0c;LAPIC&#xff0c;IOAPIC?</li><li>xv6是如何识别一个计算机系统中的多个CPU的&#xff1f; </li><li>xv6是如何支持CPU之间的中断信息传递的&#xff1f; </li><li>xv6如何初始化主处理器&#xff08;BP&#xff09;和从处理器&#xff08;AP&#xff09;的&#xff1f; </li></ul>\n<p> </p>\n<p>    xv6的一个独特之处在于它支持基于多处理器的计算机系统&#xff0c;即对称多处理计算机系统。SMP是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。它是应用十分广泛的并行技术。在这种架构中&#xff0c;一台电脑不再由单个处理器组成&#xff0c;而同时由多个处理器运行操作系统的单一复本&#xff0c;并共享内存和一台计算机的其他资源。虽然同时使用多个处理器&#xff0c;但是从管理的角度来看&#xff0c;它们的表现就像一台单处理器的计算机一样。系统将任务队列对称地分布于多个处理器之上&#xff0c;从而极大地提高了整个系统的数据处理能力。所有的处理器都可以平等地访问内存、I/O和外部中断。在对称多处理系统中&#xff0c;系统资源被系统中所有CPU共享&#xff0c;工作负载能够均匀地分配到所有可用处理器之上。在xv6中&#xff0c;每一个核上都可以独立地运行一个进程。本章侧重介绍与多处理器有关的内容&#xff1b;在本章内&#xff0c;读者可以了解到xv6是如何支持多处理器的。</p>\n<h2>2. APIC </h2>\n<p>APIC&#xff08;Advanced Programmable Interrupt Controller&#xff09;是一个与8259A兼容的高级中断处理器。它不但实现了中断处理的功能&#xff0c;还实现了以下功能&#xff1a;</p>\n<p>1. 提供与中断相关的设备通讯 </p>\n<p>2. 提供多处理器&#xff08;或多CPU&#xff09;之间的中断共享与中断通讯 </p>\n<p>事实上&#xff0c;xv6与外部设备的很大一部分通讯处理&#xff0c;都是通过APIC来实现的。<br /><br />APIC分为两层&#xff1a;Local APIC和I/O APIC。 </p>\n<p> </p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/hcrrjuyequh4bt/i76yevpeclj3/图片1.jpg\" /></p>\n<p> </p>\n<p> </p>\n<h3>a. I/O APIC </h3>\n<p>I/O APIC是用来与外部设备通讯的&#xff0c;它完成了APIC最主要的功能&#xff1a;中断处理。 </p>\n<p>I/O APIC提供了两个模式&#xff0c;普通模式和8259A兼容模式。xv6在单核环境下&#xff0c;会选择使用8259A兼容模式&#xff0c;而在多处理器环境下&#xff0c;则会使用普通模式。 </p>\n<h3>b. Local APIC </h3>\n<p>Local APIC是APIC的顶层&#xff0c;每个核都有一个对应的Local APIC。它负责进行多处理器之间的中断传输&#xff0c;屏蔽中断&#xff0c;还提供了一个可编程的Timer。由于I/O APIC已经提供了中断处理的功能&#xff0c;Local APIC只是起辅助作用&#xff0c;可以屏蔽不用。 </p>\n<p>xv6在单核环境中&#xff0c;Local APIC被屏蔽不用&#xff1b;而只有在多处理器环境中&#xff0c;Local APIC才被打开&#xff0c;完成初始化每个核、开关中断、Timer等功能。 </p>\n<h3>c. Timer </h3>\n<p>如上文所提到的&#xff0c;Local APIC提供了一个可编程的Timer。所以xv6在多处理器环境下&#xff0c;每个核使用其对应的Local APIC提供的Timer。 </p>\n<p>而在单核环境下&#xff0c;Local APIC并没有被打开。xv6使用了8253PIT(Programmable Interval Timer)来实现时钟中断。 </p>\n<p>相关代码&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>if(ismp) </p>\n<p>  lapic_timerinit(); </p>\n<p>else </p>\n<p>  pit8253_timerinit(); </p>\n</td></tr></tbody></table>\n<p></p>\n<p>注&#xff1a;github中最新的xv6已经移除了lapic_timerinit()和pit8253_timerinit()&#xff0c;目前和时钟中断有关的函数仅剩下timerinit()&#xff0c;并且默认在多核情况下是不调用的&#xff0c;如下main函数中的代码&#xff1a;</p>\n<p></p>\n<table border=\"1\" cellpadding=\"6px\" cellspacing=\"0\"><tbody><tr><td>36 if(!ismp)<br />37   timerinit(); // uniprocessor timer</td></tr></tbody></table>\n<p> </p>\n<p>picirq.c<br /><br />该文件提供了与8259A兼容的中断处理函数&#xff0c;包括&#xff1a;<br />picinit:  初始化8259A中断控制器<br />picenable: 打开指定的中断<br />picsetmask: 更改IRQ mask寄存器<br /><br />ioapic.c<br /><br />该文件提供了xv6与I/O APIC使用普通模式通讯的函数&#xff0c;包括&#xff1a;<br />ioapicinit: 初始化I/O APIC<br />ioapicread: 读I/O APIC寄存器<br />ioapicwrite: 写I/O APIC寄存器<br />该文件还包括了函数ioapicenable&#xff0c;带有两个参数&#xff0c;irq和cpunum。它用来在cpunum号核上&#xff0c;打开irq所指的中断。<br />在整个xv6中&#xff0c;这个函数被调用了两次&#xff0c;分别是打开键盘在第一个核上的中断&#xff0c;和打开IDE在最后一个核上的中断。 </p>\n<p>在多处理器的环境下&#xff0c;I/O APIC开中断之后&#xff0c;指定的核并不能收到指定的中断。只有在指定的核的Local APIC中开中断后&#xff0c;才能收到指定的中断。<br />值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。<br /><br />lapic.c<br /><br />该文件提供了xv6与Local APIC通讯的函数&#xff0c;包括&#xff1a; </p>\n<p>lapicw: 写Local APIC寄存器 </p>\n<p>lapicinit: 初始化某个核的Local APIC&#xff0c;其中关键操作&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>lapicw(SVR, ENABLE | (T_IRQ0 &#43; IRQ_SPURIOUS)); // 打开APIC<br /><br />lapicw(ICRHI, 0);<br />lapicw(ICRLO, BCAST | INIT | LEVEL); // 发送init命令<br />while(lapic[ICRLO] &amp; DELIVS); // 等待init完成 </p>\n</td></tr></tbody></table>\n<p>lapiceoi: 响应中断(Acknowledge Interrupt)&#xff0c;向EOI寄存器发送0 </p>\n<p></p>\n<p>另外还有两个函数cpunum和lapicstartap&#xff0c;将在下一节Multi Processor中介绍。 </p>\n<p>值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。 </p>\n<p> </p>\n<p></p>\n<p>在多处理器环境下&#xff0c;xv6会在每个核上运行scheduler&#xff0c;平等地分配进程。关于进程调度&#xff0c;上文中已经有详细的介绍。而本节的内容主要是介绍xv6对于多处理器的初始化。APIC可以认为是xv6与多处理器硬件之间的接口&#xff0c;几乎所有与多处理器有关的操作都要通过APIC来实现。下面是有关多处理器的一下基本概念和初始化分析。 </p>\n<h3>a. BSP和AP </h3>\n<p>APIC将核分为了两类&#xff1a;BSP(Bootstrap Processor)和AP(Application Processor)。顾名思义&#xff0c;前者是操作系统启动时第一个使用的核&#xff0c;而后者是随后将使用的核。在实际的多处理器环境中&#xff0c;BSP只有一个&#xff08;编号为0&#xff09;&#xff0c;xv6启动时就运行在它上面&#xff0c;完成基本的初始化工作&#xff0c;识别出其他的AP。AP可能有很多个&#xff0c;每个需要使用类似初始化BSP的代码来启动。在xv6中&#xff0c;只有在初始化时&#xff0c;这两类核才有区别&#xff1b;操作系统多处理初始化&#xff0c;并正常运行后&#xff0c;它们便不再有区别了。 </p>\n<h3>b. MP Configuration Table </h3>\n<p>MP Configuration Table是硬件提供给操作系统&#xff0c;用来描述多处理器信息的一个结构&#xff0c;在BSP上运行的xv6首先需要找到它&#xff0c;完成对AP、LAPIC、IOAPIC的查找和基本的初始化。该表由三部分组成&#xff1a; </p>\n<p>  </p>\n<p>1. Floating Point Structure: 作为一个指针&#xff0c;给出Configuration Table在内存中的位置 </p>\n<p>2. Configuration Table Header: 表头&#xff0c;在xv6中提供Local APIC寄存器的位置 </p>\n<p>3. Table Entry: 表项&#xff0c;一共有4种&#xff1a; </p>\n<ul><li>Processor Table Entry </li><li>Bus Table Entry</li><li>I/O APIC Table Entry</li><li>Interrupt Table Entry</li></ul>\n<p>        其中唯一对xv6真正有价值的是Processor Table Entry。其中apicid以及flag中的MPBP标志位&#xff0c;前者是每一个核的编号&#xff0c;而后者用来识别哪个核是BP。</p>\n<h3>c. Processor的编号 </h3>\n<p>在xv6中&#xff0c;使用到两种核的编号。第一种是apicid&#xff0c;也就是上文中从Processor Table Entry中获得的&#xff1b;而第二种是核在cpus数组中的下标。 </p>\n<p>前一种在初始化启动AP时会使用到(lapicstartap函数)。而后一种只使用过一次&#xff1a;在初始化Local APIC时&#xff0c;只有BSP使用了cpus数组的下标作为lapicinit的参数&#xff0c;而AP则使用了apicid作为lapicinit的参数。幸好lapicinit函数中并没有用到这个参数&#xff0c;不然可是会出大乱子的。 </p>\n<h3>d. Inter-processor Interrupt </h3>\n<p>IPI(Inter-processor Interrupt)是多处理器之间通讯的一种方式。在xv6中&#xff0c;它用来在BSP和各个AP之间通讯&#xff0c;以启动AP。它是通过读写Local APIC的寄存器来实现的。 </p>\n<h3>e. 初始化顺序</h3>\n<p>在多处理器环境下&#xff0c;xv6按照以下顺序来初始化BSP和各个AP&#xff1a; </p>\n<p>  </p>\n<p>1. 查找并读取MP Configuration Table&#xff0c;获取LAPIC配置起始地址&#xff0c;填写与CPU相关的mpproc结构和与IOAPIC相关的mpioapic结构的信息&#xff1b;&#xff08; mp.c文件的mpinit函数&#xff09;&#xff3b;Q&#xff3d;mp.c的139&#xff5e;142行有什么作用&#xff1f;</p>\n<p>2. 初始化BSP的Local APIC&#xff1b;&#xff08;lapic文件的lapicinit函数&#xff09; </p>\n<p>3. 在此还初始化了内核中的许多关键数据结构&#xff0c;包括对ioapic的初始化&#xff0c;函数为ioapicinit()&#xff0c;不过与AP没有直接关系&#xff1b;&#xff08;main.c文件的main函数的24~36行&#xff09;</p>\n<p>4. 设置AP的启动代码的起始函数start(位于entryother.S)和此函数结束后将跳转继续执行的函数mpmain&#xff08;位于main.c&#xff09;和堆栈&#xff0c;通过IPI中断来启动各个AP&#xff1b;&#xff08;main.c文件的startothers函数&#xff09;</p>\n<p>5. 运行scheduler。&#xff08;main.c文件的mpmain函数&#xff09; </p>\n<p></p>\n<p>在每个AP中&#xff0c;xv6按照如下顺序来执行&#xff1a; </p>\n<p>  </p>\n<p>1. 进入保护模式 </p>\n<p>2. 初始化AP的Local APIC </p>\n<p>3. 运行scheduler </p>\n<p> </p>\n<p>函数分析</p>\n<p> </p>\n<p>由于上文中已经介绍过系统启动的大部分内容&#xff0c;故下文中只介绍与多处理器相关的代码。 </p>\n<p> </p>\n<p>mp.c </p>\n<p> </p>\n<p>该文件用来获得MP Configuration Table&#xff0c;启动各个AP。下面是相关函数的分析说明&#xff1a; </p>\n<p>mpsearch: 寻找Floating Point Structure </p>\n<p>在不同的计算机上&#xff0c;Floating Point Structure并不在同一个位置。根据intel的文档&#xff0c;应该按顺序在如下三个位置查找&#xff1a; </p>\n<p>  </p>\n<p>1. 在Extended BIOS Data Area的第一个KB中 </p>\n<p>2. 在System Base Memory的最后一个KB中 </p>\n<p>3. 在BIOS ROM中&#xff0c;地址0xE0000~0xFFFFF </p>\n<p> </p>\n<p>mpsearch: 判断指定内存位置是否为Floating Point Structure&#xff0c;并调用mp_search1查找mp数据结构</p>\n<p>mpsearch1: 根据“_MP_”和checksum来查找mp数据结构</p>\n<p>mpconfig: 在调用mp_search的基础上&#xff0c;进一步检测找到的MP Configuration Table是否合法 </p>\n<p>mpinit: 找到MP Configuration Table&#xff0c;并获取相关信息。[Q]ncpu的初始值为多少&#xff1f;原因是&#xff1f; </p>\n<p>mpbcpu: 返回当前cpu在cpus数组中的下标作为编号 </p>\n<p> </p>\n<p>entryother.S </p>\n<p> </p>\n<p>AP的启动代码在entryother.S的start函数&#xff0c;具体操作为&#xff1a; </p>\n<p>29~32行&#xff0c;在实模式下初始化各个寄存器 </p>\n<p>34~40行&#xff0c;进入保护模式 </p>\n<p>44~50行&#xff0c;在保护模式下初始化各个段寄存器 </p>\n<p>65~67行&#xff0c;设置esp并跳转到指定函数地址(mpenter函数) </p>\n<p>值得一提的是&#xff0c;在这里定义的start的地址在0x7000&#xff0c;由Makefile中进行规定&#xff0c;start之前的12个字节用来在start和entryother.S中传递数据。start-4为栈的地址&#xff0c;而start-8为要执行的函数地址,start-12是目录的物理地址</p>\n<p> </p>\n<p>lapic.c </p>\n<p> </p>\n<p>cpunum: 读取Local APIC的ID寄存器&#xff0c;给出当前核的第一种编号 </p>\n<p>lapicstartap: 使用Inter-processor Interrupt来启动指定的AP </p>\n<p> </p>\n<p>main.c </p>\n<p> </p>\n<p>main: BSP的初始化&#xff0c;其中&#xff1a; </p>\n<p>18行&#xff0c;把BSS清零</p>\n<p>20行&#xff0c;获取MP Configuration Table的信息 </p>\n<p>21行&#xff0c;获得apicid&#xff0c;初始化BSP的Local APIC </p>\n<p>37行&#xff0c;启动各个AP </p>\n<p>89行&#xff0c;调用mpmain&#xff0c;运行scheduler </p>\n<p> </p>\n<p>该文件中与Multi Processor有关的有三个函数&#xff1a; </p>\n<p>mpenter: AP的初始化函数&#xff0c;在entryother.S进入保护模式后执行&#xff0c;其中&#xff1a;</p>\n<p>49行&#xff1a;切换到内核页表</p>\n<p>50行&#xff1a;初始化cpu的内核段描述符</p>\n<p>51行&#xff1a;初始化lapic</p>\n<p>52行&#xff1a;调用函数mpmain</p>\n<p></p>\n<p>mpmain&#xff1a;被mpenter所调用&#xff0c;其中&#xff1a; </p>\n<p>59行&#xff0c;显示输出cpuid </p>\n<p>60行&#xff0c;加载idt</p>\n<p>61行&#xff0c;设置标志&#xff0c;表示AP已经启动完毕</p>\n<p>62行&#xff0c;启动scheduler </p>\n<p> </p>\n<p>startothers: 循环启动每一个AP&#xff0c;具体操作为&#xff1a; </p>\n<p>71行&#xff0c;引用了entryother.S中的启动代码 </p>\n<p>79~80行&#xff0c;将启动代码复制入内存地址为0x7000的地方 </p>\n<p>83~84行&#xff0c;排除BSP </p>\n<p>91行&#xff1a;为ap分配栈地址</p>\n<p>90~92行&#xff0c;将mpenter地址与栈地址写入entryother.S代码之前&#xff0c;由entryother.S负责初始化栈和跳转至mpenter函数 </p>\n<p>79行&#xff0c;执行lapicstartap </p>\n<p>82行&#xff0c;等待AP初始化完毕 </p>", "subject": "[INFO]xv6多处理器支持的初步分析"}, {"uid": "i76zk4ijtWy", "anon": "no", "created": "2015-03-13T07:28:10Z", "content": "<p>本章将给出xv6多处理器支持的实现概貌。读者将学习以下一些内容: </p>\n<ul><li>什么是SMP系统&#xff1f; </li><li>什么是PIC&#xff0c;LAPIC&#xff0c;IOAPIC?</li><li>xv6是如何识别一个计算机系统中的多个CPU的&#xff1f; </li><li>xv6是如何支持CPU之间的中断信息传递的&#xff1f; </li><li>xv6如何初始化主处理器&#xff08;BP&#xff09;和从处理器&#xff08;AP&#xff09;的&#xff1f; </li></ul>\n<p> </p>\n<p>    xv6的一个独特之处在于它支持基于多处理器的计算机系统&#xff0c;即对称多处理计算机系统。SMP是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。它是应用十分广泛的并行技术。在这种架构中&#xff0c;一台电脑不再由单个处理器组成&#xff0c;而同时由多个处理器运行操作系统的单一复本&#xff0c;并共享内存和一台计算机的其他资源。虽然同时使用多个处理器&#xff0c;但是从管理的角度来看&#xff0c;它们的表现就像一台单处理器的计算机一样。系统将任务队列对称地分布于多个处理器之上&#xff0c;从而极大地提高了整个系统的数据处理能力。所有的处理器都可以平等地访问内存、I/O和外部中断。在对称多处理系统中&#xff0c;系统资源被系统中所有CPU共享&#xff0c;工作负载能够均匀地分配到所有可用处理器之上。在xv6中&#xff0c;每一个核上都可以独立地运行一个进程。本章侧重介绍与多处理器有关的内容&#xff1b;在本章内&#xff0c;读者可以了解到xv6是如何支持多处理器的。</p>\n<h2>2. APIC </h2>\n<p>APIC&#xff08;Advanced Programmable Interrupt Controller&#xff09;是一个与8259A兼容的高级中断处理器。它不但实现了中断处理的功能&#xff0c;还实现了以下功能&#xff1a;</p>\n<p>1. 提供与中断相关的设备通讯 </p>\n<p>2. 提供多处理器&#xff08;或多CPU&#xff09;之间的中断共享与中断通讯 </p>\n<p>事实上&#xff0c;xv6与外部设备的很大一部分通讯处理&#xff0c;都是通过APIC来实现的。<br /><br />APIC分为两层&#xff1a;Local APIC和I/O APIC。 </p>\n<p> </p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/hcrrjuyequh4bt/i76yevpeclj3/图片1.jpg\" /></p>\n<p> </p>\n<p> </p>\n<h3>a. I/O APIC </h3>\n<p>I/O APIC是用来与外部设备通讯的&#xff0c;它完成了APIC最主要的功能&#xff1a;中断处理。 </p>\n<p>I/O APIC提供了两个模式&#xff0c;普通模式和8259A兼容模式。xv6在单核环境下&#xff0c;会选择使用8259A兼容模式&#xff0c;而在多处理器环境下&#xff0c;则会使用普通模式。 </p>\n<h3>b. Local APIC </h3>\n<p>Local APIC是APIC的顶层&#xff0c;每个核都有一个对应的Local APIC。它负责进行多处理器之间的中断传输&#xff0c;屏蔽中断&#xff0c;还提供了一个可编程的Timer。由于I/O APIC已经提供了中断处理的功能&#xff0c;Local APIC只是起辅助作用&#xff0c;可以屏蔽不用。 </p>\n<p>xv6在单核环境中&#xff0c;Local APIC被屏蔽不用&#xff1b;而只有在多处理器环境中&#xff0c;Local APIC才被打开&#xff0c;完成初始化每个核、开关中断、Timer等功能。 </p>\n<h3>c. Timer </h3>\n<p>如上文所提到的&#xff0c;Local APIC提供了一个可编程的Timer。所以xv6在多处理器环境下&#xff0c;每个核使用其对应的Local APIC提供的Timer。 </p>\n<p>而在单核环境下&#xff0c;Local APIC并没有被打开。xv6使用了8253PIT(Programmable Interval Timer)来实现时钟中断。 </p>\n<p>相关代码&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>if(ismp) </p>\n<p>  lapic_timerinit(); </p>\n<p>else </p>\n<p>  pit8253_timerinit(); </p>\n</td></tr></tbody></table>\n<p></p>\n<p>注&#xff1a;github中最新的xv6已经移除了lapic_timerinit()和pit8253_timerinit()&#xff0c;目前和时钟中断有关的函数仅剩下timerinit()&#xff0c;并且默认在多核情况下是不调用的&#xff0c;如下main函数中的代码&#xff1a;</p>\n<p></p>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"6px\"><tbody><tr><td>36 if(!ismp)<br />37   timerinit(); // uniprocessor timer</td></tr></tbody></table>\n<p> </p>\n<p>picirq.c<br /><br />该文件提供了与8259A兼容的中断处理函数&#xff0c;包括&#xff1a;<br />picinit:  初始化8259A中断控制器<br />picenable: 打开指定的中断<br />picsetmask: 更改IRQ mask寄存器<br /><br />ioapic.c<br /><br />该文件提供了xv6与I/O APIC使用普通模式通讯的函数&#xff0c;包括&#xff1a;<br />ioapicinit: 初始化I/O APIC<br />ioapicread: 读I/O APIC寄存器<br />ioapicwrite: 写I/O APIC寄存器<br />该文件还包括了函数ioapicenable&#xff0c;带有两个参数&#xff0c;irq和cpunum。它用来在cpunum号核上&#xff0c;打开irq所指的中断。<br />在整个xv6中&#xff0c;这个函数被调用了两次&#xff0c;分别是打开键盘在第一个核上的中断&#xff0c;和打开IDE在最后一个核上的中断。 </p>\n<p>在多处理器的环境下&#xff0c;I/O APIC开中断之后&#xff0c;指定的核并不能收到指定的中断。只有在指定的核的Local APIC中开中断后&#xff0c;才能收到指定的中断。<br />值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。<br /><br />lapic.c<br /><br />该文件提供了xv6与Local APIC通讯的函数&#xff0c;包括&#xff1a; </p>\n<p>lapicw: 写Local APIC寄存器 </p>\n<p>lapicinit: 初始化某个核的Local APIC&#xff0c;其中关键操作&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>lapicw(SVR, ENABLE | (T_IRQ0 &#43; IRQ_SPURIOUS)); // 打开APIC<br /><br />lapicw(ICRHI, 0);<br />lapicw(ICRLO, BCAST | INIT | LEVEL); // 发送init命令<br />while(lapic[ICRLO] &amp; DELIVS); // 等待init完成 </p>\n</td></tr></tbody></table>\n<p>lapiceoi: 响应中断(Acknowledge Interrupt)&#xff0c;向EOI寄存器发送0 </p>\n<p></p>\n<p>另外还有两个函数cpunum和lapicstartap&#xff0c;将在下一节Multi Processor中介绍。 </p>\n<p>值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。 </p>\n<p> </p>\n<p></p>\n<p>在多处理器环境下&#xff0c;xv6会在每个核上运行scheduler&#xff0c;平等地分配进程。关于进程调度&#xff0c;上文中已经有详细的介绍。而本节的内容主要是介绍xv6对于多处理器的初始化。APIC可以认为是xv6与多处理器硬件之间的接口&#xff0c;几乎所有与多处理器有关的操作都要通过APIC来实现。下面是有关多处理器的一下基本概念和初始化分析。 </p>\n<h3>a. BSP和AP </h3>\n<p>APIC将核分为了两类&#xff1a;BSP(Bootstrap Processor)和AP(Application Processor)。顾名思义&#xff0c;前者是操作系统启动时第一个使用的核&#xff0c;而后者是随后将使用的核。在实际的多处理器环境中&#xff0c;BSP只有一个&#xff08;编号为0&#xff09;&#xff0c;xv6启动时就运行在它上面&#xff0c;完成基本的初始化工作&#xff0c;识别出其他的AP。AP可能有很多个&#xff0c;每个需要使用类似初始化BSP的代码来启动。在xv6中&#xff0c;只有在初始化时&#xff0c;这两类核才有区别&#xff1b;操作系统多处理初始化&#xff0c;并正常运行后&#xff0c;它们便不再有区别了。 </p>\n<h3>b. MP Configuration Table </h3>\n<p>MP Configuration Table是硬件提供给操作系统&#xff0c;用来描述多处理器信息的一个结构&#xff0c;在BSP上运行的xv6首先需要找到它&#xff0c;完成对AP、LAPIC、IOAPIC的查找和基本的初始化。该表由三部分组成&#xff1a; </p>\n<p>  </p>\n<p>1. Floating Point Structure: 作为一个指针&#xff0c;给出Configuration Table在内存中的位置 </p>\n<p>2. Configuration Table Header: 表头&#xff0c;在xv6中提供Local APIC寄存器的位置 </p>\n<p>3. Table Entry: 表项&#xff0c;一共有4种&#xff1a; </p>\n<ul><li>Processor Table Entry </li><li>Bus Table Entry</li><li>I/O APIC Table Entry</li><li>Interrupt Table Entry</li></ul>\n<p>        其中唯一对xv6真正有价值的是Processor Table Entry。其中apicid以及flag中的MPBP标志位&#xff0c;前者是每一个核的编号&#xff0c;而后者用来识别哪个核是BP。</p>\n<h3>c. Processor的编号 </h3>\n<p>在xv6中&#xff0c;使用到两种核的编号。第一种是apicid&#xff0c;也就是上文中从Processor Table Entry中获得的&#xff1b;而第二种是核在cpus数组中的下标。 </p>\n<p>前一种在初始化启动AP时会使用到(lapicstartap函数)。而后一种只使用过一次&#xff1a;在初始化Local APIC时&#xff0c;只有BSP使用了cpus数组的下标作为lapicinit的参数&#xff0c;而AP则使用了apicid作为lapicinit的参数。幸好lapicinit函数中并没有用到这个参数&#xff0c;不然可是会出大乱子的。 </p>\n<h3>d. Inter-processor Interrupt </h3>\n<p>IPI(Inter-processor Interrupt)是多处理器之间通讯的一种方式。在xv6中&#xff0c;它用来在BSP和各个AP之间通讯&#xff0c;以启动AP。它是通过读写Local APIC的寄存器来实现的。 </p>\n<h3>e. 初始化顺序</h3>\n<p>在多处理器环境下&#xff0c;xv6按照以下顺序来初始化BSP和各个AP&#xff1a; </p>\n<p>  </p>\n<p>1. 查找并读取MP Configuration Table&#xff0c;获取LAPIC配置起始地址&#xff0c;填写与CPU相关的mpproc结构和与IOAPIC相关的mpioapic结构的信息&#xff1b;&#xff08; mp.c文件的mpinit函数&#xff09;&#xff3b;Q&#xff3d;mp.c的139&#xff5e;142行有什么作用&#xff1f;</p>\n<p>2. 初始化BSP的Local APIC&#xff1b;&#xff08;lapic文件的lapicinit函数&#xff09; </p>\n<p>3. 在此还初始化了内核中的许多关键数据结构&#xff0c;包括对ioapic的初始化&#xff0c;函数为ioapicinit()&#xff0c;不过与AP没有直接关系&#xff1b;&#xff08;main.c文件的main函数的24~36行&#xff09;</p>\n<p>4. 设置AP的启动代码的起始函数start(位于entryother.S)和此函数结束后将跳转继续执行的函数mpmain&#xff08;位于main.c&#xff09;和堆栈&#xff0c;通过IPI中断来启动各个AP&#xff1b;&#xff08;main.c文件的startothers函数&#xff09;</p>\n<p>5. 运行scheduler。&#xff08;main.c文件的mpmain函数&#xff09; </p>\n<p></p>\n<p>在每个AP中&#xff0c;xv6按照如下顺序来执行&#xff1a; </p>\n<p>  </p>\n<p>1. 进入保护模式 </p>\n<p>2. 初始化AP的Local APIC </p>\n<p>3. 运行scheduler </p>\n<p> </p>\n<p>函数分析</p>\n<p> </p>\n<p>由于上文中已经介绍过系统启动的大部分内容&#xff0c;故下文中只介绍与多处理器相关的代码。 </p>\n<p> </p>\n<p>mp.c </p>\n<p> </p>\n<p>该文件用来获得MP Configuration Table&#xff0c;启动各个AP。下面是相关函数的分析说明&#xff1a; </p>\n<p>mpsearch: 寻找Floating Point Structure </p>\n<p>在不同的计算机上&#xff0c;Floating Point Structure并不在同一个位置。根据intel的文档&#xff0c;应该按顺序在如下三个位置查找&#xff1a; </p>\n<p>  </p>\n<p>1. 在Extended BIOS Data Area的第一个KB中 </p>\n<p>2. 在System Base Memory的最后一个KB中 </p>\n<p>3. 在BIOS ROM中&#xff0c;地址0xE0000~0xFFFFF </p>\n<p> </p>\n<p>mpsearch: 判断指定内存位置是否为Floating Point Structure&#xff0c;并调用mp_search1查找mp数据结构</p>\n<p>mpsearch1: 根据“_MP_”和checksum来查找mp数据结构</p>\n<p>mpconfig: 在调用mp_search的基础上&#xff0c;进一步检测找到的MP Configuration Table是否合法 </p>\n<p>mpinit: 找到MP Configuration Table&#xff0c;并获取相关信息。[Q]ncpu的初始值为多少&#xff1f;原因是&#xff1f; </p>\n<p>mpbcpu: 返回当前cpu在cpus数组中的下标作为编号 </p>\n<p> </p>\n<p>entryother.S </p>\n<p> </p>\n<p>AP的启动代码在entryother.S的start函数&#xff0c;具体操作为&#xff1a; </p>\n<p>29~32行&#xff0c;在实模式下初始化各个寄存器 </p>\n<p>34~40行&#xff0c;进入保护模式 </p>\n<p>44~50行&#xff0c;在保护模式下初始化各个段寄存器 </p>\n<p>65~67行&#xff0c;设置esp并跳转到指定函数地址(mpenter函数) </p>\n<p>值得一提的是&#xff0c;start之前的8个字节用来在start和entryother.S中传递数据。start-4为栈地址&#xff0c;而start-8为要执行的函数地址 </p>\n<p> </p>\n<p>lapic.c </p>\n<p> </p>\n<p>cpunum: 读取Local APIC的ID寄存器&#xff0c;给出当前核的第一种编号 </p>\n<p>lapicstartap: 使用Inter-processor Interrupt来启动指定的AP </p>\n<p> </p>\n<p>main.c </p>\n<p> </p>\n<p>main: BSP的初始化&#xff0c;其中&#xff1a; </p>\n<p>18行&#xff0c;把BSS清零</p>\n<p>20行&#xff0c;获取MP Configuration Table的信息 </p>\n<p>21行&#xff0c;获得apicid&#xff0c;初始化BSP的Local APIC </p>\n<p>37行&#xff0c;启动各个AP </p>\n<p>89行&#xff0c;调用mpmain&#xff0c;运行scheduler </p>\n<p> </p>\n<p>该文件中与Multi Processor有关的有三个函数&#xff1a; </p>\n<p>mpenter: AP的初始化函数&#xff0c;在entryother.S进入保护模式后执行&#xff0c;其中&#xff1a;</p>\n<p>49行&#xff1a;切换到内核页表</p>\n<p>50行&#xff1a;初始化cpu的内核段描述符</p>\n<p>51行&#xff1a;初始化lapic</p>\n<p>52行&#xff1a;调用函数mpmain</p>\n<p></p>\n<p>mpmain&#xff1a;被mpenter所调用&#xff0c;其中&#xff1a; </p>\n<p>59行&#xff0c;显示输出cpuid </p>\n<p>60行&#xff0c;加载idt</p>\n<p>61行&#xff0c;设置标志&#xff0c;表示AP已经启动完毕</p>\n<p>62行&#xff0c;启动scheduler </p>\n<p> </p>\n<p>startothers: 循环启动每一个AP&#xff0c;具体操作为&#xff1a; </p>\n<p>71行&#xff0c;引用了entryother.S中的启动代码 </p>\n<p>79~80行&#xff0c;将启动代码复制入内存地址为0x7000的地方 </p>\n<p>83~84行&#xff0c;排除BSP </p>\n<p>91行&#xff1a;为ap分配栈地址</p>\n<p>90~92行&#xff0c;将mpenter地址与栈地址写入entryother.S代码之前&#xff0c;由entryother.S负责初始化栈和跳转至mpenter函数 </p>\n<p>79行&#xff0c;执行lapicstartap </p>\n<p>82行&#xff0c;等待AP初始化完毕 </p>", "subject": "[INFO]xv6多处理器支持的初步分析"}, {"uid": "hcrrjuyequh4bt", "anon": "no", "created": "2015-03-13T02:18:15Z", "content": "<p>本章将给出xv6多处理器支持的实现概貌。读者将学习以下一些内容: </p>\n<ul><li>什么是SMP系统&#xff1f; </li><li>什么是PIC&#xff0c;LAPIC&#xff0c;IOAPIC?</li><li>xv6是如何识别一个计算机系统中的多个CPU的&#xff1f; </li><li>xv6是如何支持CPU之间的中断信息传递的&#xff1f; </li><li>xv6如何初始化主处理器&#xff08;BP&#xff09;和从处理器&#xff08;AP&#xff09;的&#xff1f; </li></ul>\n<p> </p>\n<p>    xv6的一个独特之处在于它支持基于多处理器的计算机系统&#xff0c;即对称多处理计算机系统。SMP是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。它是应用十分广泛的并行技术。在这种架构中&#xff0c;一台电脑不再由单个处理器组成&#xff0c;而同时由多个处理器运行操作系统的单一复本&#xff0c;并共享内存和一台计算机的其他资源。虽然同时使用多个处理器&#xff0c;但是从管理的角度来看&#xff0c;它们的表现就像一台单处理器的计算机一样。系统将任务队列对称地分布于多个处理器之上&#xff0c;从而极大地提高了整个系统的数据处理能力。所有的处理器都可以平等地访问内存、I/O和外部中断。在对称多处理系统中&#xff0c;系统资源被系统中所有CPU共享&#xff0c;工作负载能够均匀地分配到所有可用处理器之上。在xv6中&#xff0c;每一个核上都可以独立地运行一个进程。本章侧重介绍与多处理器有关的内容&#xff1b;在本章内&#xff0c;读者可以了解到xv6是如何支持多处理器的。</p>\n<h2>2. APIC </h2>\n<p>APIC&#xff08;Advanced Programmable Interrupt Controller&#xff09;是一个与8259A兼容的高级中断处理器。它不但实现了中断处理的功能&#xff0c;还实现了以下功能&#xff1a;</p>\n<p>1. 提供与中断相关的设备通讯 </p>\n<p>2. 提供多处理器&#xff08;或多CPU&#xff09;之间的中断共享与中断通讯 </p>\n<p>事实上&#xff0c;xv6与外部设备的很大一部分通讯处理&#xff0c;都是通过APIC来实现的。<br /><br />APIC分为两层&#xff1a;Local APIC和I/O APIC。 </p>\n<p> </p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/hcrrjuyequh4bt/i76yevpeclj3/图片1.jpg\" /></p>\n<p> </p>\n<p> </p>\n<h3>a. I/O APIC </h3>\n<p>I/O APIC是用来与外部设备通讯的&#xff0c;它完成了APIC最主要的功能&#xff1a;中断处理。 </p>\n<p>I/O APIC提供了两个模式&#xff0c;普通模式和8259A兼容模式。xv6在单核环境下&#xff0c;会选择使用8259A兼容模式&#xff0c;而在多处理器环境下&#xff0c;则会使用普通模式。 </p>\n<h3>b. Local APIC </h3>\n<p>Local APIC是APIC的顶层&#xff0c;每个核都有一个对应的Local APIC。它负责进行多处理器之间的中断传输&#xff0c;屏蔽中断&#xff0c;还提供了一个可编程的Timer。由于I/O APIC已经提供了中断处理的功能&#xff0c;Local APIC只是起辅助作用&#xff0c;可以屏蔽不用。 </p>\n<p>xv6在单核环境中&#xff0c;Local APIC被屏蔽不用&#xff1b;而只有在多处理器环境中&#xff0c;Local APIC才被打开&#xff0c;完成初始化每个核、开关中断、Timer等功能。 </p>\n<h3>c. Timer </h3>\n<p>如上文所提到的&#xff0c;Local APIC提供了一个可编程的Timer。所以xv6在多处理器环境下&#xff0c;每个核使用其对应的Local APIC提供的Timer。 </p>\n<p>而在单核环境下&#xff0c;Local APIC并没有被打开。xv6使用了8253PIT(Programmable Interval Timer)来实现时钟中断。 </p>\n<p>相关代码&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>if(ismp) </p>\n<p>  lapic_timerinit(); </p>\n<p>else </p>\n<p>  pit8253_timerinit(); </p>\n</td></tr></tbody></table>\n<p> </p>\n<p>picirq.c<br /><br />该文件提供了与8259A兼容的中断处理函数&#xff0c;包括&#xff1a;<br />pic_init:  初始化8259A中断控制器<br />irq_enable: 打开指定的中断<br />irq_setmask_8259A: 更改IRQ mask寄存器<br /><br />ioapic.c<br /><br />该文件提供了xv6与I/O APIC使用普通模式通讯的函数&#xff0c;包括&#xff1a;<br />ioapic_init: 初始化I/O APIC<br />ioapic_read: 读I/O APIC寄存器<br />ioapic_write: 写I/O APIC寄存器<br />该文件还包括了函数ioapic_enable&#xff0c;带有两个参数&#xff0c;irq和cpunum。它用来在cpunum号核上&#xff0c;打开irq所指的中断。<br />在整个xv6中&#xff0c;这个函数被调用了两次&#xff0c;分别是打开键盘在第一个核上的中断&#xff0c;和打开IDE在最后一个核上的中断。 </p>\n<p>在多处理器的环境下&#xff0c;I/O APIC开中断之后&#xff0c;指定的核并不能收到指定的中断。只有在指定的核的Local APIC中开中断后&#xff0c;才能收到指定的中断。<br />值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。<br /><br />lapic.c<br /><br />该文件提供了xv6与Local APIC通讯的函数&#xff0c;包括&#xff1a; </p>\n<p>lapic_read: 读Local APIC寄存器 </p>\n<p>lapic_write: 写Local APIC寄存器 </p>\n<p>lapic_init: 初始化某个核的Local APIC&#xff0c;其中关键操作&#xff1a; </p>\n<p> </p>\n<table><tbody><tr><td>\n<p>lapic_write(LAPIC_SVR, LAPIC_ENABLE|(IRQ_OFFSET&#43;IRQ_SPURIOUS)); // 打开APIC<br /><br />lapic_write(LAPIC_ICRHI, 0);<br />lapic_write(LAPIC_ICRLO, LAPIC_ALLINC|APIC_LEVEL|LAPIC_DEASSERT|APIC_INIT); // 发送init命令<br />while(lapic_read(LAPIC_ICRLO) &amp; APIC_DELIVS); // 等待init完成 </p>\n</td></tr></tbody></table>\n<p>lapic_eoi: 响应中断(Acknowledge Interrupt)&#xff0c;向EOI寄存器发送0 </p>\n<p>lapic_timerinit: 初始化Local APIC提供的Timer </p>\n<p>lapic_timerintr: Timer中断处理函数&#xff0c;内容只是简单地Acknowledge Interrupt </p>\n<p>lapic_enableintr: 开中断&#xff0c;设置TPR(Task Priority Register)为0 </p>\n<p>lapic_disableintr: 关中断&#xff0c;设置TPR(Task Priority Register)为0xFF </p>\n<p>另外还有两个函数cpu和lapic_startap&#xff0c;将在下一节Multi Processor中介绍。 </p>\n<p>值得一提的是&#xff0c;该文件的所有函数只有在多处理器的环境下才会被执行。 </p>\n<p> </p>\n<p>8253pit.c </p>\n<p> </p>\n<p>该文件用来控制8253PIT&#xff0c;整个文件只有一个函数&#xff1a;pit8253_timerinit </p>\n<p>当该函数被调用后&#xff0c;8253PIT会定期产生时钟中断。 </p>\n<p>在多处理器环境下&#xff0c;xv6会在每个核上运行scheduler&#xff0c;平等地分配进程。关于进程调度&#xff0c;上文中已经有详细的介绍。而本节的内容主要是介绍xv6对于多处理器的初始化。APIC可以认为是xv6与多处理器硬件之间的接口&#xff0c;几乎所有与多处理器有关的操作都要通过APIC来实现。下面是有关多处理器的一下基本概念和初始化分析。 </p>\n<h3>a. BSP和AP </h3>\n<p>APIC将核分为了两类&#xff1a;BSP(Bootstrap Processor)和AP(Application Processor)。顾名思义&#xff0c;前者是操作系统启动时第一个使用的核&#xff0c;而后者是随后将使用的核。在实际的多处理器环境中&#xff0c;BSP只有一个&#xff08;编号为0&#xff09;&#xff0c;xv6启动时就运行在它上面&#xff0c;完成基本的初始化工作&#xff0c;识别出其他的AP。AP可能有很多个&#xff0c;每个需要使用类似初始化BSP的代码来启动。在xv6中&#xff0c;只有在初始化时&#xff0c;这两类核才有区别&#xff1b;操作系统多处理初始化&#xff0c;并正常运行后&#xff0c;它们便不再有区别了。 </p>\n<h3>b. MP Configuration Table </h3>\n<p>MP Configuration Table是硬件提供给操作系统&#xff0c;用来描述多处理器信息的一个结构&#xff0c;在BSP上运行的xv6首先需要找到它&#xff0c;完成对AP、LAPIC、IOAPIC的查找和基本的初始化。该表由三部分组成&#xff1a; </p>\n<p>  </p>\n<p>1. Floating Point Structure: 作为一个指针&#xff0c;给出Configuration Table在内存中的位置 </p>\n<p>2. Configuration Table Header: 表头&#xff0c;在xv6中提供Local APIC寄存器的位置 </p>\n<p>3. Table Entry: 表项&#xff0c;一共有4种&#xff1a; </p>\n<ul><li>Processor Table Entry </li><li>Bus Table Entry</li><li>I/O APIC Table Entry</li><li>Interrupt Table Entry</li></ul>\n<p>        其中唯一对xv6真正有价值的是Processor Table Entry。其中apicid以及flag中的MPBP标志位&#xff0c;前者是每一个核的编号&#xff0c;而后者用来识别哪个核是BP。</p>\n<h3>c. Processor的编号 </h3>\n<p>在xv6中&#xff0c;使用到两种核的编号。第一种是apicid&#xff0c;也就是上文中从Processor Table Entry中获得的&#xff1b;而第二种是核在cpus数组中的下标。 </p>\n<p>前一种在初始化启动AP时会使用到(lapic_startap函数)。而后一种只使用过一次&#xff1a;在初始化Local APIC时&#xff0c;只有BSP使用了cpus数组的下标作为lapic_init的参数&#xff0c;而AP则使用了apicid作为lapic_init的参数。幸好lapic_init函数中并没有用到这个参数&#xff0c;不然可是会出大乱子的。 </p>\n<h3>d. Inter-processor Interrupt </h3>\n<p>IPI(Inter-processor Interrupt)是多处理器之间通讯的一种方式。在xv6中&#xff0c;它用来在BSP和各个AP之间通讯&#xff0c;以启动AP。它是通过读写Local APIC的寄存器来实现的。 </p>\n<h3>e. 初始化顺序</h3>\n<p>在多处理器环境下&#xff0c;xv6按照以下顺序来初始化BSP和各个AP&#xff1a; </p>\n<p>  </p>\n<p>1. 查找并读取MP Configuration Table&#xff0c;获取LAPIC配置起始地址&#xff0c;填写与CPU相关的mpproc结构和与IOAPIC相关的mpioapic结构的信息&#xff1b;&#xff08; mp.c文件的mp_init函数&#xff09;&#xff3b;Q&#xff3d;mp.c的139&#xff5e;142行有什么作用&#xff1f;</p>\n<p>2. 初始化BSP的Local APIC&#xff1b;&#xff08;lapic文件的lapic_init函数&#xff09; </p>\n<p>3. 在此还初始化了内核中的许多关键数据结构&#xff0c;不过与AP没有直接关系&#xff1b;&#xff08;main.c文件的main函数的24~36行&#xff09;</p>\n<p>4. 设置AP的启动代码的起始函数start(位于bootother.S)和此函数结束后将跳转继续执行的函数mpmain&#xff08;位于main.c&#xff09;和堆栈&#xff0c;通过IPI中断来启动各个AP&#xff1b;&#xff08;main.c文件的bootothers函数&#xff09;</p>\n<p>5. 运行scheduler。&#xff08;main.c文件的mpmain函数&#xff09; </p>\n<p>在每个AP中&#xff0c;xv6按照如下顺序来执行&#xff1a; </p>\n<p>  </p>\n<p>1. 进入保护模式 </p>\n<p>2. 初始化AP的Local APIC </p>\n<p>3. 运行scheduler </p>\n<p> </p>\n<p>函数分析</p>\n<p> </p>\n<p>由于上文中已经介绍过系统启动的大部分内容&#xff0c;故下文中只介绍与多处理器相关的代码。 </p>\n<p> </p>\n<p>mp.c </p>\n<p> </p>\n<p>该文件用来获得MP Configuration Table&#xff0c;启动各个AP。下面是相关函数的分析说明&#xff1a; </p>\n<p>mp_search: 寻找Floating Point Structure </p>\n<p>在不同的计算机上&#xff0c;Floating Point Structure并不在同一个位置。根据intel的文档&#xff0c;应该按顺序在如下三个位置查找&#xff1a; </p>\n<p>  </p>\n<p>1. 在Extended BIOS Data Area的第一个KB中 </p>\n<p>2. 在System Base Memory的最后一个KB中 </p>\n<p>3. 在BIOS ROM中&#xff0c;地址0xE0000~0xFFFFF </p>\n<p> </p>\n<p>mp_search: 判断指定内存位置是否为Floating Point Structure&#xff0c;并调用mp_search1查找mp数据结构</p>\n<p>mp_search1: 根据“_MP_”和checksum来查找mp数据结构</p>\n<p>mp_config: 在调用mp_search的基础上&#xff0c;进一步检测找到的MP Configuration Table是否合法 </p>\n<p>mp_init: 找到MP Configuration Table&#xff0c;并获取相关信息。[Q]ncpu的初始值为多少&#xff1f;原因是&#xff1f; </p>\n<p>mp_bcpu: 返回当前cpu在cpus数组中的下标作为编号 </p>\n<p> </p>\n<p>bootother.S </p>\n<p> </p>\n<p>AP的启动代码在other.S的bootstart函数&#xff0c;具体操作为&#xff1a; </p>\n<p>26~36行&#xff0c;在实模式下初始化各个寄存器 </p>\n<p>42~51行&#xff0c;进入保护模式 </p>\n<p>59~64行&#xff0c;在保护模式下初始化各个段寄存器 </p>\n<p>66~68行&#xff0c;设置esp并跳转到指定函数地址(mpmain函数) </p>\n<p>值得一提的是&#xff0c;start之前的8个字节用来在mp_startthem和bootother.S中传递数据。start-4为栈地址&#xff0c;而start-8为要执行的函数地址 </p>\n<p> </p>\n<p>lapic.c </p>\n<p> </p>\n<p>cpu: 读取Local APIC的ID寄存器&#xff0c;给出当前核的第一种编号 </p>\n<p>lapic_startap: 使用Inter-processor Interrupt来启动指定的AP </p>\n<p> </p>\n<p>main.c </p>\n<p> </p>\n<p>该文件中与Multi Processor有关的有两个函数&#xff1a; </p>\n<p>main: BSP的初始化&#xff0c;其中&#xff1a; </p>\n<p>18行&#xff0c;把BSS清零</p>\n<p>20行&#xff0c;获取MP Configuration Table的信息 </p>\n<p>21行&#xff0c;获得apicid&#xff0c;初始化BSP的Local APIC </p>\n<p>37行&#xff0c;启动各个AP </p>\n<p>89行&#xff0c;调用mpmain&#xff0c;运行scheduler </p>\n<p> </p>\n<p>mpmain: AP的初始化函数&#xff0c;在bootother.S进入保护模式后执行&#xff0c;其中&#xff1a; </p>\n<p>48行&#xff0c;显示输出cpid </p>\n<p>49行&#xff0c;加载idt</p>\n<p>50~51行&#xff0c;获得apicid&#xff0c;如果cpu是AP&#xff0c;则初始化AP的Local APIC </p>\n<p>52行&#xff0c;设置段模式 </p>\n<p>53行&#xff0c;设置标志&#xff0c;表示AP已经启动完毕</p>\n<p>56行&#xff0c;启动scheduler </p>\n<p> </p>\n<p>bootothers: 循环启动每一个AP&#xff0c;具体操作为&#xff1a; </p>\n<p>68行&#xff0c;引用了bootother.S中的启动代码 </p>\n<p>69行&#xff0c;将启动代码复制入APBOOTCODE(一块空内存) </p>\n<p>72~73行&#xff0c;排除BSP </p>\n<p>76~78行&#xff0c;将mpmain地址与栈地址写入bootother.S代码之前&#xff0c;由bootother.S负责初始化栈和跳转至mpmain函数 </p>\n<p>79行&#xff0c;执行lapic_startap </p>\n<p>82行&#xff0c;等待AP初始化完毕 </p>", "subject": "[INFO]xv6多处理器支持的初步分析"}], "s_edits": [], "tag_good_arr": ["hdjonbiyfs62ie"], "is_bookmarked": false, "my_favorite": false, "t": 1446634867781, "children": [{"uid": "hdjonbiyfs62ie", "no_answer": 0, "created": "2015-03-13T03:27:06Z", "id": "i770wun5n6r3nh", "updated": "2015-03-13T03:27:06Z", "subject": "<p>北大有几个同学在网上给了一个比较全面的中文xv6文档。是很好的参考。</p>\n<p></p>\n<p><a href=\"https://www.gitbook.com/book/th0ar/xv6-chinese/details\">https://www.gitbook.com/book/th0ar/xv6-chinese/details</a></p>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 5, "bucket_name": "Last week", "no_upvotes": 0, "children": [], "type": "followup"}], "type": "note", "unique_views": 71, "created": "2015-03-13T02:18:15Z", "id": "i76ygbraiba3nx", "tags": ["big_proj", "instructor-note"], "nr": 92, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {}, "folders": ["big_proj"], "bucket_order": 2, "change_log": [{"uid": "hcrrjuyequh4bt", "when": "2015-03-13T02:18:15Z", "data": "i76ygbrct93ny", "anon": "no", "type": "create"}, {"uid": "hdjonbiyfs62ie", "when": "2015-03-13T03:27:06Z", "to": "i76ygbraiba3nx", "anon": "no", "type": "followup"}, {"uid": "i76zk4ijtWy", "when": "2015-03-13T07:28:10Z", "data": "i779ivri8s23lv", "anon": "no", "type": "update"}, {"uid": "i76zykkduDo", "when": "2015-03-13T11:33:46Z", "data": "i77iaq19el3x8", "anon": "no", "type": "update"}, {"uid": "i76zykkduDo", "when": "2015-03-13T11:34:22Z", "data": "i77ibhayn1t2t9", "anon": "no", "type": "update"}, {"uid": "i76zykkduDo", "when": "2015-03-13T13:12:27Z", "data": "i77ltmbtvj35r9", "anon": "no", "type": "update"}, {"uid": "i76zykkduDo", "when": "2015-03-17T05:18:24Z", "data": "i7cunebk9r26ol", "anon": "no", "type": "update"}], "bucket_name": "Today", "request_instructor_me": false, "no_answer_followup": 0, "num_favorites": 4, "tag_good": [{"class_sections": ["课程设计_i5j09fnsl7k5x0"], "name": "Yong XIANG", "id": "hdjonbiyfs62ie", "role": "instructor", "facebook_id": null, "photo": null, "admin": true, "us": false}]}}