{"aid": "jgxah8wdw9y37j", "result": {"status": "active", "unique_views": 10, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2018-05-07T19:59:32Z", "data": "jgwo6m1fueq2fa", "uid": "je2ib5nk89v6ca"}, {"type": "update", "anon": "no", "when": "2018-05-07T20:00:05Z", "data": "jgwo7bhvtoq2zq", "uid": "je2ib5nk89v6ca"}, {"type": "update", "anon": "no", "when": "2018-05-08T02:51:51Z", "data": "jgx2wvelynn3f0", "uid": "hdjonbiyfs62ie"}, {"uid": "hdjonbiyfs62ie", "type": "i_answer", "when": "2018-05-08T02:57:18Z", "to": "jgwo6m1dkwq2f9", "anon": "no", "data": "jgx33vr4ve2g8"}], "upvote_ids": [], "id": "jgwo6m1dkwq2f9", "bookmarked": 2, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2018-05-08T02:57:18Z", "type": "i_answer", "tag_endorse_arr": [], "id": "jgx33vr05a82g7", "bucket_name": "Today", "config": {}, "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "children": [], "history": [{"content": "<p>通过分析do_wait()函数和do_exit()函数的执行流程&#xff0c;可以很好地说明进程正常退出、孤儿进程和僵尸进程的关系。李凯文同学的分析和测试程序很好地展现这一点。</p>", "anon": "no", "created": "2018-05-08T02:57:18Z", "uid": "hdjonbiyfs62ie", "subject": ""}]}], "nr": 1218, "bucket_order": 2, "type": "question", "folders": ["lecture16", "2018"], "no_answer_followup": 0, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "tags": ["2018", "lecture16", "student"], "created": "2018-05-07T19:59:32Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1525760619853, "tag_good": [{"name": "Yong XIANG", "admin": true, "photo": null, "endorser": {}, "us": false, "email": "xyong@tsinghua.edu.cn", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0", "os2018spring_i5j09fnsl7k5x0"], "role": "instructor", "admin_permission": 10, "facebook_id": null, "id": "hdjonbiyfs62ie", "photo_url": null}], "tag_good_arr": ["hdjonbiyfs62ie"], "history": [{"content": "<p>上次课上向老师让我看一看父进程不进行do_wait也不退出时会发生什么问题&#xff0c;当时课上讨论给出的思路是让父进程不断fork&#xff0c;而不退出&#xff0c;不wait()&#xff0c;子进程创建之后直接退出。</p>\n<p></p>\n<p>请老师同学指正。</p>\n<p></p>\n<p>下面首先在Ubuntu16.04上给出了实现&#xff1a;</p>\n<pre>#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define DATASIZE 10240000 // around 1GB per process\n\nint main(int argc, char** argv) {\n    int number = -1;\n    if (argc &gt; 1) {\n        number = atoi(argv[1]);\n    }\n    \n    double *data = (double *)malloc(sizeof(double) * DATASIZE);\n    for (int i = 0; i &lt; number || number &lt; 0; &#43;&#43;i) {\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\t    exit(0);\n\t}\n\tif (pid &gt; 0) {\n\t    printf(&#34;Child pid %d is created.\\n&#34;, pid);\n\t}\n\telse {\n\t    printf(&#34;Fork error, returned pid is %d.\\n&#34;, pid);\n\t}\n    }\n    while(1);\n    return 0;\n}</pre>\n<p>其中设置number为最大的子进程数&#xff0c;可以通过命令行参数输入&#xff0c;负值时没有最大子进程数限制&#xff0c;</p>\n<p>当父进程pid返回值为负值时&#xff0c;进程槽已满&#xff0c;fork失败&#xff0c;但这里没有退出&#xff0c;而是继续尝试fork。</p>\n<p>开辟堆空间是想看子进程退出后是否会仍然占用这些空间的。</p>\n<p></p>\n<p>首先是一个简单的测试&#xff0c;程序名为fork_without_wait&#xff0c;则./fork_without_wait 10</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/je2ib5nk89v6ca/jgwmv7b92ok5/Selection_025.png\" alt=\"\" /></p>\n<p>然后可以使用ps命令来查看这些进程的情况&#xff08;ps aux | grep fork_without&#xff09;&#xff1a;</p>\n<p>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</p>\n<p>------------------------------------------------------------------------------------------------------------------</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/je2ib5nk89v6ca/jgwmyj9cddpb/Selection_026.png\" alt=\"\" /></p>\n<p>由此可见&#xff0c;子进程退出时已经清理了用户堆栈数据&#xff0c;所以内存和虚存的占用量均为0&#xff0c;进程状态均为ZOMBIE&#xff08;Z&#43;&#xff09;&#xff0c;所以其主要占用的实际上是进程槽、进程列表、内核栈等在do_wait()中清理掉的部分。</p>\n<p></p>\n<p>在进程数比较多&#xff0c;特别是在使用number为负值即子进程数没有上限时&#xff0c;就会出现无法创建新进程&#xff0c;一有其他进程退出就立刻被fork出的新进程占用空间&#xff0c;导致系统卡顿无响应&#xff0c;但如果没有使用&amp;后台运行的话&#xff0c;还可以通过Ctrl&#43;C终止所有的父子进程&#xff0c;如果是后台运行&#xff0c;基本上除了重启系统就没啥解决方法了。</p>\n<p></p>\n<p>以下是./fork_without_wait -1</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/je2ib5nk89v6ca/jgwn819g1hw5/Selection_027.png\" alt=\"\" /></p>\n<p>两次Ctrl&#43;C&#xff0c;第一次出现fork failed&#xff0c;第二次才终止该程序</p>\n<p></p>\n<p>而在ucore中&#xff0c;去掉了动态分配&#xff0c;使用lab8的载入程序的方式显示情况与上面相同&#xff0c;终止可以直接关闭qemu。</p>\n<p>由于不太清楚需要用gdb追踪什么&#xff0c;所以没有使用make gdb&#xff08;同时也的确是时间有点紧了&#xff0c;因为周一上午坐飞机赶到成都出差&#xff0c;干活一直到晚上才回到宾馆&#xff0c;而且周二上午还有工作安排&#xff09;。</p>\n<p></p>\n<p>通过查看do_wait()的代码&#xff0c;也可以看到&#xff0c;在找到需要清理的子进程后&#xff0c;做的处理如下&#xff1a;</p>\n<pre>found:\n    if (proc == idleproc || proc == initproc) {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL) {\n        *code_store = proc-&gt;exit_code; // 设置返回值\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);  // 将该进程从hash链表中移除\n        remove_links(proc); // 将该进程从进程链接中移除\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);  // 释放内核栈\n    kfree(proc);       // 释放该进程的struct_proc\n    return 0;</pre>\n<p>没有do_wait()实际上就是这些没有清理&#xff0c;其他的都在do_exit()中清理了</p>\n<pre>// do_exit - called by sys_exit\n//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process\n//   2. set process&#39; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.\n//   3. call scheduler to switch to other process\nint\ndo_exit(int error_code) {\n    if (current == idleproc) {\n        panic(&#34;idleproc exit.\\n&#34;);\n    }\n    if (current == initproc) {\n        panic(&#34;initproc exit.\\n&#34;);\n    }\n    // 清理内存管理数据结构mm\n    struct mm_struct *mm = current-&gt;mm;\n    if (mm != NULL) {\n        lcr3(boot_cr3);\n        if (mm_count_dec(mm) == 0) {\n            exit_mmap(mm);\n            put_pgdir(mm);\n            mm_destroy(mm);\n        }\n        current-&gt;mm = NULL;\n    }\n    put_files(current); //for LAB8\n    current-&gt;state = PROC_ZOMBIE;   // 修改进程状态\n    current-&gt;exit_code = error_code;  // 设置返回值\n    \n    bool intr_flag;\n    struct proc_struct *proc;\n    local_intr_save(intr_flag);\n    {\n        proc = current-&gt;parent; \n        if (proc-&gt;wait_state == WT_CHILD) {\n            wakeup_proc(proc);          // 唤醒父进程\n        }\n        while (current-&gt;cptr != NULL) {   // 该进程有子进程&#xff0c;就将子进程过继给initproc\n            proc = current-&gt;cptr;\n            current-&gt;cptr = proc-&gt;optr;\n    \n            proc-&gt;yptr = NULL;\n            if ((proc-&gt;optr = initproc-&gt;cptr) != NULL) {\n                initproc-&gt;cptr-&gt;yptr = proc;\n            }\n            proc-&gt;parent = initproc;\n            initproc-&gt;cptr = proc;\n            if (proc-&gt;state == PROC_ZOMBIE) {  // 如果过继的子进程已经处于ZOMBIE状态&#xff0c;则唤醒initproc进行清理\n                if (initproc-&gt;wait_state == WT_CHILD) {\n                    wakeup_proc(initproc);\n                }\n            }\n        }\n    }\n    local_intr_restore(intr_flag);\n    \n    schedule();\n    panic(&#34;do_exit will not return!! %d.\\n&#34;, current-&gt;pid); // 正常的do_exit不会运行该指令</pre>\n<p>由此可见&#xff0c;do_exit()清理用户进程的页表等内存管理数据结构&#xff0c;修改进程状态&#xff0c;唤醒父进程&#xff08;或过继到的initproc&#xff09;进行清理&#xff0c;最后让出CPU使用权&#xff0c;而do_wait()则是在找到退出的子进程后将其内核栈释放&#xff0c;移出hash链表和进程链表&#xff0c;设置返回值和释放进程控制块。</p>", "anon": "no", "created": "2018-05-08T02:51:51Z", "uid": "hdjonbiyfs62ie", "subject": "父进程不进行do_wait也不退出时的问题"}, {"content": "<p>上次课上向老师让我看一看父进程不进行do_wait也不退出时会发生什么问题&#xff0c;当时课上讨论给出的思路是让父进程不断fork&#xff0c;而不退出&#xff0c;不wait()&#xff0c;子进程创建之后直接退出。</p>\n<p></p>\n<p>请老师同学指正。</p>\n<p></p>\n<p>下面首先在Ubuntu16.04上给出了实现&#xff1a;</p>\n<pre>#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define DATASIZE 10240000 // around 1GB per process\n\nint main(int argc, char** argv) {\n    int number = -1;\n    if (argc &gt; 1) {\n        number = atoi(argv[1]);\n    }\n    \n    double *data = (double *)malloc(sizeof(double) * DATASIZE);\n    for (int i = 0; i &lt; number || number &lt; 0; &#43;&#43;i) {\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\t    exit(0);\n\t}\n\tif (pid &gt; 0) {\n\t    printf(&#34;Child pid %d is created.\\n&#34;, pid);\n\t}\n\telse {\n\t    printf(&#34;Fork error, returned pid is %d.\\n&#34;, pid);\n\t}\n    }\n    while(1);\n    return 0;\n}</pre>\n<p>其中设置number为最大的子进程数&#xff0c;可以通过命令行参数输入&#xff0c;负值时没有最大子进程数限制&#xff0c;</p>\n<p>当父进程pid返回值为负值时&#xff0c;进程槽已满&#xff0c;fork失败&#xff0c;但这里没有退出&#xff0c;而是继续尝试fork。</p>\n<p>开辟堆空间是想看子进程退出后是否会仍然占用这些空间的。</p>\n<p></p>\n<p>首先是一个简单的测试&#xff0c;程序名为fork_without_wait&#xff0c;则./fork_without_wait 10</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/je2ib5nk89v6ca/jgwmv7b92ok5/Selection_025.png\" alt=\"\" /></p>\n<p>然后可以使用ps命令来查看这些进程的情况&#xff08;ps aux | grep fork_without&#xff09;&#xff1a;</p>\n<p>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</p>\n<p>------------------------------------------------------------------------------------------------------------------</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/je2ib5nk89v6ca/jgwmyj9cddpb/Selection_026.png\" alt=\"\" /></p>\n<p>由此可见&#xff0c;子进程退出时已经清理了用户堆栈数据&#xff0c;所以内存和虚存的占用量均为0&#xff0c;进程状态均为ZOMBIE&#xff08;Z&#43;&#xff09;&#xff0c;所以其主要占用的实际上是进程槽、进程列表、内核栈等在do_wait()中清理掉的部分。</p>\n<p></p>\n<p>在进程数比较多&#xff0c;特别是在使用number为负值即子进程数没有上限时&#xff0c;就会出现无法创建新进程&#xff0c;一有其他进程退出就立刻被fork出的新进程占用空间&#xff0c;导致系统卡顿无响应&#xff0c;但如果没有使用&amp;后台运行的话&#xff0c;还可以通过Ctrl&#43;C终止所有的父子进程&#xff0c;如果是后台运行&#xff0c;基本上除了重启系统就没啥解决方法了。</p>\n<p></p>\n<p>以下是./fork_without_wait -1</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/je2ib5nk89v6ca/jgwn819g1hw5/Selection_027.png\" alt=\"\" /></p>\n<p>两次Ctrl&#43;C&#xff0c;第一次出现fork failed&#xff0c;第二次才终止该程序</p>\n<p></p>\n<p>而在ucore中&#xff0c;去掉了动态分配&#xff0c;使用lab8的载入程序的方式显示情况与上面相同&#xff0c;终止可以直接关闭qemu。</p>\n<p>由于不太清楚需要用gdb追踪什么&#xff0c;所以没有使用make gdb&#xff08;同时也的确是时间有点紧了&#xff0c;因为周一上午坐飞机赶到成都出差&#xff0c;干活一直到晚上才回到宾馆&#xff0c;而且周二上午还有工作安排&#xff09;。</p>\n<p></p>\n<p>通过查看do_wait()的代码&#xff0c;也可以看到&#xff0c;在找到需要清理的子进程后&#xff0c;做的处理如下&#xff1a;</p>\n<pre>found:\n    if (proc == idleproc || proc == initproc) {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL) {\n        *code_store = proc-&gt;exit_code; // 设置返回值\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);  // 将该进程从hash链表中移除\n        remove_links(proc); // 将该进程从进程链接中移除\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);  // 释放内核栈\n    kfree(proc);       // 释放该进程的struct_proc\n    return 0;</pre>\n<p>没有do_wait()实际上就是这些没有清理&#xff0c;其他的都在do_exit()中清理了</p>\n<pre>// do_exit - called by sys_exit\n//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process\n//   2. set process&#39; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.\n//   3. call scheduler to switch to other process\nint\ndo_exit(int error_code) {\n    if (current == idleproc) {\n        panic(&#34;idleproc exit.\\n&#34;);\n    }\n    if (current == initproc) {\n        panic(&#34;initproc exit.\\n&#34;);\n    }\n    // 清理内存管理数据结构mm\n    struct mm_struct *mm = current-&gt;mm;\n    if (mm != NULL) {\n        lcr3(boot_cr3);\n        if (mm_count_dec(mm) == 0) {\n            exit_mmap(mm);\n            put_pgdir(mm);\n            mm_destroy(mm);\n        }\n        current-&gt;mm = NULL;\n    }\n    put_files(current); //for LAB8\n    current-&gt;state = PROC_ZOMBIE;   // 修改进程状态\n    current-&gt;exit_code = error_code;  // 设置返回值\n    \n    bool intr_flag;\n    struct proc_struct *proc;\n    local_intr_save(intr_flag);\n    {\n        proc = current-&gt;parent; \n        if (proc-&gt;wait_state == WT_CHILD) {\n            wakeup_proc(proc);          // 唤醒父进程\n        }\n        while (current-&gt;cptr != NULL) {   // 该进程有子进程&#xff0c;就将子进程过继给initproc\n            proc = current-&gt;cptr;\n            current-&gt;cptr = proc-&gt;optr;\n    \n            proc-&gt;yptr = NULL;\n            if ((proc-&gt;optr = initproc-&gt;cptr) != NULL) {\n                initproc-&gt;cptr-&gt;yptr = proc;\n            }\n            proc-&gt;parent = initproc;\n            initproc-&gt;cptr = proc;\n            if (proc-&gt;state == PROC_ZOMBIE) {  // 如果过继的子进程已经处于ZOMBIE状态&#xff0c;则唤醒initproc进行清理\n                if (initproc-&gt;wait_state == WT_CHILD) {\n                    wakeup_proc(initproc);\n                }\n            }\n        }\n    }\n    local_intr_restore(intr_flag);\n    \n    schedule();\n    panic(&#34;do_exit will not return!! %d.\\n&#34;, current-&gt;pid); // 正常的do_exit不会运行该指令</pre>\n<p>由此可见&#xff0c;do_exit()清理用户进程的页表等内存管理数据结构&#xff0c;修改进程状态&#xff0c;唤醒父进程&#xff08;或过继到的initproc&#xff09;进行清理&#xff0c;最后让出CPU使用权&#xff0c;而do_wait()则是在找到退出的子进程后将其内核栈释放&#xff0c;移出hash链表和进程链表&#xff0c;设置返回值和释放进程控制块。</p>", "anon": "no", "created": "2018-05-07T20:00:05Z", "uid": "je2ib5nk89v6ca", "subject": "父进程不进行do_wait也不退出时的问题"}, {"content": "<p>上次课上向老师让我看一看父进程不进行do_wait也不退出时会发生什么问题&#xff0c;当时课上讨论给出的思路是让父进程不断fork&#xff0c;而不退出&#xff0c;不wait()&#xff0c;子进程创建之后直接退出。</p>\n<p></p>\n<p>请老师同学指正。</p>\n<p></p>\n<p>下面首先在Ubuntu16.04上给出了实现&#xff1a;</p>\n<pre>#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n#define DATASIZE 10240000 // around 1GB per process\n\nint main(int argc, char** argv) {\n    int number = -1;\n    if (argc &gt; 1) {\n        number = atoi(argv[1]);\n    }\n    \n    double *data = (double *)malloc(sizeof(double) * DATASIZE);\n    for (int i = 0; i &lt; number || number &lt; 0; &#43;&#43;i) {\n\tpid_t pid = fork();\n\tif (pid == 0) {\n\t    exit(0);\n\t}\n\tif (pid &gt; 0) {\n\t    printf(&#34;Child pid %d is created.\\n&#34;, pid);\n\t}\n\telse {\n\t    printf(&#34;Fork error, returned pid is %d.\\n&#34;, pid);\n\t}\n    }\n    while(1);\n    return 0;\n}</pre>\n<p>其中设置number为最大的子进程数&#xff0c;可以通过命令行参数输入&#xff0c;负值时没有最大子进程数限制&#xff0c;</p>\n<p>当父进程pid返回值为负值时&#xff0c;进程槽已满&#xff0c;fork失败&#xff0c;但这里没有退出&#xff0c;而是继续尝试fork。</p>\n<p>开辟堆空间是想看子进程退出后是否会仍然占用这些空间的。</p>\n<p></p>\n<p>首先是一个简单的测试&#xff0c;程序名为fork_without_wait&#xff0c;则./fork_without_wait 10</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/je2ib5nk89v6ca/jgwmv7b92ok5/Selection_025.png\" alt=\"\" /></p>\n<p>然后可以使用ps命令来查看这些进程的情况&#xff08;ps aux | grep fork_without&#xff09;&#xff1a;</p>\n<p>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</p>\n<p>------------------------------------------------------------------------------------------------------------------</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/je2ib5nk89v6ca/jgwmyj9cddpb/Selection_026.png\" alt=\"\" /></p>\n<p>由此可见&#xff0c;子进程退出时已经清理了用户堆栈数据&#xff0c;所以内存和虚存的占用量均为0&#xff0c;进程状态均为ZOMBIE&#xff08;Z&#43;&#xff09;&#xff0c;所以其主要占用的实际上是进程槽、进程列表、内核栈等在do_wait()中清理掉的部分。</p>\n<p></p>\n<p>在进程数比较多&#xff0c;特别是在使用number为负值即子进程数没有上限时&#xff0c;就会出现无法创建新进程&#xff0c;一有其他进程退出就立刻被fork出的新进程占用空间&#xff0c;导致系统卡顿无响应&#xff0c;但如果没有使用&amp;后台运行的话&#xff0c;还可以通过Ctrl&#43;C终止所有的父子进程&#xff0c;如果是后台运行&#xff0c;基本上除了重启系统就没啥解决方法了。</p>\n<p></p>\n<p>以下是./fork_without_wait -1</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/je2ib5nk89v6ca/jgwn819g1hw5/Selection_027.png\" alt=\"\" /></p>\n<p>两次Ctrl&#43;C&#xff0c;第一次出现fork failed&#xff0c;第二次才终止该程序</p>\n<p></p>\n<p>而在ucore中&#xff0c;去掉了动态分配&#xff0c;使用lab8的载入程序的方式显示情况与上面相同&#xff0c;终止可以直接关闭qemu。</p>\n<p>由于不太清楚需要用gdb追踪什么&#xff0c;所以没有使用make gdb&#xff08;同时也的确是时间有点紧了&#xff0c;因为周一上午坐飞机赶到成都出差&#xff0c;干活一直到晚上才回到宾馆&#xff0c;而且周二上午还有工作安排&#xff09;。</p>\n<p></p>\n<p>通过查看do_wait()的代码&#xff0c;也可以看到&#xff0c;在找到需要清理的子进程后&#xff0c;做的处理如下&#xff1a;</p>\n<pre>found:\n    if (proc == idleproc || proc == initproc) {\n        panic(&#34;wait idleproc or initproc.\\n&#34;);\n    }\n    if (code_store != NULL) {\n        *code_store = proc-&gt;exit_code; // 设置返回值\n    }\n    local_intr_save(intr_flag);\n    {\n        unhash_proc(proc);  // 将该进程从hash链表中移除\n        remove_links(proc); // 将该进程从进程链接中移除\n    }\n    local_intr_restore(intr_flag);\n    put_kstack(proc);  // 释放内核栈\n    kfree(proc);       // 释放该进程的struct_proc\n    return 0;</pre>\n<p>没有do_wait()实际上就是这些没有清理&#xff0c;其他的都在do_exit()中清理了</p>\n<pre>// do_exit - called by sys_exit\n//   1. call exit_mmap &amp; put_pgdir &amp; mm_destroy to free the almost all memory space of process\n//   2. set process&#39; state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.\n//   3. call scheduler to switch to other process\nint\ndo_exit(int error_code) {\n    if (current == idleproc) {\n        panic(&#34;idleproc exit.\\n&#34;);\n    }\n    if (current == initproc) {\n        panic(&#34;initproc exit.\\n&#34;);\n    }\n    // 清理内存管理数据结构mm\n    struct mm_struct *mm = current-&gt;mm;\n    if (mm != NULL) {\n        lcr3(boot_cr3);\n        if (mm_count_dec(mm) == 0) {\n            exit_mmap(mm);\n            put_pgdir(mm);\n            mm_destroy(mm);\n        }\n        current-&gt;mm = NULL;\n    }\n    put_files(current); //for LAB8\n    current-&gt;state = PROC_ZOMBIE;   // 修改进程状态\n    current-&gt;exit_code = error_code;  // 设置返回值\n    \n    bool intr_flag;\n    struct proc_struct *proc;\n    local_intr_save(intr_flag);\n    {\n        proc = current-&gt;parent; \n        if (proc-&gt;wait_state == WT_CHILD) {\n            wakeup_proc(proc);          // 唤醒父进程\n        }\n        while (current-&gt;cptr != NULL) {   // 该进程有子进程&#xff0c;就将子进程过继给initproc\n            proc = current-&gt;cptr;\n            current-&gt;cptr = proc-&gt;optr;\n    \n            proc-&gt;yptr = NULL;\n            if ((proc-&gt;optr = initproc-&gt;cptr) != NULL) {\n                initproc-&gt;cptr-&gt;yptr = proc;\n            }\n            proc-&gt;parent = initproc;\n            initproc-&gt;cptr = proc;\n            if (proc-&gt;state == PROC_ZOMBIE) {  // 如果过继的子进程已经处于ZOMBIE状态&#xff0c;则唤醒initproc进行清理\n                if (initproc-&gt;wait_state == WT_CHILD) {\n                    wakeup_proc(initproc);\n                }\n            }\n        }\n    }\n    local_intr_restore(intr_flag);\n    \n    schedule();\n    panic(&#34;do_exit will not return!! %d.\\n&#34;, current-&gt;pid); // 正常的do_exit不会运行该指令</pre>\n<p>由此可见&#xff0c;do_exit()清理用户进程的页表等内存管理数据结构&#xff0c;修改进程状态&#xff0c;唤醒父进程&#xff08;或过继到的initproc&#xff09;进行清理&#xff0c;最后让出CPU使用权&#xff0c;而do_wait()则是在找到退出的子进程后将其内核栈释放&#xff0c;移出hash链表和进程链表&#xff0c;设置返回值和释放进程控制块。</p>", "anon": "no", "created": "2018-05-07T19:59:32Z", "uid": "je2ib5nk89v6ca", "subject": "父进程不进行do_wait也不退出时的问题"}]}, "error": null}