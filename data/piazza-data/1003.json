{"aid": "j03zcbahzcf3rx", "result": {"status": "active", "unique_views": 16, "request_instructor_me": false, "change_log": [{"type": "create", "anon": "no", "when": "2017-03-10T08:12:02Z", "data": "j03jnfib82h10", "uid": "ie7xy5f0l9b1qi"}, {"type": "update", "anon": "no", "when": "2017-03-10T08:12:47Z", "data": "j03joe1rf7m7j8", "uid": "ie7xy5f0l9b1qi"}, {"type": "update", "anon": "no", "when": "2017-03-10T08:16:43Z", "data": "j03jtggksw35f9", "uid": "ie7xy5f0l9b1qi"}], "upvote_ids": [], "id": "j03jnfi9ertz", "bookmarked": 4, "no_answer": 1, "i_edits": [], "is_bookmarked": false, "children": [], "nr": 1003, "bucket_order": 2, "type": "question", "folders": ["lab1"], "no_answer_followup": 0, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "tags": ["lab1", "student", "unanswered"], "created": "2017-03-10T08:12:02Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1489159877417, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>老师&#xff0c;助教&#xff0c;同学们好&#xff0c;我对Lab1的Challenge有一些不懂的地方:</p>\n<p>在Lab1的Challenge2中要求:</p>\n<p>用键盘实现用户模式内核模式切换。具体目标是&#xff1a;“键盘输入3时切换到用户模式&#xff0c;键盘输入0时切换到内核模式”。</p>\n<p>答案(github branch lab1-X)的实现为:<br />&#96;&#96;&#96;<br />     case IRQ_OFFSET &#43; IRQ_KBD:<br />         c = cons_getc();<br />         cprintf(&#34;kbd [%03d] %c\\n&#34;, c, c);<br /> <br />         /*********************/<br />         //Hardware Interrupt is different with software trap, so no need use temp stack<br />         if ( c ==&#39;3&#39;){<br />             tf-&gt;tf_eflags |= 0x3000;<br />             if (tf-&gt;tf_cs != USER_CS) {<br /> <br />                 tf-&gt;tf_cs = USER_CS;<br />                 tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br />                 tf-&gt;tf_eflags |= FL_IOPL_MASK;<br />         }<br />         print_trapframe(tf);</p>\n<p>    }<br /> ......<br />&#96;&#96;&#96;</p>\n<p>按照我的理解,在内核态时触发键盘中断&#xff0c;此时是从内核态转换为内核态&#xff0c;故栈中不会先压入ss和esp。此时通过修改栈帧再iret的方法进行状态切换&#xff0c;<br />直接修改tf-&gt;tf_ss为USER_DS&#xff0c;会不会有越过当前栈帧的问题&#xff1f;因为此时栈帧中并没有ss这一项。答案中强调了硬中断和软中断的不同所以处理方式不同&#xff0c;这个不同是什么呢&#xff1f;</p>\n<p></p>\n<p>另外&#xff0c;我猜想在Challenge1的答案中可能会有点小问题:<br />(1)在内核态转换到用户态时:<br />&#96;&#96;&#96;<br />     case T_SWITCH_TOU:<br />         tf-&gt;tf_eflags |= 0x3000;<br />         if (tf-&gt;tf_cs != USER_CS) {<br />             switchk2u = *tf;<br />             switchk2u.tf_cs = USER_CS;<br />             switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;<br />             switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;<br /> <br />             // set eflags, make sure ucore can use io under user mode.<br />             // if CPL &gt; IOPL, then cpu will generate a general protection.<br />             switchk2u.tf_eflags |= FL_IOPL_MASK;<br /> <br />             // set temporary stack<br />             // then iret will jump to the right stack<br />             *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u;<br />&#96;&#96;&#96;</p>\n<p><br />switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;我觉得这里不应该加上-8&#xff0c;在init.c中</p>\n<p></p>\n<p>&#96;&#96;&#96;<br />static void lab1_switch_to_user(void) {<br /> //LAB1 CHALLENGE 1 : TODO<br />     asm volatile (<br />         &#34;sub $0x8, %%esp \\n&#34;<br />         &#34;int %0 \\n&#34;<br />         &#34;movl %%ebp, %%esp&#34; //can cancel</p>\n<p>        : <br />         : &#34;i&#34;(T_SWITCH_TOU)<br />     );<br />}<br />&#96;&#96;&#96;</p>\n<p><br />已经提前把esp减了8再调用软中断&#xff0c;此时再到上面的case中处理时&#xff0c;新建栈帧的esp若要指向上一个栈帧的结尾&#xff0c;值应为(uint32_t)tf &#43; sizeof(struct trapframe)。<br />经测试&#xff0c;若去掉这个-8&#xff0c;可在lab1_switch_to_user中去掉&#34;movl %%ebp, %%esp&#34;&#xff0c;此时仍正常运行&#xff0c;因为iret时esp已修正为正确值。</p>\n<p></p>\n<p>(2)在用户态转化到内核态时:<br />&#96;&#96;&#96;<br />     case T_SWITCH_TOK:<br />         if (tf-&gt;tf_cs != KERNEL_CS) {<br />             tf-&gt;tf_cs = KERNEL_CS;<br />             tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;<br />             tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;<br />             switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));<br />             memmove(switchu2k, tf, sizeof(struct trapframe) - 8);<br />             *((uint32_t *)tf - 1) = (uint32_t)switchu2k;<br />         }<br />     break;<br />&#96;&#96;&#96;</p>\n<p>if{}中的后三句似乎没有存在的必要诶&#xff0c;直接改当前tf好像就可以了?</p>\n<p>我的理解可能有些浅薄&#xff0c;希望老师同学一起讨论一下&#xff0c;谢谢&#xff01;</p>\n<p></p>", "anon": "no", "created": "2017-03-10T08:16:43Z", "uid": "ie7xy5f0l9b1qi", "subject": "关于Lab1 Challenge的几个小问题"}, {"content": "<p>老师&#xff0c;助教&#xff0c;同学们好&#xff0c;我对Lab1的Challenge有一些不懂的地方:</p>\n<p>在Lab1的Challenge2中要求:</p>\n<p>用键盘实现用户模式内核模式切换。具体目标是&#xff1a;“键盘输入3时切换到用户模式&#xff0c;键盘输入0时切换到内核模式”。</p>\n<p>答案(github branch lab1-X)的实现为:<br />&#96;&#96;&#96;<br /> case IRQ_OFFSET &#43; IRQ_KBD:<br /> c = cons_getc();<br /> cprintf(&#34;kbd [%03d] %c\\n&#34;, c, c);<br /> <br /> /*********************/<br /> //Hardware Interrupt is different with software trap, so no need use temp stack<br /> if ( c ==&#39;3&#39;){<br /> tf-&gt;tf_eflags |= 0x3000;<br /> if (tf-&gt;tf_cs != USER_CS) {<br /> <br /> tf-&gt;tf_cs = USER_CS;<br /> tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br /> tf-&gt;tf_eflags |= FL_IOPL_MASK;<br /> }<br /> print_trapframe(tf);</p>\n<p>}<br /> ......<br />&#96;&#96;&#96;</p>\n<p>按照我的理解,在内核态时触发键盘中断&#xff0c;此时是从内核态转换为内核态&#xff0c;故栈中不会先压入ss和esp。此时通过修改栈帧再iret的方法进行状态切换&#xff0c;<br />直接修改tf-&gt;tf_ss为USER_DS&#xff0c;会不会有越过当前栈帧的问题&#xff1f;因为此时栈帧中并没有ss这一项。答案中强调了硬中断和软中断的不同所以处理方式不同&#xff0c;<br />这个不同是什么呢&#xff1f;</p>\n<p>另外&#xff0c;我猜想在Challenge1的答案中可能会有点小问题:<br />(1)在内核态转换到用户态时:<br />&#96;&#96;&#96;<br /> case T_SWITCH_TOU:<br /> tf-&gt;tf_eflags |= 0x3000;<br /> if (tf-&gt;tf_cs != USER_CS) {<br /> switchk2u = *tf;<br /> switchk2u.tf_cs = USER_CS;<br /> switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;<br /> switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;<br /> <br /> // set eflags, make sure ucore can use io under user mode.<br /> // if CPL &gt; IOPL, then cpu will generate a general protection.<br /> switchk2u.tf_eflags |= FL_IOPL_MASK;<br /> <br /> // set temporary stack<br /> // then iret will jump to the right stack<br /> *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u;<br />&#96;&#96;&#96;<br />switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;我觉得这里不应该加上-8&#xff0c;在init.c中<br />&#96;&#96;&#96;<br />static void<br />lab1_switch_to_user(void) {<br /> //LAB1 CHALLENGE 1 : TODO<br /> asm volatile (<br /> &#34;sub $0x8, %%esp \\n&#34;<br /> &#34;int %0 \\n&#34;<br /> &#34;movl %%ebp, %%esp&#34; //can cancel<br /> : <br /> : &#34;i&#34;(T_SWITCH_TOU)<br /> );<br />}<br />&#96;&#96;&#96;<br />已经提前把esp减了8再调用软中断&#xff0c;此时再到上面的case中处理时&#xff0c;新建栈帧的esp若要指向上一个栈帧的结尾&#xff0c;值应为(uint32_t)tf &#43; sizeof(struct trapframe)。<br />经测试&#xff0c;若去掉这个-8&#xff0c;可在lab1_switch_to_user中去掉&#34;movl %%ebp, %%esp&#34;&#xff0c;此时仍正常运行&#xff0c;因为iret时esp已修正为正确值。</p>\n<p>(2)在用户态转化到内核态时:<br />&#96;&#96;&#96;<br /> case T_SWITCH_TOK:<br /> if (tf-&gt;tf_cs != KERNEL_CS) {<br /> tf-&gt;tf_cs = KERNEL_CS;<br /> tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;<br /> tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;<br /> switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));<br /> memmove(switchu2k, tf, sizeof(struct trapframe) - 8);<br /> *((uint32_t *)tf - 1) = (uint32_t)switchu2k;<br /> }<br /> break;<br />&#96;&#96;&#96;</p>\n<p>if{}中的后三句似乎没有存在的必要诶&#xff0c;直接改当前tf好像就可以了?</p>\n<p>我的理解可能有些浅薄&#xff0c;希望老师同学一起讨论一下&#xff0c;谢谢&#xff01;</p>\n<p></p>", "anon": "no", "created": "2017-03-10T08:12:47Z", "uid": "ie7xy5f0l9b1qi", "subject": "关于Lab1 Challenge的几个小问题"}, {"content": "<p>老师&#xff0c;助教你们好&#xff0c;我对Lab1的Challenge有一些不懂的地方:</p>\n<p>在Lab1的Challenge2中要求:</p>\n<p>用键盘实现用户模式内核模式切换。具体目标是&#xff1a;“键盘输入3时切换到用户模式&#xff0c;键盘输入0时切换到内核模式”。</p>\n<p>答案(github branch lab1-X)的实现为:<br />&#96;&#96;&#96;<br /> case IRQ_OFFSET &#43; IRQ_KBD:<br /> c = cons_getc();<br /> cprintf(&#34;kbd [%03d] %c\\n&#34;, c, c);<br /> <br /> /*********************/<br /> //Hardware Interrupt is different with software trap, so no need use temp stack<br /> if ( c ==&#39;3&#39;){<br /> tf-&gt;tf_eflags |= 0x3000;<br /> if (tf-&gt;tf_cs != USER_CS) {<br /> <br /> tf-&gt;tf_cs = USER_CS;<br /> tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;<br /> tf-&gt;tf_eflags |= FL_IOPL_MASK;<br /> }<br /> print_trapframe(tf);</p>\n<p>}<br /> ......<br />&#96;&#96;&#96;</p>\n<p>按照我的理解,在内核态时触发键盘中断&#xff0c;此时是从内核态转换为内核态&#xff0c;故栈中不会先压入ss和esp。此时通过修改栈帧再iret的方法进行状态切换&#xff0c;<br />直接修改tf-&gt;tf_ss为USER_DS&#xff0c;会不会有越过当前栈帧的问题&#xff1f;因为此时栈帧中并没有ss这一项。答案中强调了硬中断和软中断的不同所以处理方式不同&#xff0c;<br />这个不同是什么呢&#xff1f;</p>\n<p>另外&#xff0c;我猜想在Challenge1的答案中可能会有点小问题:<br />(1)在内核态转换到用户态时:<br />&#96;&#96;&#96;<br /> case T_SWITCH_TOU:<br /> tf-&gt;tf_eflags |= 0x3000;<br /> if (tf-&gt;tf_cs != USER_CS) {<br /> switchk2u = *tf;<br /> switchk2u.tf_cs = USER_CS;<br /> switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;<br /> switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;<br /> <br /> // set eflags, make sure ucore can use io under user mode.<br /> // if CPL &gt; IOPL, then cpu will generate a general protection.<br /> switchk2u.tf_eflags |= FL_IOPL_MASK;<br /> <br /> // set temporary stack<br /> // then iret will jump to the right stack<br /> *((uint32_t *)tf - 1) = (uint32_t)&amp;switchk2u;<br />&#96;&#96;&#96;<br />switchk2u.tf_esp = (uint32_t)tf &#43; sizeof(struct trapframe) - 8;我觉得这里不应该加上-8&#xff0c;在init.c中<br />&#96;&#96;&#96;<br />static void<br />lab1_switch_to_user(void) {<br /> //LAB1 CHALLENGE 1 : TODO<br /> asm volatile (<br /> &#34;sub $0x8, %%esp \\n&#34;<br /> &#34;int %0 \\n&#34;<br /> &#34;movl %%ebp, %%esp&#34; //can cancel<br /> : <br /> : &#34;i&#34;(T_SWITCH_TOU)<br /> );<br />}<br />&#96;&#96;&#96;<br />已经提前把esp减了8再调用软中断&#xff0c;此时再到上面的case中处理时&#xff0c;新建栈帧的esp若要指向上一个栈帧的结尾&#xff0c;值应为(uint32_t)tf &#43; sizeof(struct trapframe)。<br />经测试&#xff0c;若去掉这个-8&#xff0c;可在lab1_switch_to_user中去掉&#34;movl %%ebp, %%esp&#34;&#xff0c;此时仍正常运行&#xff0c;因为iret时esp已修正为正确值。</p>\n<p>(2)在用户态转化到内核态时:<br />&#96;&#96;&#96;<br /> case T_SWITCH_TOK:<br /> if (tf-&gt;tf_cs != KERNEL_CS) {<br /> tf-&gt;tf_cs = KERNEL_CS;<br /> tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;<br /> tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;<br /> switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));<br /> memmove(switchu2k, tf, sizeof(struct trapframe) - 8);<br /> *((uint32_t *)tf - 1) = (uint32_t)switchu2k;<br /> }<br /> break;<br />&#96;&#96;&#96;</p>\n<p>if{}中的后三句似乎没有存在的必要诶&#xff0c;直接改当前tf好像就可以了?</p>\n<p>我的理解可能有些浅薄&#xff0c;希望老师同学一起讨论一下&#xff0c;谢谢&#xff01;</p>\n<p></p>", "anon": "no", "created": "2017-03-10T08:12:02Z", "uid": "ie7xy5f0l9b1qi", "subject": "关于Lab1 Challenge的几个小问题"}]}, "error": null}