{"aid": "iln9s1fbj0j1sh", "result": {"folders": ["lab2"], "unique_views": 53, "request_instructor_me": false, "change_log": [{"data": "ibgajq81yqx1hp", "anon": "no", "when": "2015-06-28T09:45:34Z", "uid": "iaxb95cm1DB", "type": "create"}, {"uid": "i6uarbyshf06f8", "data": "ibge3q4uqu23xz", "when": "2015-06-28T11:25:06Z", "to": "ibgajq7zy2z1ho", "anon": "stud", "type": "s_answer"}, {"to": "ibgajq7zy2z1ho", "anon": "no", "when": "2016-03-04T12:31:53Z", "uid": "i242q8ug7vw40x", "type": "followup"}, {"to": "ibgajq7zy2z1ho", "anon": "no", "when": "2016-03-04T13:35:17Z", "uid": "i242q8ug7vw40x", "type": "feedback"}], "upvote_ids": [], "id": "ibgajq7zy2z1ho", "bookmarked": 5, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2015-06-28T11:25:06Z", "config": {}, "tag_endorse_arr": [], "children": [], "bucket_name": "Today", "type": "s_answer", "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "id": "ibge3q4qg5u3xy", "history": [{"content": "<p>简单来说&#xff0c;就是用一个Page对象中page_link的地址&#xff0c;减去page_link在Page结构中的偏移量&#xff0c;找到相应的Page对象的地址&#xff0c;然后强转成Page对象。</p>\n<p></p>\n<p>具体来说如下&#xff08;以下引用自实验指导书lab0&#xff09;&#xff1a;</p>\n<p></p>\n<p>list_entry_t通用双向循环链表中仅保存了某特定数据结构中链表节点成员变量的地址&#xff0c;那么如何通过这个链表节点成员变量访问到它的所有者&#xff08;即某特定数据结构的变量&#xff09;呢&#xff1f;Linux为此提供了针对数据结构XXX的le2XXX(le, member)的宏&#xff0c;其中le&#xff0c;即list entry的简称&#xff0c;是指向数据结构XXX中list_entry_t成员变量的指针&#xff0c;也就是存储在双向循环链表中的节点地址值&#xff0c; member则是XXX数据类型中包含的链表节点的成员变量。例如&#xff0c;我们要遍历访问空闲块链表中所有节点所在的基于Page数据结构的变量&#xff0c;则可以采用如下编程方式&#xff08;基于lab2/kern/mm/default_pmm.c&#xff09;&#xff1a;</p>\n<pre>//free_area是空闲块管理结构&#xff0c;free_area.free_list是空闲块链表头<br /> free_area_t free_area;<br /> list_entry_t * le = &amp;free_area.free_list; //le是空闲块链表头指针<br /> while((le=list_next(le)) != &amp;free_area.free_list) { //从第一个节点开始遍历<br /> struct Page *p = le2page(le, page_link); //获取节点所在基于Page数据结构的变量<br /> ……<br /> }</pre>\n<p>le2page宏&#xff08;定义位于lab2/kern/mm/memlayout.h&#xff09;的使用相当简单&#xff1a;</p>\n<pre>// convert list entry to page<br /> #define le2page(le, member) \\<br /> to_struct((le), struct Page, member)</pre>\n<p>而相比之下&#xff0c;它的实现用到的to_struct宏和offsetof宏&#xff08;定义位于lab2/libs/defs.h&#xff09;则有一些难懂&#xff1a;</p>\n<pre>/* Return the offset of &#39;member&#39; relative to the beginning of a struct type */<br /> #define offsetof(type, member) \\<br /> ((size_t)(&amp;((type *)0)-&gt;member))\n/* *<br /> * to_struct - get the struct from a ptr<br /> * &#64;ptr: a struct pointer of member<br /> * &#64;type: the type of the struct this is embedded in<br /> * &#64;member: the name of the member within the struct<br /> * */<br /> #define to_struct(ptr, type, member) \\<br /> ((type *)((char *)(ptr) - offsetof(type, member)))</pre>\n<p>这里采用了一个利用gcc编译器技术的技巧&#xff0c;即先求得数据结构的成员变量在本宿主数据结构中的偏移量&#xff0c;然后根据成员变量的地址反过来得出属主数据结构的变量的地址。</p>\n<p>我们首先来看offsetof宏&#xff0c;size_t最终定义与CPU体系结构相关&#xff0c;本实验都采用Intel X86-32 CPU&#xff0c;故size_t等价于 unsigned int。 ((type \\*)0)-&gt;member的设计含义是什么&#xff1f;其实这是为了求得数据结构的成员变量在本宿主数据结构中的偏移量。为了达到这个目标&#xff0c;首先将0地址强制&#34;转换&#34;为type数据结构&#xff08;比如struct Page&#xff09;的指针&#xff0c;再访问到type数据结构中的member成员&#xff08;比如page_link&#xff09;的地址&#xff0c;即是type数据结构中member成员相对于数据结构变量的偏移量。在offsetof宏中&#xff0c;这个member成员的地址&#xff08;即“&amp;((type \\*)0)-&gt;member)”&#xff09;实际上就是type数据结构中member成员相对于数据结构变量的偏移量。对于给定一个结构&#xff0c;offsetof(type,member)是一个常量&#xff0c;to_struct宏正是利用这个不变的偏移量来求得链表数据项的变量地址。接下来再分析一下to_struct宏&#xff0c;可以发现 to_struct宏中用到的ptr变量是链表节点的地址&#xff0c;把它减去offsetof宏所获得的数据结构内偏移量&#xff0c;即就得到了包含链表节点的属主数据结构的变量的地址。</p>\n<p></p>\n<p></p>", "anon": "stud", "subject": "", "uid": "i6uarbyshf06f8", "created": "2015-06-28T11:25:06Z"}]}, {"folders": [], "updated": "2016-03-04T12:31:53Z", "no_upvotes": 0, "uid": "i242q8ug7vw40x", "created": "2016-03-04T12:31:53Z", "type": "followup", "no_answer": 0, "id": "ildokk66ieh1n5", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [{"folders": [], "updated": "2016-03-04T13:35:17Z", "uid": "i242q8ug7vw40x", "created": "2016-03-04T13:35:17Z", "type": "feedback", "id": "ildqu3qxs9239w", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "看了其他的讨论 我已经明白了... 抱歉"}], "subject": "我也有同样的疑问, 但楼上的回答应该是说知道page_link如何找到持有他的page结构体, 但题主问的应该是说一个Page结构体管理的那个4K大小的物理页的信息究竟应该怎么得到, 请求回答."}], "no_answer_followup": 0, "nr": 490, "bucket_order": 2, "config": {}, "status": "active", "tags": ["lab2", "student"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2015-06-28T09:45:34Z", "is_tag_good": false, "type": "question", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1457674529591, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>请问老师&#xff0c;助教&#xff0c;同学们&#xff0c;实验2中的Page数据结构是如何跟实际物理页联系起来的呢&#xff1f;</p>\n<div>struct Page {<br />    int ref;                        // page frame&#39;s reference counter<br />    uint32_t flags;                 // array of flags that describe the status of the page frame<br />    unsigned int property;          // the num of free block, used in first fit pm manager<br />    list_entry_t page_link;         // free list link<br />};<br />Page中并没有一个member标识出它对应的实际物理页的相关信息呐&#xff1f;&#xff1f;</div>", "anon": "no", "subject": "实验2中的一个疑问", "uid": "iaxb95cm1DB", "created": "2015-06-28T09:45:34Z"}]}, "error": null}