{"aid": "j0feuxg5gbm79h", "result": {"status": "active", "unique_views": 95, "request_instructor_me": false, "change_log": [{"data": "ilraqm2jpqo32g", "anon": "no", "when": "2016-03-14T01:13:27Z", "uid": "i0ayxqk6wry734", "type": "create"}, {"data": "ils1rwn3ruwgi", "anon": "no", "when": "2016-03-14T13:50:17Z", "uid": "i0ayxqk6wry734", "type": "update"}, {"uid": "hcrrjuyequh4bt", "data": "im1dig5so3y78t", "when": "2016-03-21T02:28:47Z", "to": "ilraqm2h1bx32f", "anon": "no", "type": "i_answer"}, {"type": "update", "anon": "no", "when": "2017-03-18T01:56:49Z", "data": "j0elrq009og4zu", "uid": "hdjonbiyfs62ie"}, {"type": "update", "anon": "no", "when": "2017-03-18T04:05:28Z", "data": "j0eqd5lhtlo59l", "uid": "hdjonbiyfs62ie"}], "upvote_ids": [], "id": "ilraqm2h1bx32f", "bookmarked": 6, "no_answer": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "is_tag_endorse": false, "created": "2016-03-21T02:28:47Z", "type": "i_answer", "tag_endorse_arr": [], "id": "im1dig5ozr678s", "bucket_name": "Today", "config": {}, "tag_endorse": [], "bucket_order": 2, "data": {"embed_links": []}, "children": [], "history": [{"content": "<p>很好&#xff01;</p>", "anon": "no", "created": "2016-03-21T02:28:47Z", "uid": "hcrrjuyequh4bt", "subject": ""}]}], "nr": 691, "bucket_order": 2, "type": "question", "folders": ["lecture7", "2016", "特权级"], "no_answer_followup": 0, "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "tags": ["2016", "lecture7", "student", "特权级"], "created": "2016-03-14T01:13:27Z", "is_tag_good": false, "config": {}, "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1489851068117, "tag_good": [{"name": "Yong XIANG", "admin": true, "photo": null, "us": false, "id": "hdjonbiyfs62ie", "class_sections": ["课程设计_i5j09fnsl7k5x0", "清华学生_i5j09fnsl7k5x0", "所有老师和助教_i5j09fnsl7k5x0"], "role": "instructor", "facebook_id": null, "email": "xyong@tsinghua.edu.cn", "admin_permission": 10}, {"name": "霍健炜2016110024", "admin": false, "photo": null, "us": false, "id": "im4yagyfl3chl", "class_sections": ["清华学生_i5j09fnsl7k5x0"], "role": "student", "facebook_id": null, "email": "huojw15@mails.tsinghua.edu.cn"}], "tag_good_arr": ["hdjonbiyfs62ie", "im4yagyfl3chl"], "history": [{"content": "<p>【更新】特权级切换的方法&#xff0c;在lab1 challenge里有所涉及&#xff0c;主要就是依靠软中断进入内核</p>\n<p>由内核修改硬件自动保存的异常帧trap_frame数据结构&#xff0c;使得在异常返回时&#xff0c;给硬件造成一种假象&#xff0c;好像你原先是从你所希望前往的那个特权级进入中断内核程序的&#xff0c;这样就可以实现特权级的转换了&#xff0c;所以问题的关键就是怎么改异常帧&#xff0c;才能正确跳转回去&#xff08;自己实验的时候发现有些字段改和不改好像都能跳回去&#xff09;&#xff0c;故我们需要知道IRET这条指令在中断返回究竟干了些什么&#xff0c;为此查阅了Intel处理器手册</p>\n<div>\n<div>\n<div>\n<pre>Intel® 64 and IA-32 Architectures Software Developer’s Manual \nCombined Volumes: 1, 2A, 2B, 2C, 3A, 3B, 3C and 3D\nDecember 2015,Order Number: 325462-057US</pre>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<p>&#xff08;在此感谢上课提供帮助的来自香港的留学生小伙伴以及其他两位协力的小伙伴&#xff09;&#xff0c;手册中从961页开始描述了iret指令的具体执行流程&#xff0c;</p>\n<p>在此只描述和我们上课内容有关的部分。</p>\n<p>在实模式下&#xff0c;这个过程比较简单&#xff0c;就是恢复三个部分&#xff0c;cs/eip/eflags&#xff0c;就能保证状态还原了</p>\n<pre>In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<p>在保护模式下&#xff0c;这个事情变得很复杂&#xff0c;我们只讨论其中我们关心的两种</p>\n<div>\n<div>\n<div>\n<ul><li>\n<p>Intra-privilege level return </p>\n</li><li>\n<p>Inter-privilege level return</p>\n<div>\n<div>\n<div></div>\n</div>\n</div>\n</li></ul>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<p>指令的执行流是这样的</p>\n<pre>IF PE = 0 THEN GOTO REAL-ADDRESS-MODE;\nELSIF (IA32_EFER.LMA = 0) THEN\n\tIF (EFLAGS.VM = 1) THEN GOTO RETURN-FROM-VIRTUAL-8086-MODE; \n\tELSE GOTO PROTECTED-MODE;\n\tFI;\nELSE GOTO IA-32e-MODE;\nFI;</pre>\n<p>我们关心的是GOTO PROTECTED-MODE的分支&#xff08;大胆猜测是这个模式&#xff09;</p>\n<pre>PROTECTED-MODE: \nIF NT = 1 \n\tTHEN GOTO TASK-RETURN; (* PE = 1, VM = 0, NT = 1 *) \nFI;\nIF OperandSize = 32 THEN\n\tEIP ← Pop();\n\tCS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *) \n\ttempEFLAGS ← Pop();\nELSE (* OperandSize = 16 *)\n\tEIP ← Pop(); (* 16-bit pop; clear upper bits *)\n\tCS ← Pop(); (* 16-bit pop *)\n\ttempEFLAGS ← Pop(); (* 16-bit pop; clear upper bits *)\nFI;\nIF tempEFLAGS(VM) = 1 and CPL = 0\n\tTHEN GOTO RETURN-TO-VIRTUAL-8086-MODE;\nELSE GOTO PROTECTED-MODE-RETURN; \nFI;</pre>\n<p>应该选32位模式这个分支&#xff0c;我们看到先弹出了eip,cs和eflags(临时变量)&#xff0c;这段和实模式一样</p>\n<p>然后应该去到 GOTO PROTECTED-MODE-RETURN</p>\n<pre>PROTECTED-MODE-RETURN: (* PE = 1 *) \nIF CS(RPL) &gt; CPL\nTHEN GOTO RETURN-TO-OUTER-PRIVILEGE-LEVEL;\nELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL; \nFI; END;</pre>\n<p>这里终于出现的期待已久的特权级判断&#xff0c;然而并看不懂了&#xff08;=_=&#xff09;&#xff0c;CS(RPL)是什么&#xff1f;不是说cs里的是CPL么。。</p>\n<p>暂时搁置&#xff0c;继续往下&#xff0c;先看特权级切换的分支</p>\n<pre>RETURN-TO-OUTER-PRIVILEGE-LEVEL: \nIF OperandSize = 32 THEN\n\tESP ← Pop();\n\tSS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *) \nELSE IF OperandSize = 16 THEN\n\tESP ← Pop(); (* 16-bit pop; clear upper bits *) \n\tSS ← Pop(); (* 16-bit pop *)\n     ELSE (* OperandSize = 64 *) \n\tRSP ← Pop();\n\tSS ← Pop(); (* 64-bit pop, high-order 48 bits discarded *) \n     FI;\nIF new mode ≠ 64-Bit Mode THEN\n\tIF EIP is not within CS limit THEN #GP(0); \n\tFI;\nELSE (* new mode = 64-bit mode *)\n\tIF RIP is non-canonical THEN #GP(0); FI;\nFI;\nEFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) ← tempEFLAGS; \nIF OperandSize = 32\n\tTHEN EFLAGS(RF, AC, ID) ← tempEFLAGS; \nFI; \nIF CPL ≤ IOPL\n\tTHEN EFLAGS(IF) ← tempEFLAGS; \nFI; \nIF CPL = 0 THEN\n\tEFLAGS(IOPL) ← tempEFLAGS; \n\tIF OperandSize = 32 THEN \n\t\tEFLAGS(VM, VIF, VIP) ← tempEFLAGS; \n\tFI; \n\tIF OperandSize = 64 THEN \n\t\tEFLAGS(VIF, VIP) ← tempEFLAGS; \n\tFI;\nFI;\nCPL ← CS(RPL);\nFOR each SegReg in (ES, FS, GS, and DS) DO\n\ttempDesc ← descriptor cache for SegReg (* hidden part of segment register *) \nIF tempDesc(DPL) &lt; CPL AND tempDesc(Type) is data or non-conforming code\n\tTHEN (* Segment register invalid *) SegReg ← NULL;\nFI; \nOD;\nEND;</pre>\n<p>这部分描述了向低特权级切换时的流程&#xff0c;恢复了esp和ss&#xff0c;然后出现了一个不知道是什么的IOPL&#xff08;拜托PL好多了不要再来了。。&#xff09;</p>\n<p>看到这里似乎可以推断系统判断自己现在在哪个特权级应该不是当场查CS的CPL的&#xff0c;而是缓存了一个CPL寄存器还是啥的&#xff0c;切换的时候再重新赋值&#xff0c;然后我们可以看到关于数据段寄存器貌似是不恢复的&#xff08;为什么&#xff1f;&#xff1f;&#xff1f;&#xff1f;&#xff09;&#xff0c;但是会做一个判断&#xff0c;如果没有权限访问就把隐藏部分清除&#xff08;还是考虑的很周到。。&#xff09;</p>\n<p>再看同特权级转换的过程</p>\n<pre>RETURN-TO-SAME-PRIVILEGE-LEVEL: (* PE = 1, RPL = CPL *) \nIF new mode ≠ 64-Bit Mode THEN\n\tIF EIP is not within CS limit\n\tTHEN #GP(0); FI;\nELSE (* new mode = 64-bit mode *)\n\tIF RIP is non-canonical THEN #GP(0); FI;\nFI;\nEFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) ← tempEFLAGS; \nIF OperandSize = 32 or OperandSize = 64 \nTHEN EFLAGS(RF, AC, ID) ← tempEFLAGS; \nFI;\nIF CPL ≤ IOPL\nTHEN EFLAGS(IF) ← tempEFLAGS; FI;\nIF CPL = 0\nTHEN (* VM = 0 in flags image *)\nEFLAGS(IOPL) ← tempEFLAGS;\nIF OperandSize = 32 or OperandSize = 64\nTHEN EFLAGS(VIF, VIP) ← tempEFLAGS; FI;\nFI; END;\n</pre>\n<p>好像就是恢复了一下eflags,具体过程不太懂</p>\n<p></p>\n<p>综上我们似乎可以得出结论&#xff0c;只要在异常帧中正确设置了cs和eip&#xff0c;基本就能达到目的了&#xff0c;如果要切换到用户模式&#xff0c;需要设置一下ss和esp&#xff1b;ss应该需要设置好&#xff08;不知道回去之后还能改吗&#xff1f;&#xff09;,esp也可以回去之后再改&#xff0c;这个应该没问题&#xff1b;如果是切到内核态&#xff0c;那么系统多压栈的ss和esp应该就没有作用了&#xff0c;但是还是留在了内核栈没有被弹出&#xff08;不知道有没有隐患&#xff09;。</p>\n<p>p.s. 还有那个CS(RPL)和IOPL有哪位大神解释下么=_=</p>", "anon": "no", "created": "2017-03-18T04:05:28Z", "uid": "hdjonbiyfs62ie", "subject": "特权级切换时iret的准确过程&#xff08;课上提问&#xff09;"}, {"content": "<p>【更新】特权级切换的方法&#xff0c;在lab1 challenge里有所涉及&#xff0c;主要就是依靠软中断进入内核</p>\n<p>由内核修改硬件自动保存的异常帧trap_frame数据结构&#xff0c;使得在异常返回时&#xff0c;给硬件造成一种假象&#xff0c;好像你原先是从你所希望前往的那个特权级进入中断内核程序的&#xff0c;这样就可以实现特权级的转换了&#xff0c;所以问题的关键就是怎么改异常帧&#xff0c;才能正确跳转回去&#xff08;自己实验的时候发现有些字段改和不改好像都能跳回去&#xff09;&#xff0c;故我们需要知道IRET这条指令在中断返回究竟干了些什么&#xff0c;为此查阅了Intel处理器手册</p>\n<div>\n<div>\n<div>\n<pre>Intel® 64 and IA-32 Architectures Software Developer’s Manual \nCombined Volumes: 1, 2A, 2B, 2C, 3A, 3B, 3C and 3D\nDecember 2015,Order Number: 325462-057US</pre>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<p>&#xff08;在此感谢上课提供帮助的来自香港的留学生小伙伴以及其他两位协力的小伙伴&#xff09;&#xff0c;手册中从961页开始描述了iret指令的具体执行流程&#xff0c;</p>\n<p>在此只描述和我们上课内容有关的部分。</p>\n<p>在实模式下&#xff0c;这个过程比较简单&#xff0c;就是恢复三个部分&#xff0c;cs/eip/eflags&#xff0c;就能保证状态还原了</p>\n<pre>In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<p>在保护模式下&#xff0c;这个事情变得很复杂&#xff0c;我们只讨论其中我们关心的两种</p>\n<div>\n<div>\n<div>\n<ul><li>\n<p>Intra-privilege level return </p>\n</li><li>\n<p>Inter-privilege level return</p>\n<div>\n<div>\n<div></div>\n</div>\n</div>\n</li></ul>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<p>指令的执行流是这样的</p>\n<pre>IF PE = 0 THEN GOTO REAL-ADDRESS-MODE;\nELSIF (IA32_EFER.LMA = 0) THEN\n\tIF (EFLAGS.VM = 1) THEN GOTO RETURN-FROM-VIRTUAL-8086-MODE; \n\tELSE GOTO PROTECTED-MODE;\n\tFI;\nELSE GOTO IA-32e-MODE;\nFI;</pre>\n<p>我们关心的是GOTO PROTECTED-MODE的分支&#xff08;大胆猜测是这个模式&#xff09;</p>\n<pre>PROTECTED-MODE: \nIF NT = 1 \n\tTHEN GOTO TASK-RETURN; (* PE = 1, VM = 0, NT = 1 *) \nFI;\nIF OperandSize = 32 THEN\n\tEIP ← Pop();\n\tCS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *) \n\ttempEFLAGS ← Pop();\nELSE (* OperandSize = 16 *)\n\tEIP ← Pop(); (* 16-bit pop; clear upper bits *)\n\tCS ← Pop(); (* 16-bit pop *)\n\ttempEFLAGS ← Pop(); (* 16-bit pop; clear upper bits *)\nFI;\nIF tempEFLAGS(VM) = 1 and CPL = 0\n\tTHEN GOTO RETURN-TO-VIRTUAL-8086-MODE;\nELSE GOTO PROTECTED-MODE-RETURN; \nFI;</pre>\n<p>应该选32位模式这个分支&#xff0c;我们看到先弹出了eip,cs和eflags(临时变量)&#xff0c;这段和实模式一样</p>\n<p>然后应该去到 GOTO PROTECTED-MODE-RETURN</p>\n<pre>PROTECTED-MODE-RETURN: (* PE = 1 *) \nIF CS(RPL) &gt; CPL\nTHEN GOTO RETURN-TO-OUTER-PRIVILEGE-LEVEL;\nELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL; \nFI; END;</pre>\n<p>这里终于出现的期待已久的特权级判断&#xff0c;然而并看不懂了&#xff08;=_=&#xff09;&#xff0c;CS(RPL)是什么&#xff1f;不是说cs里的是CPL么。。</p>\n<p>暂时搁置&#xff0c;继续往下&#xff0c;先看特权级切换的分支</p>\n<pre>RETURN-TO-OUTER-PRIVILEGE-LEVEL: \nIF OperandSize = 32 THEN\n\tESP ← Pop();\n\tSS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *) \nELSE IF OperandSize = 16 THEN\n\tESP ← Pop(); (* 16-bit pop; clear upper bits *) \n\tSS ← Pop(); (* 16-bit pop *)\n     ELSE (* OperandSize = 64 *) \n\tRSP ← Pop();\n\tSS ← Pop(); (* 64-bit pop, high-order 48 bits discarded *) \n     FI;\nIF new mode ≠ 64-Bit Mode THEN\n\tIF EIP is not within CS limit THEN #GP(0); \n\tFI;\nELSE (* new mode = 64-bit mode *)\n\tIF RIP is non-canonical THEN #GP(0); FI;\nFI;\nEFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) ← tempEFLAGS; \nIF OperandSize = 32\n\tTHEN EFLAGS(RF, AC, ID) ← tempEFLAGS; \nFI; \nIF CPL ≤ IOPL\n\tTHEN EFLAGS(IF) ← tempEFLAGS; \nFI; \nIF CPL = 0 THEN\n\tEFLAGS(IOPL) ← tempEFLAGS; \n\tIF OperandSize = 32 THEN \n\t\tEFLAGS(VM, VIF, VIP) ← tempEFLAGS; \n\tFI; \n\tIF OperandSize = 64 THEN \n\t\tEFLAGS(VIF, VIP) ← tempEFLAGS; \n\tFI;\nFI;\nCPL ← CS(RPL);\nFOR each SegReg in (ES, FS, GS, and DS) DO\n\ttempDesc ← descriptor cache for SegReg (* hidden part of segment register *) \nIF tempDesc(DPL) &lt; CPL AND tempDesc(Type) is data or non-conforming code\n\tTHEN (* Segment register invalid *) SegReg ← NULL;\nFI; \nOD;\nEND;</pre>\n<p>这部分描述了向低特权级切换时的流程&#xff0c;恢复了esp和ss&#xff0c;然后出现了一个不知道是什么的IOPL&#xff08;拜托PL好多了不要再来了。。&#xff09;</p>\n<p>看到这里似乎可以推断系统判断自己现在在哪个特权级应该不是当场查CS的CPL的&#xff0c;而是缓存了一个CPL寄存器还是啥的&#xff0c;切换的时候再重新赋值&#xff0c;然后我们可以看到关于数据段寄存器貌似是不恢复的&#xff08;为什么&#xff1f;&#xff1f;&#xff1f;&#xff1f;&#xff09;&#xff0c;但是会做一个判断&#xff0c;如果没有权限访问就把隐藏部分清除&#xff08;还是考虑的很周到。。&#xff09;</p>\n<p>再看同特权级转换的过程</p>\n<pre>RETURN-TO-SAME-PRIVILEGE-LEVEL: (* PE = 1, RPL = CPL *) \nIF new mode ≠ 64-Bit Mode THEN\n\tIF EIP is not within CS limit\n\tTHEN #GP(0); FI;\nELSE (* new mode = 64-bit mode *)\n\tIF RIP is non-canonical THEN #GP(0); FI;\nFI;\nEFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) ← tempEFLAGS; \nIF OperandSize = 32 or OperandSize = 64 \nTHEN EFLAGS(RF, AC, ID) ← tempEFLAGS; \nFI;\nIF CPL ≤ IOPL\nTHEN EFLAGS(IF) ← tempEFLAGS; FI;\nIF CPL = 0\nTHEN (* VM = 0 in flags image *)\nEFLAGS(IOPL) ← tempEFLAGS;\nIF OperandSize = 32 or OperandSize = 64\nTHEN EFLAGS(VIF, VIP) ← tempEFLAGS; FI;\nFI; END;\n</pre>\n<p>好像就是恢复了一下eflags,具体过程不太懂</p>\n<p></p>\n<p>综上我们似乎可以得出结论&#xff0c;只要在异常帧中正确设置了cs和eip&#xff0c;基本就能达到目的了&#xff0c;如果要切换到用户模式&#xff0c;需要设置一下ss和esp&#xff1b;ss应该需要设置好&#xff08;不知道回去之后还能改吗&#xff1f;&#xff09;,esp也可以回去之后再改&#xff0c;这个应该没问题&#xff1b;如果是切到内核态&#xff0c;那么系统多压栈的ss和esp应该就没有作用了&#xff0c;但是还是留在了内核栈没有被弹出&#xff08;不知道有没有隐患&#xff09;。</p>\n<p>p.s. 还有那个CS(RPL)和IOPL有哪位大神解释下么=_=</p>", "anon": "no", "created": "2017-03-18T01:56:49Z", "uid": "hdjonbiyfs62ie", "subject": "特权级切换时iret的准确过程&#xff08;课上提问&#xff09;"}, {"content": "<p>【更新】特权级切换的方法&#xff0c;在lab1 challenge里有所涉及&#xff0c;主要就是依靠软中断进入内核</p>\n<p>由内核修改硬件自动保存的异常帧trap_frame数据结构&#xff0c;使得在异常返回时&#xff0c;给硬件造成一种假象&#xff0c;好像你原先是从你所希望前往的那个特权级进入中断内核程序的&#xff0c;这样就可以实现特权级的转换了&#xff0c;所以问题的关键就是怎么改异常帧&#xff0c;才能正确跳转回去&#xff08;自己实验的时候发现有些字段改和不改好像都能跳回去&#xff09;&#xff0c;故我们需要知道IRET这条指令在中断返回究竟干了些什么&#xff0c;为此查阅了Intel处理器手册</p>\n<div>\n<div>\n<div>\n<pre>Intel® 64 and IA-32 Architectures Software Developer’s Manual <br />Combined Volumes: 1, 2A, 2B, 2C, 3A, 3B, 3C and 3D<br />December 2015,Order Number: 325462-057US</pre>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<div>\n<p>&#xff08;在此感谢上课提供帮助的来自香港的留学生小伙伴以及其他两位协力的小伙伴&#xff09;&#xff0c;手册中从961页开始描述了iret指令的具体执行流程&#xff0c;</p>\n<p>在此只描述和我们上课内容有关的部分。</p>\n<p>在实模式下&#xff0c;这个过程比较简单&#xff0c;就是恢复三个部分&#xff0c;cs/eip/eflags&#xff0c;就能保证状态还原了</p>\n<pre>In Real-Address Mode, the IRET instruction preforms a far return to the interrupted program or procedure. During this operation, the processor pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.</pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<p>在保护模式下&#xff0c;这个事情变得很复杂&#xff0c;我们只讨论其中我们关心的两种</p>\n<div>\n<div>\n<div>\n<ul><li>\n<p>Intra-privilege level return </p>\n</li><li>\n<p>Inter-privilege level return</p>\n<div>\n<div>\n<div></div>\n</div>\n</div>\n</li></ul>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<p>指令的执行流是这样的</p>\n<pre>IF PE = 0 THEN GOTO REAL-ADDRESS-MODE;\nELSIF (IA32_EFER.LMA = 0) THEN\n\tIF (EFLAGS.VM = 1) THEN GOTO RETURN-FROM-VIRTUAL-8086-MODE; <br />\tELSE GOTO PROTECTED-MODE;\n\tFI;\nELSE GOTO IA-32e-MODE;\nFI;</pre>\n<p>我们关心的是GOTO PROTECTED-MODE的分支&#xff08;大胆猜测是这个模式&#xff09;</p>\n<pre>PROTECTED-MODE: <br />IF NT = 1 <br />\tTHEN GOTO TASK-RETURN; (* PE = 1, VM = 0, NT = 1 *) <br />FI;\nIF OperandSize = 32 THEN\n\tEIP ← Pop();\n\tCS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *) <br />\ttempEFLAGS ← Pop();\nELSE (* OperandSize = 16 *)\n\tEIP ← Pop(); (* 16-bit pop; clear upper bits *)\n\tCS ← Pop(); (* 16-bit pop *)\n\ttempEFLAGS ← Pop(); (* 16-bit pop; clear upper bits *)\nFI;\nIF tempEFLAGS(VM) = 1 and CPL = 0\n\tTHEN GOTO RETURN-TO-VIRTUAL-8086-MODE;\nELSE GOTO PROTECTED-MODE-RETURN; <br />FI;</pre>\n<p>应该选32位模式这个分支&#xff0c;我们看到先弹出了eip,cs和eflags(临时变量)&#xff0c;这段和实模式一样</p>\n<p>然后应该去到 GOTO PROTECTED-MODE-RETURN</p>\n<pre>PROTECTED-MODE-RETURN: (* PE = 1 *) <br />IF CS(RPL) &gt; CPL\nTHEN GOTO RETURN-TO-OUTER-PRIVILEGE-LEVEL;\nELSE GOTO RETURN-TO-SAME-PRIVILEGE-LEVEL; <br />FI; END;</pre>\n<p>这里终于出现的期待已久的特权级判断&#xff0c;然而并看不懂了&#xff08;=_=&#xff09;&#xff0c;CS(RPL)是什么&#xff1f;不是说cs里的是CPL么。。</p>\n<p>暂时搁置&#xff0c;继续往下&#xff0c;先看特权级切换的分支</p>\n<pre>RETURN-TO-OUTER-PRIVILEGE-LEVEL: <br />IF OperandSize = 32 THEN\n\tESP ← Pop();\n\tSS ← Pop(); (* 32-bit pop, high-order 16 bits discarded *) <br />ELSE IF OperandSize = 16 THEN\n\tESP ← Pop(); (* 16-bit pop; clear upper bits *) <br />\tSS ← Pop(); (* 16-bit pop *)\n     ELSE (* OperandSize = 64 *) <br />\tRSP ← Pop();\n\tSS ← Pop(); (* 64-bit pop, high-order 48 bits discarded *) <br />     FI;\nIF new mode ≠ 64-Bit Mode THEN\n\tIF EIP is not within CS limit THEN #GP(0); <br />\tFI;\nELSE (* new mode = 64-bit mode *)\n\tIF RIP is non-canonical THEN #GP(0); FI;\nFI;\nEFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) ← tempEFLAGS; <br />IF OperandSize = 32\n\tTHEN EFLAGS(RF, AC, ID) ← tempEFLAGS; <br />FI; <br />IF CPL ≤ IOPL\n\tTHEN EFLAGS(IF) ← tempEFLAGS; <br />FI; <br />IF CPL = 0 THEN\n\tEFLAGS(IOPL) ← tempEFLAGS; <br />\tIF OperandSize = 32 THEN <br />\t\tEFLAGS(VM, VIF, VIP) ← tempEFLAGS; <br />\tFI; <br />\tIF OperandSize = 64 THEN <br />\t\tEFLAGS(VIF, VIP) ← tempEFLAGS; <br />\tFI;\nFI;\nCPL ← CS(RPL);\nFOR each SegReg in (ES, FS, GS, and DS) DO\n\ttempDesc ← descriptor cache for SegReg (* hidden part of segment register *) <br />IF tempDesc(DPL) &lt; CPL AND tempDesc(Type) is data or non-conforming code\n\tTHEN (* Segment register invalid *) SegReg ← NULL;\nFI; <br />OD;\nEND;</pre>\n<p>这部分描述了向低特权级切换时的流程&#xff0c;恢复了esp和ss&#xff0c;然后出现了一个不知道是什么的IOPL&#xff08;拜托PL好多了不要再来了。。&#xff09;</p>\n<p>看到这里似乎可以推断系统判断自己现在在哪个特权级应该不是当场查CS的CPL的&#xff0c;而是缓存了一个CPL寄存器还是啥的&#xff0c;切换的时候再重新赋值&#xff0c;然后我们可以看到关于数据段寄存器貌似是不恢复的&#xff08;为什么&#xff1f;&#xff1f;&#xff1f;&#xff1f;&#xff09;&#xff0c;但是会做一个判断&#xff0c;如果没有权限访问就把隐藏部分清除&#xff08;还是考虑的很周到。。&#xff09;</p>\n<p>再看同特权级转换的过程</p>\n<pre>RETURN-TO-SAME-PRIVILEGE-LEVEL: (* PE = 1, RPL = CPL *) <br />IF new mode ≠ 64-Bit Mode THEN\n\tIF EIP is not within CS limit\n\tTHEN #GP(0); FI;\nELSE (* new mode = 64-bit mode *)\n\tIF RIP is non-canonical THEN #GP(0); FI;\nFI;\nEFLAGS (CF, PF, AF, ZF, SF, TF, DF, OF, NT) ← tempEFLAGS; <br />IF OperandSize = 32 or OperandSize = 64 <br />THEN EFLAGS(RF, AC, ID) ← tempEFLAGS; <br />FI;<br />IF CPL ≤ IOPL\nTHEN EFLAGS(IF) ← tempEFLAGS; FI;\nIF CPL = 0\nTHEN (* VM = 0 in flags image *)<br />EFLAGS(IOPL) ← tempEFLAGS;\nIF OperandSize = 32 or OperandSize = 64\nTHEN EFLAGS(VIF, VIP) ← tempEFLAGS; FI;\nFI; END;\n</pre>\n<p>好像就是恢复了一下eflags,具体过程不太懂</p>\n<p></p>\n<p>综上我们似乎可以得出结论&#xff0c;只要在异常帧中正确设置了cs和eip&#xff0c;基本就能达到目的了&#xff0c;如果要切换到用户模式&#xff0c;需要设置一下ss和esp&#xff1b;ss应该需要设置好&#xff08;不知道回去之后还能改吗&#xff1f;&#xff09;,esp也可以回去之后再改&#xff0c;这个应该没问题&#xff1b;如果是切到内核态&#xff0c;那么系统多压栈的ss和esp应该就没有作用了&#xff0c;但是还是留在了内核栈没有被弹出&#xff08;不知道有没有隐患&#xff09;。</p>\n<p>p.s. 还有那个CS(RPL)和IOPL有哪位大神解释下么=_=</p>", "anon": "no", "created": "2016-03-14T13:50:17Z", "uid": "i0ayxqk6wry734", "subject": "特权级切换时iret的准确过程&#xff08;课上提问&#xff09;"}, {"content": "<p>下课后总结</p>", "anon": "no", "created": "2016-03-14T01:13:27Z", "uid": "i0ayxqk6wry734", "subject": "特权级切换时iret的准确过程&#xff08;课上提问&#xff09;"}]}, "error": null}