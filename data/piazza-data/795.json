{"aid": "in90nx2447n7l4", "result": {"folders": ["lecture14", "课堂问答"], "unique_views": 110, "request_instructor_me": false, "change_log": [{"data": "imyanvkkdra16m", "anon": "no", "when": "2016-04-13T03:25:25Z", "uid": "hdjonbiyfs62ie", "type": "create"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T03:25:50Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T03:26:12Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T03:26:42Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"data": "imyhwudd7uv3sm", "anon": "no", "when": "2016-04-13T06:48:20Z", "uid": "hcrrjuyequh4bt", "type": "update"}, {"data": "imyl07hqgk43yi", "anon": "no", "when": "2016-04-13T08:14:56Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T08:24:41Z", "uid": "i0nuu5yhgno5tv", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T09:01:56Z", "uid": "i0yuo4o74sx70w", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T09:01:59Z", "uid": "ikvcvr0o2bs7m3", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T09:09:29Z", "uid": "i6ub4vwhQXd", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T09:09:46Z", "uid": "i0ayxqk6wry734", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T09:10:23Z", "uid": "i0gl5kctugw3xi", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T09:12:12Z", "uid": "ikvcvr6di5i7ma", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T09:16:31Z", "uid": "i6w84pnmjCQ", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T09:42:46Z", "uid": "i1bzj2xilgm4uk", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T10:05:41Z", "uid": "i0zaci5voig5h", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T10:06:53Z", "uid": "i6w84pnmjCQ", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T10:07:45Z", "uid": "i0c9nvk0xzc2n3", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T10:21:55Z", "uid": "i6vjwdpfniF", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T10:43:30Z", "uid": "i28skba6cd976f", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T11:18:28Z", "uid": "i0c1nsm3911wc", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T12:00:51Z", "uid": "i701mss708y", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T12:15:24Z", "uid": "ic226rac4j5jw", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-13T13:06:15Z", "uid": "i242q8ug7vw40x", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T02:01:22Z", "uid": "ikvcvqz0jx17m1", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T05:18:56Z", "uid": "i0ccqbaxwdz75c", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T06:37:30Z", "uid": "i3qk2vs65x276j", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T11:14:31Z", "uid": "i21zpwab2z775p", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T11:24:21Z", "uid": "i6vir34gLfK", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T11:25:30Z", "uid": "ikx8y1dzPrM", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T11:29:01Z", "uid": "ikvcvnzpzq7j7", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T11:41:05Z", "uid": "i1569mw0xp954u", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T11:42:29Z", "uid": "i2olyyl8swl1we", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T11:48:22Z", "uid": "i11v1az5sf83l2", "type": "feedback"}, {"to": "imyanvkj7un16l", "anon": "no", "when": "2016-04-14T12:41:22Z", "uid": "i0evrfcnckf5dt", "type": "feedback"}, {"data": "in8fn7ksspm2tj", "anon": "no", "when": "2016-04-20T05:42:34Z", "uid": "hdjonbiyfs62ie", "type": "update"}], "upvote_ids": [], "id": "imyanvkj7un16l", "bookmarked": 29, "no_answer_followup": 0, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2016-04-13T03:25:50Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-13T03:25:50Z", "type": "followup", "no_answer": 0, "id": "imyaoeoko01ya", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2016-04-13T08:24:41Z", "uid": "i0nuu5yhgno5tv", "created": "2016-04-13T08:24:41Z", "type": "feedback", "id": "imylcqsy27118o", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<pre>Ikernel panic at kern/trap/trap.c:300:\n    trap in user process\nebp:0xc038af48 eip:0xc0100adf 0xc010c2fe 0xc038af8c 0x0000012c 0x00000000 \n    kern/debug/kdebug.c:350: print_stackframe&#43;21\nebp:0xc038af78 eip:0xc0100e2b 0xc010c680 0x0000012c 0xc010c793 0x0000001b \n    kern/debug/panic.c:27: __panic&#43;93\nebp:0xc038afa8 eip:0xc0102bed 0xc038afb4 0x00000049 0x00000000 0xaffffe98 \n    kern/trap/trap.c:300: trap&#43;119\nebp:0xaffffe98 eip:0xc0102c05 0x0000001e 0x00000049 0xaffffec8 0x008000d6 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffea8 eip:0x00800290 0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;24\nebp:0xaffffec8 eip:0x008000d6 0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x0080056b 0x008000c5 0xafffff3c 0x008013e1 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;33\nebp:0xafffff48 eip:0x00800113 0x008013e0 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;45\nebp:0xafffff78 eip:0x00800136 0x008013e0 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;29\nebp:0xafffffa8 eip:0x00800fa6 0x00000000 0x00000000 0x00000000 0x00000000 \n    user/exit.c:9: main&#43;20\nebp:0xafffffd8 eip:0x0080034d 0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10</pre>\n<p>这是在trap里面发现是用户进程的时候的结果&#xff0c;注意ebp最下面是0xaffffffd8开头的&#xff0c;说明是用户进程&#xff0c;而不是kernel的栈。也就是说&#xff0c;进入trap的时候&#xff0c;会切换堆栈。</p>"}, {"folders": [], "updated": "2016-04-13T09:01:56Z", "uid": "i0yuo4o74sx70w", "created": "2016-04-13T09:01:56Z", "type": "feedback", "id": "imymon5asp2t", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>张浩天2013011416  郑兆衡2013011389</p>\n<p>在trap_dispatch()里添加如下代码</p>\n<pre>if (!trap_in_kernel(tf))\n    {\n        panic(&#34;trap in user mode&#34;);\n    }</pre>\n<p>在panic()里添加如下代码</p>\n<pre>print_stackframe();</pre>\n<p>这样执行make qemu后&#xff0c;输出</p>\n<pre>kernel panic at kern/trap/trap.c:200:\n    trap in user mode\nebp:0xc03adf18 eip:0xc0101f62 args:0xc010d89a 0xc03adf5c 0x000000c8 0x00000002 \n    kern/debug/kdebug.c:350: print_stackframe&#43;21\nebp:0xc03adf48 eip:0xc01022b6 args:0xc010dc20 0x000000c8 0xc010dc48 0x00000000 \n    kern/debug/panic.c:25: __panic&#43;93\nebp:0xc03adf78 eip:0xc0103c4a args:0xc03adfb4 0x00000000 0x00800020 0x0000001b \n    kern/trap/trap.c:200: trap_dispatch&#43;55\nebp:0xc03adfa8 eip:0xc0103ede args:0xc03adfb4 0x00000049 0x00000000 0xaffffe98 \n    kern/trap/trap.c:292: trap&#43;74\nebp:0xaffffe98 eip:0xc0103f33 args:0x0000001e 0x00000049 0xaffffec8 0x008000d6 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffea8 eip:0x00800290 args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;24\nebp:0xaffffec8 eip:0x008000d6 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x0080056b args:0x008000c5 0xafffff3c 0x008013e1 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;33\nebp:0xafffff48 eip:0x00800113 args:0x008013e0 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;45\nebp:0xafffff78 eip:0x00800136 args:0x008013e0 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;29\nebp:0xafffffa8 eip:0x00800fa6 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/exit.c:9: main&#43;20\nebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10</pre>\n<p></p>\n<p>现在解释如下输出为什么ebp在用户态地址&#xff0c;eip在内核态地址</p>\n<pre>ebp:0xaffffe98 eip:0xc0103f33 args:0x0000001e 0x00000049 0xaffffec8 0x008000d6 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0</pre>\n<p>可以看到</p>\n<pre>int\nsys_putc(int c) {\n    return syscall(SYS_putc, c);\n}</pre>\n<p>也就是说sys_putc()和trapentry.S中间其实还有一层函数调用syscall()&#xff0c;但是为什么输出中没有这层函数呢&#xff1f;</p>\n<p>其实这两个问题的根源是一致的。</p>\n<p></p>\n<p>首先我们梳理一下这个部分的实际的函数调用流程和状态&#xff1a;</p>\n<p>用户态&#xff1a;</p>\n<p>sys_putc() -&gt; syscall()</p>\n<p>用户态到内核态&#xff1a;</p>\n<p>syscall() -&gt; int软中断</p>\n<p>内核态&#xff1a;</p>\n<p>int软中断-&gt; __alltraps -&gt; trap()</p>\n<p></p>\n<p>问题的关键就出在用户态到内核态切换的过程&#xff0c;也就是syscall()内部</p>\n<p>这里虽然执行了int软中断&#xff0c;但硬件只会修改esp&#xff0c;使得用户栈切换到内核栈&#xff0c;但不会修改ebp&#xff0c;</p>\n<p>也就是说执行__alltraps的时候&#xff0c;虽然esp已经指向内核地址空间&#xff0c;但ebp仍指向用户地址空间&#xff0c;具体来说就是syscall()的栈基址</p>\n<p>因此&#xff0c;神奇的情况就会发生了&#xff1a;当__alltraps里call trap的时候&#xff0c;返回地址存的是_alltraps里下一条指令的地址&#xff0c;但进入trap以后&#xff0c;push ebp的时候&#xff0c;保存的竟然还是syscalI()的ebp&#xff0c;当然就指向用户地址空间了。</p>"}, {"folders": [], "updated": "2016-04-13T09:01:59Z", "uid": "ikvcvr0o2bs7m3", "created": "2016-04-13T09:01:59Z", "type": "feedback", "id": "imymopu15ps76h", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<pre>kernel panic at kern/syscall/syscall.c:58:\nebp:0xc03acec8 eip:0xc0101ecc args:0x00000049 0xc0102fb2 0x0000000a 0xc03acefc \n    kern/debug/kdebug.c:350: print_stackframe&#43;21\nebp:0xc03acee8 eip:0xc01017cb args:0xc010ef54 0x0000003a 0xc010ef4c 0x00000000 \n    kern/debug/panic.c:30: __panic&#43;110\nebp:0xc03acf18 eip:0xc010baad args:0xc03acf34 0xc03acf54 0xc0103d3e 0xc03acf60 \n    kern/syscall/syscall.c:0: sys_putc&#43;46\nebp:0xc03acf58 eip:0xc010bb34 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    kern/syscall/syscall.c:94: syscall&#43;116\nebp:0xc03acf78 eip:0xc0103bce args:0xc03acfb4 0x00000000 0x00000023 0x00000023 \n    kern/trap/trap.c:217: trap_dispatch&#43;271\nebp:0xc03acfa8 eip:0xc0103d3e args:0xc03acfb4 0x00000049 0x00000000 0xaffffea8 \n    kern/trap/trap.c:288: trap&#43;80\nebp:0xaffffea8 eip:0xc0104808 args:0x0000001e 0x00000049 0xaffffed8 0x00800254 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffeb8 eip:0x0080017e args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;12\nebp:0xaffffed8 eip:0x00800254 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x008009a2 args:0x00800243 0xafffff3c 0x00801321 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;29\nebp:0xafffff48 eip:0x00800288 args:0x00801320 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;32\nebp:0xafffff78 eip:0x008002ab args:0x00801320 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;26\nebp:0xafffffa8 eip:0x00800f00 args:0x00000000 0x00000000 0x00000000 0x0080030f \n    user/exit.c:9: main&#43;29\nebp:0xafffffd8 eip:0x0080030f args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10</pre>\n<p>在panic函数中添加print_stackframe(),并在syscall里面的sys_putc系统调用后面的cputchar(c)后面添加panic();打印出堆栈信息和用户态内核态的函数调用关系。</p>"}, {"folders": [], "updated": "2016-04-13T09:09:46Z", "uid": "i0ayxqk6wry734", "created": "2016-04-13T09:09:46Z", "type": "feedback", "id": "imymypi2vlv2wz", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>【第一个给出栈问题的解决方案的小组】2013011371 沈哲言  2013011404 叶子鹏 </p>\n<p></p>\n<p>首先&#xff0c;我们在panic函数里增加了print_stackframe调用&#xff0c;用来输出堆栈的信息</p>\n<pre>void\n__panic(const char *file, int line, const char *fmt, ...) {\n    if (is_panic) {\n        goto panic_dead;\n    }\n    is_panic = 1;\n\n    // print the &#39;message&#39;\n    va_list ap;\n    va_start(ap, fmt);\n    cprintf(&#34;kernel panic at %s:%d:\\n    &#34;, file, line);\n    vcprintf(fmt, ap);\n    cprintf(&#34;\\n&#34;);\n    va_end(ap);\n\n    //print stackframe\n    print_stackframe();\npanic_dead:\n    intr_disable();\n    while (1) {\n        kmonitor(NULL);\n    }\n}</pre>\n<p>接着&#xff0c;在中断返回时人工触发panic</p>\n<p></p>\n<pre>void\ntrap(struct trapframe *tf) {\n    // dispatch based on what type of trap occurred\n    // used for previous projects\n    if (current == NULL) {\n        trap_dispatch(tf);\n    }\n    else {\n        // keep a trapframe chain in stack\n        struct trapframe *otf = current-&gt;tf;\n        current-&gt;tf = tf;\n    \n        bool in_kernel = trap_in_kernel(tf);\n    \n        trap_dispatch(tf);\n    \n        current-&gt;tf = otf;\n        if (!in_kernel) {\n        \tpanic(&#34;lovelive&#34;);\n            if (current-&gt;flags &amp; PF_EXITING) {\n                do_exit(-E_KILLED);\n            }\n            if (current-&gt;need_resched) {\n                schedule();\n            }\n        }\n    }\n}</pre>\n<p>make qemu之后输出信息如下&#xff08;注意这是有问题的版本&#xff0c;之后会进行分析和修正&#xff09;</p>\n<pre>kernel panic at kern/trap/trap.c:299:\n    lovelive\nebp:0xc0389f58 eip:0xc0100b4f args:0x00000000 0x00000000 0x00000000 0xc0389f8c \n    kern/debug/kdebug.c:352: print_stackframe&#43;21\nebp:0xc0389f78 eip:0xc010044b args:0xc010ba40 0x0000012b 0xc010bb53 0x00000023 \n    kern/debug/panic.c:28: __panic&#43;91\nebp:0xc0389fa8 eip:0xc0102ace args:0xc0389fb4 0x00000049 0x00000000 0xaffffea8 \n    kern/trap/trap.c:299: trap&#43;123\nebp:0xaffffea8 eip:0xc0103557 args:0x0000001e 0x00000049 0xaffffed8 0x00800254 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffeb8 eip:0x0080017e args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;12\nebp:0xaffffed8 eip:0x00800254 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x008009a2 args:0x00800243 0xafffff3c 0x00801321 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;29\nebp:0xafffff48 eip:0x00800288 args:0x00801320 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;32\nebp:0xafffff78 eip:0x008002ab args:0x00801320 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;26\nebp:0xafffffa8 eip:0x00800f00 args:0x00000000 0x00000000 0x00000000 0x0080030f \n    user/exit.c:9: main&#43;29\nebp:0xafffffd8 eip:0x0080030f args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10</pre>\n<p><em><strong>首先我们先分析一下导致显示错误的原因&#xff1a;由于int触发的硬件中断不是一个call而是一个类似于jump的行为&#xff0c;所以all_traps并非一次函数调用。我们看到的entry.S中的ebp并非 all_traps 的&#xff0c;而是 system_call 的。</strong></em><br /><em><strong>我们现在的手段就是&#xff0c;修改print_stackframe函数&#xff0c;使其能正确输出栈帧信息。我们考虑到内核态拥有访问用户态的权限&#xff0c;所以我们在trap这个函数里面调用panic&#xff0c;再在panic中调用 print_stackframe&#xff08;这部分和原先一样&#xff09;最后我们修改 print_stackframe</strong></em><strong> 函数&#xff0c;在内核态和用户态切换的时候正确地过度以达到目的。</strong><strong><br /><br /></strong></p>\n<pre>void\nprint_stackframe(void) {\n    uint32_t ebp = read_ebp();\n    uint32_t eip = read_eip();\n    uint32_t oebp = 0;\n    int i = 0;\n    while (ebp &amp;&amp; i&lt;STACKFRAME_DEPTH){\n    \tcprintf(&#34;ebp:0x%08x eip:0x%08x args:&#34;, ebp, eip);\n    \tfor (int j=0; j&lt;4; j&#43;&#43;) cprintf(&#34;0x%08x &#34;, ((uint32_t *)ebp)[j&#43;2]);\n    \tcprintf(&#34;\\n&#34;);\n    \tprint_debuginfo(eip - 1);\n    \ti&#43;&#43;;\n    \toebp = ebp;\n    \teip = ((uint32_t *)ebp)[1];\n    \tebp = ((uint32_t *)ebp)[0];\n    \tif (oebp &gt; 0xc0000000 &amp;&amp; ebp &lt; 0xc0000000){\n    \t\tcprintf(&#34;ebp:0x%08x eip:0x%08x args:&#34;, oebp&#43;15*4, eip);\n    \t\tfor (int j=0; j&lt;4; j&#43;&#43;) cprintf(&#34;0x00000000 &#34;);cprintf(&#34;\\n&#34;);\n    \t\tprint_debuginfo(eip - 1);\n    \t\tcprintf(&#34;=====above is kernel stack trace, below is user stack trace======\\n&#34;);\n    \t\teip = ((uint32_t *)oebp)[17];\n    \t}\n    }\n}</pre>\n<p>我们的print较于原来的print&#xff0c;多了以下几个步骤&#xff1a;<br /><em><strong>1.记录old_ebp</strong></em><br /><em><strong>2.判断是不是 all_traps 并做特殊处理</strong></em><br /><em><strong>3.还原 sys_call 函数的栈帧</strong></em></p>\n<p>先看看新的输出结果</p>\n<p></p>\n<pre>kernel_execve: pid = 2, name = &#34;exit&#34;.\nIkernel panic at kern/trap/trap.c:299:\n    lovelive\nebp:0xc0389f58 eip:0xc0100b4f args:0x00000000 0x00000000 0x00000000 0xc0389f8c \n    kern/debug/kdebug.c:352: print_stackframe&#43;21\nebp:0xc0389f78 eip:0xc010044b args:0xc010bb40 0x0000012b 0xc010bc53 0x00000023 \n    kern/debug/panic.c:28: __panic&#43;91\nebp:0xc0389fa8 eip:0xc0102b6b args:0xc0389fb4 0x00000049 0x00000000 0xaffffea8 \n    kern/trap/trap.c:299: trap&#43;123\nebp:0xc0389fe4 eip:0xc01035f4 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\n=====above is kernel stack trace, below is user stack trace======\nebp:0xaffffea8 eip:0x008000fd args:0x0000001e 0x00000049 0xaffffed8 0x00800254 \n    user/libs/syscall.c:20: syscall&#43;71\nebp:0xaffffeb8 eip:0x0080017e args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:66: sys_putc&#43;12\nebp:0xaffffed8 eip:0x00800254 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x008009a2 args:0x00800243 0xafffff3c 0x00801321 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;29\nebp:0xafffff48 eip:0x00800288 args:0x00801320 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;32\nebp:0xafffff78 eip:0x008002ab args:0x00801320 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;26\nebp:0xafffffa8 eip:0x00800f00 args:0x00000000 0x00000000 0x00000000 0x0080030f \n    user/exit.c:9: main&#43;29\nebp:0xafffffd8 eip:0x0080030f args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10\nWelcome to the kernel debug monitor!!\nType &#39;help&#39; for a list of commands.</pre>\n<p>接下来我们详细解释这三步的工作。<br />1.记录old_ebp<br />我们在 all_traps 中的工作需要old_ebp<br />2.判断是不是 all_traps 并做特殊处理<br />我们针对ebp小于 0xc0000000 而eip大于 0xc0000000 的情况做特殊处理&#xff0c;它是 all_traps 函数&#xff0c;我们会计算出 all_traps 的栈帧首地址&#xff0c;并按照格式输出信息。并输出额外信息&#xff0c;表示内核栈结束。<br />3.还原 sys_call 函数的栈帧<br />sys_call 在错误显示中没有&#xff0c;它的ebp我们是知道的&#xff0c;我们只需要构造出其eip&#xff0c;根据栈的结构&#xff0c;我们推测出它的位置在esp上17个位置。这样我们就还原了它的栈帧。</p>"}, {"folders": [], "updated": "2016-04-13T09:12:12Z", "uid": "ikvcvr6di5i7ma", "created": "2016-04-13T09:12:12Z", "type": "feedback", "id": "imyn1uu6b1i3dc", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>杨明 2013011412 谢琛睿 2013011406</p>\n<p>在__panic函数里调用print_stackframe函数&#xff0c;在syscall.c/sys_putc系统调用中触发中断</p>\n<pre>static int\nsys_putc(uint32_t arg[]) {\n    int c = (int)arg[0];\n    cputchar(c);\n    panic(&#34;debug.\\n&#34;);\n    return 0;\n}</pre>\n<p>结果如下&#xff1a;</p>\n<pre>Ikernel panic at kern/syscall/syscall.c:58:\n    debug.\n\nebp:0xc03adec8 eip:0xc0101ea0 args:0x00000049 0xc0102f75 0x0000000a 0xc03adefc \n    kern/debug/kdebug.c:350: print_stackframe&#43;21\nebp:0xc03adee8 eip:0xc01017a3 args:0xc010eef4 0x0000003a 0xc010eeec 0x00000000 \n    kern/debug/panic.c:26: __panic&#43;93\nebp:0xc03adf18 eip:0xc010b9fa args:0xc03adf34 0xc03adf54 0xc0103ceb 0xc03adf60 \n    kern/syscall/syscall.c:0: sys_putc&#43;47\nebp:0xc03adf58 eip:0xc010ba81 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    kern/syscall/syscall.c:94: syscall&#43;116\nebp:0xc03adf78 eip:0xc0103b81 args:0xc03adfb4 0x00000000 0x00000023 0x00000023 \n    kern/trap/trap.c:216: trap_dispatch&#43;272\nebp:0xc03adfa8 eip:0xc0103ceb args:0xc03adfb4 0x00000049 0x00000000 0xaffffea8 \n    kern/trap/trap.c:287: trap&#43;80\nebp:0xaffffea8 eip:0xc01047b4 args:0x0000001e 0x00000049 0xaffffed8 0x00800251 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffeb8 eip:0x0080017d args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;12\nebp:0xaffffed8 eip:0x00800251 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x0080099d args:0x00800240 0xafffff3c 0x00801361 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;30\nebp:0xafffff48 eip:0x00800284 args:0x00801360 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;32\nebp:0xafffff78 eip:0x008002a7 args:0x00801360 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;26\nebp:0xafffffa8 eip:0x00800ef5 args:0x00000000 0x00000000 0x00000000 0x0080030b \n    user/exit.c:9: main&#43;29\nebp:0xafffffd8 eip:0x0080030b args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10\nWelcome to the kernel debug monitor!!</pre>\n<p></p>\n<p>我们发现trapentry.S的指令时&#xff0c;ebp仍旧处于用户态&#xff0c;原因应该是trapentry.S汇编代码中并更新ebp&#xff0c;就是硬件修改了ebp&#xff0c;但os之前push了原来的ebp到内核中并未修改&#xff0c;所以导致输出的ebp仍旧是用户态的ebp。</p>"}, {"folders": [], "updated": "2016-04-13T10:05:41Z", "uid": "i0zaci5voig5h", "created": "2016-04-13T10:05:41Z", "type": "feedback", "id": "imyoympww32xk", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2012011894 朱俸民 2013011411朱新瑞</p>\n<p>https://github.com/paulzfm/os_course_spoc_exercises/blob/master/lab5-SPOC-Milesian.md</p>"}, {"folders": [], "updated": "2016-04-13T10:06:53Z", "uid": "i6w84pnmjCQ", "created": "2016-04-13T10:06:53Z", "type": "feedback", "id": "imyp05vgpuh66i", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p><tt>我的理解, 那个在用户栈的ebp实际上是syscall函数的ebp. 因为int不会push ebp, __alltraps也没有push ebp, 所以__alltraps的ebp根本没在栈里存过, 因此没打印出来. 然后__alltraps用iret所以ebp不对也可以回去, 因此程序也不会跑飞. 实际上是那个打印的函数不能记录中断造成的栈的改变, 只能记录函数调用造成的栈的改变. 欢迎指正.</tt></p>\n<p></p>"}, {"folders": [], "updated": "2016-04-13T10:07:45Z", "uid": "i0c9nvk0xzc2n3", "created": "2016-04-13T10:07:45Z", "type": "feedback", "id": "imyp1ajbcua6qq", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011376 龚拓宇 2013011379 姚炫容</p>\n<p></p>\n<p>在kern/syscall/syscall.c 中的sys_fork中添加如下代码</p>\n<p></p>\n<pre>    print_stackframe();\n    panic(&#39;haha&#39;);</pre>\n<p><br />得到输出</p>\n<pre>ebp:0xc058aed8 eip:0xc0100acc args:0x00000000 0xc058af14 0xc0102a17 0x0000000a \n    kern/debug/kdebug.c:350: print_stackframe&#43;22\nebp:0xc058aef8 eip:0xc010b1c2 args:0xc058af24 0x0000000a 0x00000000 0x00000000 \n    kern/syscall/syscall.c:17: sys_fork&#43;10\nebp:0xc058af48 eip:0xc010b333 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    kern/syscall/syscall.c:96: syscall&#43;115\nebp:0xc058af78 eip:0xc0102a17 args:0xc058afb4 0x00000000 0x00800020 0x0000001b \n    kern/trap/trap.c:214: trap_dispatch&#43;294\nebp:0xc058afa8 eip:0xc0102b63 args:0xc058afb4 0x00000000 0xafffff68 0xaffffefc \n    kern/trap/trap.c:285: trap&#43;74\nebp:0xaffffefc eip:0xc0102bba args:0x00000002 0xafffff18 0x008002ea 0x008000cc \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xafffff08 eip:0x00800229 args:0x008000cc 0x00000000 0xafffff68 0x008010af \n    user/libs/syscall.c:40: sys_fork&#43;17\nebp:0xafffff18 eip:0x008002ea args:0xafffff5b 0x00000005 0x00801420 0x00801436 \n    user/libs/ulib.c:15: fork&#43;10\nebp:0xafffff68 eip:0x008010af args:0x00801436 0x00000030 0x00801436 0x00000000 \n    user/forktree.c:17: forkchild&#43;74\nebp:0xafffff88 eip:0x00801107 args:0x00801436 0x00000000 0x00000000 0x00000000 \n    user/forktree.c:28: forktree&#43;52\nebp:0xafffffa8 eip:0x00801131 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/forktree.c:34: main&#43;20\nebp:0xafffffd8 eip:0x00800367 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10</pre>\n<p>至于为什么trapentry的ebp仍在用户态&#xff0c;这是因为&#xff0c;从用户态程序调用syscall一直到trapentry&#xff0c;操作系统都没有机会修改ebp&#xff0c;此时的ebp仍是user/libs/syscall.c 中syscall函数的ebp&#xff08;注意&#xff0c;因为inline的缘故&#xff0c;所以少了一层栈帧&#xff09;&#xff0c;但是实际上&#xff0c;用户栈已经切换到了内核栈&#xff0c;此时的esp已经是内核栈了。</p>"}, {"folders": [], "updated": "2016-04-13T10:21:55Z", "uid": "i6vjwdpfniF", "created": "2016-04-13T10:21:55Z", "type": "feedback", "id": "imypjieb5y23sz", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2012012139 高博 2012011383 赵涵</p>\n<p></p>\n<p>kernel panic at kern/trap/trap.c:200:<br /> trap in user mode<br />ebp:0xc03adf18 eip:0xc0101f62 args:0xc010d89a 0xc03adf5c 0x000000c8 0x00000002 <br /> kern/debug/kdebug.c:350: print_stackframe&#43;21<br />ebp:0xc03adf48 eip:0xc01022b6 args:0xc010dc20 0x000000c8 0xc010dc48 0x00000000 <br /> kern/debug/panic.c:25: __panic&#43;93<br />ebp:0xc03adf78 eip:0xc0103c4a args:0xc03adfb4 0x00000000 0x00800020 0x0000001b <br /> kern/trap/trap.c:200: trap_dispatch&#43;55<br />ebp:0xc03adfa8 eip:0xc0103ede args:0xc03adfb4 0x00000049 0x00000000 0xaffffe98 <br /> kern/trap/trap.c:292: trap&#43;74<br />ebp:0xaffffe98 eip:0xc0103f33 args:0x0000001e 0x00000049 0xaffffec8 0x008000d6 <br /> kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0<br />ebp:0xaffffea8 eip:0x00800290 args:0x00000049 0x00000000 0x00000000 0x00000000 <br /> user/libs/syscall.c:65: sys_putc&#43;24<br />ebp:0xaffffec8 eip:0x008000d6 args:0x00000049 0xafffff3c 0x00000000 0x00000000 <br /> user/libs/stdio.c:11: cputch&#43;16<br />ebp:0xafffff18 eip:0x0080056b args:0x008000c5 0xafffff3c 0x008013e1 0xafffff84 <br /> libs/printfmt.c:131: vprintfmt&#43;33<br />ebp:0xafffff48 eip:0x00800113 args:0x008013e0 0xafffff84 0x00000000 0x00000000 <br /> user/libs/stdio.c:27: vcprintf&#43;45<br />ebp:0xafffff78 eip:0x00800136 args:0x008013e0 0x00000000 0x00000000 0x00000000 <br /> user/libs/stdio.c:42: cprintf&#43;29<br />ebp:0xafffffa8 eip:0x00800fa6 args:0x00000000 0x00000000 0x00000000 0x00000000 <br /> user/exit.c:9: main&#43;20<br />ebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000 <br /> user/libs/umain.c:7: umain&#43;10</p>\n<p></p>\n<p>在panic()里添加print_stackframe()<br />在syscall.c/sys_putc中断</p>"}, {"folders": [], "updated": "2016-04-13T10:43:30Z", "uid": "i28skba6cd976f", "created": "2016-04-13T10:43:30Z", "type": "feedback", "id": "imyqb9p9m0n32a", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>张殿炎 2013011328 叶方轲 2013011340</p>\n<p></p>\n<p>在kern/syscall/syscall.c 中的sys_fork中添加</p>\n<pre>print_stackframe();\n    panic(&#39;lovelive&#39;);</pre>\n<p></p>\n<p>得到如下结果&#xff1a;</p>\n<pre><br />ebp:0xc0369ed8 eip:0xc0100bd2 args:0x00000000 0x00000001 0xaffffe6c 0x00000001 <br />    kern/debug/kdebug.c:350: print_stackframe&#43;21<br />ebp:0xc0369ef8 eip:0xc010eb55 args:0xc0369f24 0x0000000a 0xc0369f80 0xffff6ad9 <br />    kern/syscall/syscall.c:22: sys_fork&#43;10<br />ebp:0xc0369f48 eip:0xc010eecb args:0xc0100360 0xc010030a 0xc0369fbc 0xc0102b16 <br />    kern/syscall/syscall.c:201: syscall&#43;117<br />ebp:0xc0369f78 eip:0xc01029b3 args:0xc0369fb4 0x00000000 0x00000000 0x00000023 <br />    kern/trap/trap.c:217: trap_dispatch&#43;299<br />ebp:0xc0369fa8 eip:0xc0102ac1 args:0xc0369fb4 0xafffff94 0xafffff94 0xafffff4c <br />    kern/trap/trap.c:298: trap&#43;74<br />ebp:0xafffff4c eip:0xc0102b16 args:0x00000002 0xafffff68 0x008008ca 0x00000000 <br />    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0<br />ebp:0xafffff58 eip:0x00800571 args:0x00000000 0xafffff94 0xafffff94 0x00801edd <br />    user/libs/syscall.c:43: sys_fork&#43;17<br />ebp:0xafffff68 eip:0x008008ca args:0x00802570 0x00802522 0x00000000 0x00000000 <br />    user/libs/ulib.c:30: fork&#43;10<br />ebp:0xafffff94 eip:0x00801edd args:0x00000001 0xaffffff8 0x00000001 0x00000000 <br />    user/sh.c:238: main&#43;143<br />ebp:0xafffffc4 eip:0x00800ab8 args:0x00000001 0xaffffff8 0x00000000 0x00000000 <br />    user/libs/umain.c:31: umain&#43;167<br /><br /></pre>\n<p></p>"}, {"folders": [], "updated": "2016-04-13T12:00:51Z", "uid": "i701mss708y", "created": "2016-04-13T12:00:51Z", "type": "feedback", "id": "imyt2q9cl1s5qb", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>陈伯乐 2012011302 &amp; 崔岩 2012011309</p>\n<p></p>\n<p>在panic函数里增加了print_stackframe调用&#xff0c;输出信息如下</p>\n<pre>Ikernel panic at kern/trap/trap.c:299:\n    lovelive\nebp:0xc0389f58 eip:0xc0100b4f args:0x00000000 0x00000000 0x00000000 0xc0389f8c \n    kern/debug/kdebug.c:352: print_stackframe&#43;21\nebp:0xc0389f78 eip:0xc010044b args:0xc010ba40 0x0000012b 0xc010bb53 0x00000023 \n    kern/debug/panic.c:28: __panic&#43;91\nebp:0xc0389fa8 eip:0xc0102ace args:0xc0389fb4 0x00000049 0x00000000 0xaffffea8 \n    kern/trap/trap.c:299: trap&#43;123\nebp:0xaffffea8 eip:0xc0103557 args:0x0000001e 0x00000049 0xaffffed8 0x00800254 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffeb8 eip:0x0080017e args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;12\nebp:0xaffffed8 eip:0x00800254 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x008009a2 args:0x00800243 0xafffff3c 0x00801321 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;29\nebp:0xafffff48 eip:0x00800288 args:0x00801320 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;32\nebp:0xafffff78 eip:0x008002ab args:0x00801320 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;26\nebp:0xafffffa8 eip:0x00800f00 args:0x00000000 0x00000000 0x00000000 0x0080030f \n    user/exit.c:9: main&#43;29\nebp:0xafffffd8 eip:0x0080030f args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10</pre>"}, {"folders": [], "updated": "2016-04-14T02:01:22Z", "uid": "ikvcvqz0jx17m1", "created": "2016-04-14T02:01:22Z", "type": "feedback", "id": "imzn3mxg4dr4zj", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>2012011333 俞寒轩</p>\n<p>2012011306 肖迪</p>\n<p></p>\n<p>如下为输出。</p>\n<pre>Ikernel panic at kern/trap/trap.c:291:\n    User Mode:\nebp:0xc03adf48 eip:0xc0101f62 args:0xc010d93a 0xc03adf8c 0x00000123 0x00000000 \n    kern/debug/kdebug.c:350: print_stackframe&#43;21\nebp:0xc03adf78 eip:0xc01022b6 args:0xc010dcc0 0x00000123 0xc010dde3 0x0000001b \n    kern/debug/panic.c:26: __panic&#43;93\nebp:0xc03adfa8 eip:0xc0103ee0 args:0xc03adfb4 0x00000049 0x00000000 0xaffffe98 \n    kern/trap/trap.c:291: trap&#43;119\nebp:0xaffffe98 eip:0xc0103ef8 args:0x0000001e 0x00000049 0xaffffec8 0x008000d6 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffea8 eip:0x00800290 args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;24\nebp:0xaffffec8 eip:0x008000d6 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x0080056b args:0x008000c5 0xafffff3c 0x008013e1 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;33\nebp:0xafffff48 eip:0x00800113 args:0x008013e0 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;45\nebp:0xafffff78 eip:0x00800136 args:0x008013e0 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;29\nebp:0xafffffa8 eip:0x00800fa6 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/exit.c:9: main&#43;20\nebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10</pre>\n<p>在__panic函数中添加print_stackframe()&#xff0c;并将trap.c的trap函数修改为</p>\n<pre>if (!in_kernel) {\n    panic(&#34;User Mode:&#34;);\n    if (current-&gt;flags &amp; PF_EXITING) {\n        do_exit(-E_KILLED);\n    }\n    if (current-&gt;need_resched) {\n        schedule();\n    }\n}</pre>\n<p>从下往上不难看出调用顺序&#xff0c;cputch调用了syscall的接口&#xff0c;然后进入到中断处理程序中再输出。</p>"}, {"folders": [], "updated": "2016-04-14T05:18:56Z", "uid": "i0ccqbaxwdz75c", "created": "2016-04-14T05:18:56Z", "type": "feedback", "id": "imzu5pyv3sq6k6", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>何乐 2013011351 郭栋 2013011334</p>\n<p>在panic.c中的__panic函数中调用print_stackframe()输出堆栈信息&#xff0c;在syscall.c的sys_putc()中人为触发panic&#xff0c;结果如下&#xff1a;</p>\n<pre>Ikernel panic at kern/syscall/syscall.c:58:<br />    2013011334 2013011351<br /><br />ebp:0xc03ade98 eip:0xc0101f62 args:0xc010d97a 0xc03adedc 0x0000003a 0xc010180d <br />    kern/debug/kdebug.c:350: print_stackframe&#43;21<br />ebp:0xc03adec8 eip:0xc01022b6 args:0xc010fc43 0x0000003a 0xc010fc2c 0x00000000 <br />    kern/debug/panic.c:26: __panic&#43;93<br />ebp:0xc03adef8 eip:0xc010c714 args:0xc03adf24 0x0000000a 0x00000000 0x00000000 <br />    kern/syscall/syscall.c:0: sys_putc&#43;52<br />ebp:0xc03adf48 eip:0xc010c79a args:0x00000000 0x00000000 0x00000000 0x00000000 <br />    kern/syscall/syscall.c:94: syscall&#43;115<br />ebp:0xc03adf78 eip:0xc0103d3e args:0xc03adfb4 0x00000000 0x00800020 0x0000001b <br />    kern/trap/trap.c:216: trap_dispatch&#43;299<br />ebp:0xc03adfa8 eip:0xc0103eb3 args:0xc03adfb4 0x00000049 0x00000000 0xaffffe98 <br />    kern/trap/trap.c:287: trap&#43;74<br />ebp:0xaffffe98 eip:0xc0103f08 args:0x0000001e 0x00000049 0xaffffec8 0x008000d6 <br />    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0<br />ebp:0xaffffea8 eip:0x00800290 args:0x00000049 0x00000000 0x00000000 0x00000000 <br />    user/libs/syscall.c:65: sys_putc&#43;24<br />ebp:0xaffffec8 eip:0x008000d6 args:0x00000049 0xafffff3c 0x00000000 0x00000000 <br />    user/libs/stdio.c:11: cputch&#43;16<br />ebp:0xafffff18 eip:0x0080056b args:0x008000c5 0xafffff3c 0x008013e1 0xafffff84 <br />    libs/printfmt.c:131: vprintfmt&#43;33<br />ebp:0xafffff48 eip:0x00800113 args:0x008013e0 0xafffff84 0x00000000 0x00000000 <br />    user/libs/stdio.c:27: vcprintf&#43;45<br />ebp:0xafffff78 eip:0x00800136 args:0x008013e0 0x00000000 0x00000000 0x00000000 <br />    user/libs/stdio.c:42: cprintf&#43;29<br />ebp:0xafffffa8 eip:0x00800fa6 args:0x00000000 0x00000000 0x00000000 0x00000000 <br />    user/exit.c:9: main&#43;20<br />ebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000 <br />    user/libs/umain.c:7: umain&#43;10<br />Welcome to the kernel debug monitor!!<br />Type &#39;help&#39; for a list of commands.</pre>\n<p>从中可以看出是在trapentry.S处发生了堆栈的切换</p>"}, {"folders": [], "updated": "2016-04-14T06:37:30Z", "uid": "i3qk2vs65x276j", "created": "2016-04-14T06:37:30Z", "type": "feedback", "id": "imzwyrhl2vj2er", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>在trap_dispatch()中加入&#xff1a;</p>\n<p>if(!trap_in_kernel(tf)){</p>\n<p>    panic(&#34;trap in user mode.\\n&#34;);</p>\n<p>}</p>\n<p>在__panic()中加入&#xff1a;</p>\n<p>print_stackframe();</p>\n<p>结果如下&#xff1a;</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i3qk2vs65x276j/imzww2c78vzh/1.png\" /></p>"}, {"folders": [], "updated": "2016-04-14T11:29:01Z", "uid": "ikvcvnzpzq7j7", "created": "2016-04-14T11:29:01Z", "type": "feedback", "id": "in07dn0d3ww3bt", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>甄显安 2012080060</p>\n<p>陆喆 2012011308</p>\n<pre>在__panic()中加入&#xff1a;print_stackframe();\n在kern/syscall/syscall.c的sys_fork()中加入&#xff1a;panic(&#34;== fork ==&#34;);</pre>\n<p>输出结果&#xff1a;</p>\n<pre>I am the parent. Forking the child...<br />ebp:0xc03acec8 eip:0xc0101ebc args:0x0000000a 0xc0102fa2 0x0000000a 0xc03acefc <br />    kern/debug/kdebug.c:350: print_stackframe&#43;21<br />ebp:0xc03acee8 eip:0xc0101780 args:0xc010ef3b 0x00000013 0xc010ef2c 0x00000000 <br />    kern/debug/panic.c:22: __panic&#43;35<br />ebp:0xc03acf18 eip:0xc010b9c4 args:0xc03acf34 0xc03acf54 0xc0103d2e 0xc03acf60 <br />    kern/syscall/syscall.c:0: sys_fork&#43;45<br />ebp:0xc03acf58 eip:0xc010bb24 args:0x00000000 0x00000000 0x00000000 0x00000000 <br />    kern/syscall/syscall.c:95: syscall&#43;116<br />ebp:0xc03acf78 eip:0xc0103bbe args:0xc03acfb4 0x00000000 0x00000023 0x00000023 <br />    kern/trap/trap.c:216: trap_dispatch&#43;271<br />ebp:0xc03acfa8 eip:0xc0103d2e args:0xc03acfb4 0x00000000 0xafffffa8 0xafffff6c <br />    kern/trap/trap.c:287: trap&#43;80<br />ebp:0xafffff6c eip:0xc01047f8 args:0x00000002 0xafffff88 0x008001c3 0x00801320 <br />    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0<br />ebp:0xafffff78 eip:0x00800127 args:0x00801320 0x00000000 0xafffffa8 0x00800f08 <br />    user/libs/syscall.c:40: sys_fork&#43;9<br />ebp:0xafffff88 eip:0x008001c3 args:0x00000000 0x00000000 0x00000000 0x00000000 <br />    user/libs/ulib.c:15: fork&#43;10<br />ebp:0xafffffa8 eip:0x00800f08 args:0x00000000 0x00000000 0x00000000 0x0080030f <br />    user/exit.c:10: main&#43;37<br />ebp:0xafffffd8 eip:0x0080030f args:0x00000000 0x00000000 0x00000000 0x00000000 <br />    user/libs/umain.c:7: umain&#43;10<br />kernel panic at kern/syscall/syscall.c:19:<br />==fork==</pre>\n<p></p>"}, {"folders": [], "updated": "2016-04-14T11:48:22Z", "uid": "i11v1az5sf83l2", "created": "2016-04-14T11:48:22Z", "type": "feedback", "id": "in082j6fc5t7hd", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>2013011310 余翔</p>\n<p>2013011308 林婕茵</p>\n<p>在panic中添加print_stackframe函数&#xff0c;并在在fork()中手动触发</p>\n<pre>kernel panic at kern/syscall/syscall.c:58:\nebp:0xc03acec8 eip:0xc0101ecc args:0x00000049 0xc0102fb2 0x0000000a 0xc03acefc \n    kern/debug/kdebug.c:350: print_stackframe&#43;21\nebp:0xc03acee8 eip:0xc01017cb args:0xc010ef54 0x0000003a 0xc010ef4c 0x00000000 \n    kern/debug/panic.c:30: __panic&#43;110\nebp:0xc03acf18 eip:0xc010baad args:0xc03acf34 0xc03acf54 0xc0103d3e 0xc03acf60 \n    kern/syscall/syscall.c:0: sys_putc&#43;46\nebp:0xc03acf58 eip:0xc010bb34 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    kern/syscall/syscall.c:94: syscall&#43;116\nebp:0xc03acf78 eip:0xc0103bce args:0xc03acfb4 0x00000000 0x00000023 0x00000023 \n    kern/trap/trap.c:217: trap_dispatch&#43;271\nebp:0xc03acfa8 eip:0xc0103d3e args:0xc03acfb4 0x00000049 0x00000000 0xaffffea8 \n    kern/trap/trap.c:288: trap&#43;80\nebp:0xaffffea8 eip:0xc0104808 args:0x0000001e 0x00000049 0xaffffed8 0x00800254 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffeb8 eip:0x0080017e args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;12\nebp:0xaffffed8 eip:0x00800254 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x008009a2 args:0x00800243 0xafffff3c 0x00801321 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;29\nebp:0xafffff48 eip:0x00800288 args:0x00801320 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;32\nebp:0xafffff78 eip:0x008002ab args:0x00801320 0x00000000 0x00000000 0x00000000 \n    user/libs/</pre>"}], "subject": "<p>基础题目&#xff1a;</p>\n<p></p>\n<p>(0)-14.2(2):尝试在panic函数中获取并输出用户栈和内核栈的函数嵌套信息&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>选择“(0)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-13T03:26:12Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-13T03:26:12Z", "type": "followup", "no_answer": 0, "id": "imyaovq3ulo33r", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2016-04-13T09:09:29Z", "uid": "i6ub4vwhQXd", "created": "2016-04-13T09:09:29Z", "type": "feedback", "id": "imymycnhlwc1xg", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>徐捷 2012011371&#xff0c;赖国堃 2012011372</p>\n<p>修改kern/debug/panic.c&#xff0c;输出触发panic时的页表信息&#xff0c;并在schedule中触发panic</p>\n<p><a href=\"https://github.com/EternalAnswer/os_course_spoc_exercises/tree/master/all/05-4-lab5\" target=\"_blank\">code</a></p>\n<p></p>\n<p>输出结果为&#xff1a;</p>\n<pre>-------------------- BEGIN --------------------\nPDE(001) 00000000-00400000 00400000 urw\n  |-- PTE(00004) 00200000-00204000 00004000 urw\nPDE(001) 00800000-00c00000 00400000 urw\n  |-- PTE(00002) 00800000-00802000 00002000 ur-\n  |-- PTE(00001) 00802000-00803000 00001000 urw\nPDE(001) afc00000-b0000000 00400000 urw\n  |-- PTE(00004) afffc000-b0000000 00004000 urw\nPDE(0e0) c0000000-f8000000 38000000 urw\n  |-- PTE(38000) c0000000-f8000000 38000000 -rw\nPDE(001) fac00000-fb000000 00400000 -rw\n  |-- PTE(00001) fac00000-fac01000 00001000 urw\n  |-- PTE(00001) fac02000-fac03000 00001000 urw\n  |-- PTE(00001) faebf000-faec0000 00001000 urw\n  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw\n  |-- PTE(00001) fafeb000-fafec000 00001000 -rw\n--------------------- END ---------------------</pre>\n<p></p>"}, {"folders": [], "updated": "2016-04-13T09:10:23Z", "uid": "i0gl5kctugw3xi", "created": "2016-04-13T09:10:23Z", "type": "feedback", "id": "imymzi6750n1kt", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>代码的修改方式为&#xff1a;</p>\n<p>在trap()函数中增加&#xff1a;</p>\n<pre>if (tf-&gt;tf_cs != KERNEL_CS) {\n    panic(&#34;Panic in Trap \\n&#34;);\n}</pre>\n<p>触发panic。</p>\n<p></p>\n<p>在panic.c中的__panic()函数中增加&#xff1a;</p>\n<pre>print_stackframe();\nprint_pgdir();</pre>\n<p>即可打印需要的所有结果。</p>\n<p></p>\n<p>输出的堆栈和页表信息如下&#xff1a;</p>\n<pre>ebp:0xc03adf48 eip:0xc0101f62 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    kern/debug/kdebug.c:350: print_stackframe&#43;21\nebp:0xc03adf78 eip:0xc0102278 args:0xc010dd00 0x00000120 0xc010de23 0x0000001b \n    kern/debug/panic.c:21: __panic&#43;31\nebp:0xc03adfa8 eip:0xc0103ed9 args:0xc03adfb4 0x00000049 0x00000000 0xaffffe98 \n    kern/trap/trap.c:288: trap&#43;107\nebp:0xaffffe98 eip:0xc0103f39 args:0x0000001e 0x00000049 0xaffffec8 0x008000d6 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffea8 eip:0x00800290 args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;24\nebp:0xaffffec8 eip:0x008000d6 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x0080056b args:0x008000c5 0xafffff3c 0x008013e1 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;33\nebp:0xafffff48 eip:0x00800113 args:0x008013e0 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;45\nebp:0xafffff78 eip:0x00800136 args:0x008013e0 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;29\nebp:0xafffffa8 eip:0x00800fa6 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/exit.c:9: main&#43;20\nebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10\n-------------------- BEGIN --------------------\nPDE(001) 00000000-00400000 00400000 urw\n  |-- PTE(00004) 00200000-00204000 00004000 urw\nPDE(001) 00800000-00c00000 00400000 urw\n  |-- PTE(00002) 00800000-00802000 00002000 ur-\n  |-- PTE(00001) 00802000-00803000 00001000 urw\nPDE(001) afc00000-b0000000 00400000 urw\n  |-- PTE(00004) afffc000-b0000000 00004000 urw\nPDE(0e0) c0000000-f8000000 38000000 urw\n  |-- PTE(38000) c0000000-f8000000 38000000 -rw\nPDE(001) fac00000-fb000000 00400000 -rw\n  |-- PTE(00001) fac00000-fac01000 00001000 urw\n  |-- PTE(00001) fac02000-fac03000 00001000 urw\n  |-- PTE(00001) faebf000-faec0000 00001000 urw\n  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw\n  |-- PTE(00001) fafeb000-fafec000 00001000 -rw\n--------------------- END ---------------------</pre>\n<p>阅读页面情况的时候注意&#xff0c;括号中的是这个区域中的单元数&#xff08;PTE是页&#xff0c;PDE一个单元则是一张页表的空间&#xff0c;也就是1024页&#xff09;</p>\n<p>后面则是虚拟地址区间和大小。urw为该页权限。</p>\n<p>从上面的页表信息中&#xff0c;我们可以看到&#xff1a;</p>\n<p>&#xff08;1&#xff09;0x00200000以上的用户态调试信息区域&#xff08;STAB&#xff09;&#xff1b;</p>\n<p>&#xff08;2&#xff09;0x00800000以上的用户程序、堆区域&#xff1b;</p>\n<p>&#xff08;3&#xff09;0xB0000000以下的用户栈区&#xff1b;</p>\n<p>&#xff08;4&#xff09;0xC0000000以上的内核态使用的区域&#xff1b;</p>\n<p>&#xff08;5&#xff09;0xFAC00000以上的页表区域&#xff1b;</p>\n<p></p>\n<p>最后&#xff0c;关于课上争论的为什么trapentry的ebp仍然在用户态的问题&#xff0c;个人认为并不难理解。ebp的值并非是硬件管理的&#xff0c;而全是软件做的。在写函数的汇编代码时&#xff0c;我们总是先写下面的代码管理ebp&#xff1a;</p>\n<pre>push %ebp\nmov %esp, %ebp</pre>\n<p>如果没有这两行代码&#xff0c;ebp将保持之前的不变。所以这里trapentry的ebp的值还是在用户态。</p>\n<p>即&#xff0c;只是eip从syscall函数变过来了&#xff0c;栈帧的基址却没有变&#xff08;即便此时栈本身都发生了变化&#xff09;。</p>\n<p>&#xff08;正因为eip变了&#xff0c;所以打印函数名时打的是trapentry&#xff09;</p>\n<p></p>\n<p>其他的输出&#xff0c;对于C的函数&#xff0c;编译时会自动加上ebp的管理&#xff0c;所以输出结果是正确的。</p>"}, {"folders": [], "updated": "2016-04-13T09:42:46Z", "uid": "i1bzj2xilgm4uk", "created": "2016-04-13T09:42:46Z", "type": "feedback", "id": "imyo55sr6gm77d", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2013011355徐涵2013011339白家松</p>\n<p>在sched.c中加入</p>\n<pre>if (next != current) {\n\t proc_run(next);\n\tpanic(&#34;2013011355_2013011339\\n&#34;);\n}</pre>\n<p>在panic.c中加入代码&#xff1a;</p>\n<pre>cprintf(&#34;kernel panic at %s:%d:\\n    &#34;, file, line);\nprint_pgdir();    \nvcprintf(fmt, ap);</pre>\n<p>输出结果为&#xff1a;</p>\n<pre>    -------------------- BEGIN --------------------\nPDE(001) 00000000-00400000 00400000 urw\n  |-- PTE(00004) 00200000-00204000 00004000 urw\nPDE(001) 00800000-00c00000 00400000 urw\n  |-- PTE(00002) 00800000-00802000 00002000 ur-\n  |-- PTE(00001) 00802000-00803000 00001000 urw\nPDE(001) afc00000-b0000000 00400000 urw\n  |-- PTE(00004) afffc000-b0000000 00004000 urw\nPDE(0e0) c0000000-f8000000 38000000 urw\n  |-- PTE(38000) c0000000-f8000000 38000000 -rw\nPDE(001) fac00000-fb000000 00400000 -rw\n  |-- PTE(00001) fac00000-fac01000 00001000 urw\n  |-- PTE(00001) fac02000-fac03000 00001000 urw\n  |-- PTE(00001) faebf000-faec0000 00001000 urw\n  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw\n  |-- PTE(00001) fafeb000-fafec000 00001000 -rw\n--------------------- END ---------------------\n2013011355_2013011339</pre>\n<p></p>"}, {"folders": [], "updated": "2016-04-14T11:14:31Z", "uid": "i21zpwab2z775p", "created": "2016-04-14T11:14:31Z", "type": "feedback", "id": "in06v09wmce1f", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>马志明 2013011395  王启圣 2013011409</p>\n<p>在trap.c中的trap_dispatch函数一开始增加如下语句</p>\n<pre>if(tf-&gt;tf_cs != KERNEL_CS) {\n    \tprint_pgdir();\n    \tpanic(&#34;panic in trap_dispatch\\n&#34;);\n    }</pre>\n<p>输出结果如下</p>\n<pre>-------------------- BEGIN --------------------\nPDE(001) 00000000-00400000 00400000 urw\n  |-- PTE(00004) 00200000-00204000 00004000 urw\nPDE(001) 00800000-00c00000 00400000 urw\n  |-- PTE(00002) 00800000-00802000 00002000 ur-\n  |-- PTE(00001) 00802000-00803000 00001000 urw\nPDE(001) afc00000-b0000000 00400000 urw\n  |-- PTE(00004) afffc000-b0000000 00004000 urw\nPDE(0e0) c0000000-f8000000 38000000 urw\n  |-- PTE(38000) c0000000-f8000000 38000000 -rw\nPDE(001) fac00000-fb000000 00400000 -rw\n  |-- PTE(00001) fac00000-fac01000 00001000 urw\n  |-- PTE(00001) fac02000-fac03000 00001000 urw\n  |-- PTE(00001) faebf000-faec0000 00001000 urw\n  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw\n  |-- PTE(00001) fafeb000-fafec000 00001000 -rw\n--------------------- END ---------------------\nkernel panic at kern/trap/trap.c:200:\n    panic in trap_dispatch</pre>\n<p></p>"}, {"folders": [], "updated": "2016-04-14T11:24:21Z", "uid": "i6vir34gLfK", "created": "2016-04-14T11:24:21Z", "type": "feedback", "id": "in077n91snlsa", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2012011321 章晔</p>\n<p>2012080059 金嘉宇</p>\n<p></p>\n<p>在sched.c中加入</p>\n<pre>if (next != current) {\n\t proc_run(next);\n\tpanic(&#34;Panic!\\n&#34;);\n}</pre>\n<p>在panic.c中加入代码&#xff1a;</p>\n<pre>cprintf(&#34;kernel panic at %s:%d:\\n    &#34;, file, line);\nprint_pgdir();    \nvcprintf(fmt, ap);</pre>\n<p>输出结果为&#xff1a;</p>\n<pre>    -------------------- BEGIN --------------------\nPDE(001) 00000000-00400000 00400000 urw\n  |-- PTE(00004) 00200000-00204000 00004000 urw\nPDE(001) 00800000-00c00000 00400000 urw\n  |-- PTE(00002) 00800000-00802000 00002000 ur-\n  |-- PTE(00001) 00802000-00803000 00001000 urw\nPDE(001) afc00000-b0000000 00400000 urw\n  |-- PTE(00004) afffc000-b0000000 00004000 urw\nPDE(0e0) c0000000-f8000000 38000000 urw\n  |-- PTE(38000) c0000000-f8000000 38000000 -rw\nPDE(001) fac00000-fb000000 00400000 -rw\n  |-- PTE(00001) fac00000-fac01000 00001000 urw\n  |-- PTE(00001) fac02000-fac03000 00001000 urw\n  |-- PTE(00001) faebf000-faec0000 00001000 urw\n  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw\n  |-- PTE(00001) fafeb000-fafec000 00001000 -rw\n--------------------- END ---------------------</pre>"}, {"folders": [], "updated": "2016-04-14T11:25:30Z", "uid": "ikx8y1dzPrM", "created": "2016-04-14T11:25:30Z", "type": "feedback", "id": "in07945d8m12om", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>krajna 2014010527</p>\n<p></p>\n<p>在shcedule中调用panic()打印当前进程的虚拟内存布局。</p>\n<p></p>\n<p>在panic.c文件中添加代码</p>\n<p>print_pgdir();</p>\n<p> </p>\n<p>运行结果如下。</p>\n<p>A PANIC IN SCHEDULE.<br />&#43;&#43;&#43;&#43;&#43;&#43;&#43;memory_information&#43;&#43;&#43;&#43;&#43;&#43;&#43;&#43;<br />-------------------- BEGIN --------------------<br />PDE(001) 00000000-00400000 00400000 urw<br /> |-- PTE(00004) 00200000-00204000 00004000 urw<br />PDE(001) 00800000-00c00000 00400000 urw<br /> |-- PTE(00002) 00800000-00802000 00002000 ur-<br /> |-- PTE(00001) 00802000-00803000 00001000 urw<br />PDE(001) afc00000-b0000000 00400000 urw<br /> |-- PTE(00004) afffc000-b0000000 00004000 urw<br />PDE(0e0) c0000000-f8000000 38000000 urw<br /> |-- PTE(38000) c0000000-f8000000 38000000 -rw<br />PDE(001) fac00000-fb000000 00400000 -rw<br /> |-- PTE(00001) fac00000-fac01000 00001000 urw<br /> |-- PTE(00001) fac02000-fac03000 00001000 urw<br /> |-- PTE(00001) faebf000-faec0000 00001000 urw<br /> |-- PTE(000e0) faf00000-fafe0000 000e0000 urw<br /> |-- PTE(00001) fafeb000-fafec000 00001000 -rw<br />--------------------- END ---------------------</p>"}, {"folders": [], "updated": "2016-04-14T11:41:05Z", "uid": "i1569mw0xp954u", "created": "2016-04-14T11:41:05Z", "type": "feedback", "id": "in07t66n6905xs", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>程凯 2013011303</p>\n<p>张明钊 2013012212</p>\n<pre>在trap()里添加&#xff1a;\nif (tf-&gt;tf_cs != KERNEL_CS) {\n    panic(&#34;Panic in Trap \\n&#34;);\n}\n\n在panic()里添加&#xff1a;\nprint_stackframe();\nprint_pgdir();\n\n输出&#xff1a;\nebp:0xc03adf48 eip:0xc0101f62 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    kern/debug/kdebug.c:350: print_stackframe&#43;21\nebp:0xc03adf78 eip:0xc0102278 args:0xc010dd00 0x00000120 0xc010de23 0x0000001b \n    kern/debug/panic.c:21: __panic&#43;31\nebp:0xc03adfa8 eip:0xc0103ed9 args:0xc03adfb4 0x00000049 0x00000000 0xaffffe98 \n    kern/trap/trap.c:288: trap&#43;107\nebp:0xaffffe98 eip:0xc0103f39 args:0x0000001e 0x00000049 0xaffffec8 0x008000d6 \n    kern/trap/trapentry.S:24: &lt;unknown&gt;&#43;0\nebp:0xaffffea8 eip:0x00800290 args:0x00000049 0x00000000 0x00000000 0x00000000 \n    user/libs/syscall.c:65: sys_putc&#43;24\nebp:0xaffffec8 eip:0x008000d6 args:0x00000049 0xafffff3c 0x00000000 0x00000000 \n    user/libs/stdio.c:11: cputch&#43;16\nebp:0xafffff18 eip:0x0080056b args:0x008000c5 0xafffff3c 0x008013e1 0xafffff84 \n    libs/printfmt.c:131: vprintfmt&#43;33\nebp:0xafffff48 eip:0x00800113 args:0x008013e0 0xafffff84 0x00000000 0x00000000 \n    user/libs/stdio.c:27: vcprintf&#43;45\nebp:0xafffff78 eip:0x00800136 args:0x008013e0 0x00000000 0x00000000 0x00000000 \n    user/libs/stdio.c:42: cprintf&#43;29\nebp:0xafffffa8 eip:0x00800fa6 args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/exit.c:9: main&#43;20\nebp:0xafffffd8 eip:0x0080034d args:0x00000000 0x00000000 0x00000000 0x00000000 \n    user/libs/umain.c:7: umain&#43;10\n-------------------- BEGIN --------------------\nPDE(001) 00000000-00400000 00400000 urw\n  |-- PTE(00004) 00200000-00204000 00004000 urw\nPDE(001) 00800000-00c00000 00400000 urw\n  |-- PTE(00002) 00800000-00802000 00002000 ur-\n  |-- PTE(00001) 00802000-00803000 00001000 urw\nPDE(001) afc00000-b0000000 00400000 urw\n  |-- PTE(00004) afffc000-b0000000 00004000 urw\nPDE(0e0) c0000000-f8000000 38000000 urw\n  |-- PTE(38000) c0000000-f8000000 38000000 -rw\nPDE(001) fac00000-fb000000 00400000 -rw\n  |-- PTE(00001) fac00000-fac01000 00001000 urw\n  |-- PTE(00001) fac02000-fac03000 00001000 urw\n  |-- PTE(00001) faebf000-faec0000 00001000 urw\n  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw\n  |-- PTE(00001) fafeb000-fafec000 00001000 -rw\n--------------------- END ---------------------</pre>"}, {"folders": [], "updated": "2016-04-14T11:42:29Z", "uid": "i2olyyl8swl1we", "created": "2016-04-14T11:42:29Z", "type": "feedback", "id": "in07uz1njxn5xb", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>黎文杰2013011353 曹科垒2013011345</p>\n<p>在sched.c中加入</p>\n<pre>if (next != current) {\n\tproc_run(next);\n\tpanic(&#34;panic\\n&#34;);\n}</pre>\n<p>在panic.c中加入代码&#xff1a;</p>\n<pre>cprintf(&#34;kernel panic at %s:%d:\\n    &#34;, file, line);\nprint_pgdir();    \nvcprintf(fmt, ap);</pre>\n<p>输出结果为&#xff1a;</p>\n<pre>    -------------------- BEGIN --------------------\nPDE(001) 00000000-00400000 00400000 urw\n  |-- PTE(00004) 00200000-00204000 00004000 urw\nPDE(001) 00800000-00c00000 00400000 urw\n  |-- PTE(00002) 00800000-00802000 00002000 ur-\n  |-- PTE(00001) 00802000-00803000 00001000 urw\nPDE(001) afc00000-b0000000 00400000 urw\n  |-- PTE(00004) afffc000-b0000000 00004000 urw\nPDE(0e0) c0000000-f8000000 38000000 urw\n  |-- PTE(38000) c0000000-f8000000 38000000 -rw\nPDE(001) fac00000-fb000000 00400000 -rw\n  |-- PTE(00001) fac00000-fac01000 00001000 urw\n  |-- PTE(00001) fac02000-fac03000 00001000 urw\n  |-- PTE(00001) faebf000-faec0000 00001000 urw\n  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw\n  |-- PTE(00001) fafeb000-fafec000 00001000 -rw\n--------------------- END ---------------------\n</pre>"}, {"folders": [], "updated": "2016-04-14T12:41:22Z", "uid": "i0evrfcnckf5dt", "created": "2016-04-14T12:41:22Z", "type": "feedback", "id": "in09yosvikr5xe", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p><pre>在trap()里添加&#xff1a;\nif (tf-&gt;tf_cs != KERNEL_CS) {\n    panic(&#34;Panic in Trap \\n&#34;);\n}\n\n在panic()里添加&#xff1a;\nprint_stackframe();\nprint_pgdir();</pre>\n<p>输出结果为&#xff1a;</p>\n<pre>    -------------------- BEGIN --------------------\nPDE(001) 00000000-00400000 00400000 urw\n  |-- PTE(00004) 00200000-00204000 00004000 urw\nPDE(001) 00800000-00c00000 00400000 urw\n  |-- PTE(00002) 00800000-00802000 00002000 ur-\n  |-- PTE(00001) 00802000-00803000 00001000 urw\nPDE(001) afc00000-b0000000 00400000 urw\n  |-- PTE(00004) afffc000-b0000000 00004000 urw\nPDE(0e0) c0000000-f8000000 38000000 urw\n  |-- PTE(38000) c0000000-f8000000 38000000 -rw\nPDE(001) fac00000-fb000000 00400000 -rw\n  |-- PTE(00001) fac00000-fac01000 00001000 urw\n  |-- PTE(00001) fac02000-fac03000 00001000 urw\n  |-- PTE(00001) faebf000-faec0000 00001000 urw\n  |-- PTE(000e0) faf00000-fafe0000 000e0000 urw\n  |-- PTE(00001) fafeb000-fafec000 00001000 -rw\n--------------------- END ---------------------</pre>"}], "subject": "<p>基础题目&#xff1a;</p>\n<p></p>\n<p>(1)-14.2(3):尝试在panic函数中获取和输出页表有效逻辑地址空间范围和在内存中的逻辑地址空间范围&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>选择“(1)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-13T03:26:42Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-13T03:26:42Z", "type": "followup", "no_answer": 0, "id": "imyapj5ildqmz", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [{"folders": [], "updated": "2016-04-13T09:16:31Z", "uid": "i6w84pnmjCQ", "created": "2016-04-13T09:16:31Z", "type": "feedback", "id": "imyn7ebtwqf5l5", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>代码:</p>\n<p><a href=\"http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab5_result/kern/process/proc.c\">http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab5_result/kern/process/proc.c</a></p>\n<p><a href=\"http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab5_result/kern/schedule/sched.c\">http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab5_result/kern/schedule/sched.c</a></p>\n<p></p>\n<p>报告:</p>\n<p><a href=\"http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab5_result/lab5-spoc.md\">http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab5_result/lab5-spoc.md</a></p>\n<p></p>\n<p>王智默 2012011355</p>\n<p>高越 2012011379</p>\n<p></p>"}, {"folders": [], "updated": "2016-04-13T11:18:28Z", "uid": "i0c1nsm3911wc", "created": "2016-04-13T11:18:28Z", "type": "feedback", "id": "imyrk7w6uakvq", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p>2012011894 朱俸民 2013011411朱新瑞</p>\n<p></p>\n<p>报告见&#xff1a;<a href=\"https://github.com/paulzfm/ucore-os-lab/blob/challenge/related_info/lab5/lab5-spoc-discuss/report.md\" target=\"_blank\">Github仓库</a></p>\n<p></p>"}, {"folders": [], "updated": "2016-04-13T12:15:24Z", "uid": "ic226rac4j5jw", "created": "2016-04-13T12:15:24Z", "type": "feedback", "id": "imytlfowk6s3y", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>高博</p>\n<p>2012012139</p>\n<p></p>\n<p><a href=\"https://github.com/gaobo1993/os_course_spoc_exercises/tree/master/all/lab5-spoc-discuss\">Code</a></p>\n<p><a href=\"https://github.com/gaobo1993/os_course_spoc_exercises/blob/master/all/lab5-spoc-discuss/Report.md\" target=\"_blank\">Report</a></p>\n<p></p>"}, {"folders": [], "updated": "2016-04-13T13:06:15Z", "uid": "i242q8ug7vw40x", "created": "2016-04-13T13:06:15Z", "type": "feedback", "id": "imyveubv5kh2e3", "anon": "no", "bucket_name": "Last week", "config": {}, "bucket_order": 5, "data": null, "children": [], "subject": "<p></p>\n<p>2013011356 董豪宇</p>\n<p>2013011302 李奕昕</p>\n<p></p>\n<p>用户态程序 修改了exit</p>\n<p><a href=\"https://github.com/donghy/os_exercise/blob/master/lec14_ex_user_code.md\" target=\"_blank\">https://github.com/donghy/os_exercise/blob/master/lec14_ex_user_code.md</a></p>\n<p></p>\n<p>其他地方也加了输出, 但太杂, 不一一列出, 只给出执行输出</p>\n<p><a href=\"https://github.com/donghy/os_exercise/blob/master/lec14_ex_output.md\" target=\"_blank\">https://github.com/donghy/os_exercise/blob/master/lec14_ex_output.md</a></p>\n<p></p>\n<p>报告</p>\n<p><a href=\"https://github.com/donghy/os_exercise/blob/master/lec14_ex_report.md\" target=\"_blank\">https://github.com/donghy/os_exercise/blob/master/lec14_ex_report.md</a></p>"}], "subject": "<p>较难题目&#xff1a;</p>\n<p></p>\n<p>题目&#xff1a;增加一个用户进程A&#xff0c;在ucore运行过程中通过cprintf函数来完整地展现出来进程A相关的动态执行和内部数据/状态变化的细节。</p>\n<p></p>\n<p>选择“较难题目”的同学的回答结果写在此贴后面。</p>"}], "nr": 795, "bucket_order": 2, "config": {}, "status": "active", "tags": ["instructor-note", "lecture14", "课堂问答"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-04-13T03:25:25Z", "is_tag_good": false, "type": "note", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1461166258971, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>请向勇班的同学把“第十四讲 实验五 用户进程管理”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#lab5-spoc-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#lab5-spoc-思考题</a></p>\n<p><br />第十四讲的回答的截止时间是明天&#xff08;20160414&#xff09;晚20点前。<br /> <br />要求&#xff1a;每个依据自己对课程内容的掌握情况&#xff0c;选择做“基础题目”或“较难题目”。不需要两种选择都做。</p>\n<p></p>\n<p>1. 基础题目&#xff1a;有2个“个人思考题”&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除2后的余数&#xff0c;完成与余数相同的题目&#xff0c;独立回答。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#142-进程的内存布局\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#142-进程的内存布局</a></p>\n<p></p>\n<p>(0)-14.2(2):尝试在panic函数中获取并输出用户栈和内核栈的函数嵌套信息&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>(1)-14.2(3):尝试在panic函数中获取和输出页表有效逻辑地址空间范围和在内存中的逻辑地址空间范围&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>2. 较难题目&#xff1a;“小组练习与思考题”中的“(2)”。最多二个人一组&#xff0c;也可以独立回答。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#2spoc-理解用户进程的生命周期\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#2spoc-理解用户进程的生命周期</a></p>\n<p></p>\n<p>题目&#xff1a;增加一个用户进程A&#xff0c;在ucore运行过程中通过cprintf函数来完整地展现出来进程A相关的动态执行和内部数据/状态变化的细节。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>\n<p></p>\n<p>选择“(0)”的同学<br />Dichen Qian<br />张浩天2013011416 郑兆衡2013011389<br />2013011371 沈哲言 2013011404 叶子鹏</p>\n<p><br />选择“(1)”的同学<br />徐捷 2012011371&#xff0c;赖国堃 2012011372<br />高思达(2013011413)</p>\n<p></p>\n<p>选择“较难题目”的同学<br />王智默 2012011355 高越 2012011379<br />2012011894 朱俸民 2013011411朱新瑞<br />高博 2012012139<br />2013011356 董豪宇 2013011302 李奕昕</p>", "anon": "no", "subject": "2016春季-第十四讲 课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-04-20T05:42:34Z"}, {"content": "<p>请向勇班的同学把“第十四讲 实验五 用户进程管理”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#lab5-spoc-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#lab5-spoc-思考题</a></p>\n<p><br />第十四讲的回答的截止时间是明天&#xff08;20160414&#xff09;晚20点前。<br /> <br />要求&#xff1a;每个依据自己对课程内容的掌握情况&#xff0c;选择做“基础题目”或“较难题目”。不需要两种选择都做。</p>\n<p></p>\n<p>1. 基础题目&#xff1a;有2个“个人思考题”&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除2后的余数&#xff0c;完成与余数相同的题目&#xff0c;独立回答。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#142-进程的内存布局\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#142-进程的内存布局</a></p>\n<p></p>\n<p>(0)-14.2(2):尝试在panic函数中获取并输出用户栈和内核栈的函数嵌套信息&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>(1)-14.2(3):尝试在panic函数中获取和输出页表有效逻辑地址空间范围和在内存中的逻辑地址空间范围&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>2. 较难题目&#xff1a;“小组练习与思考题”中的“(2)”。最多二个人一组&#xff0c;也可以独立回答。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#2spoc-理解用户进程的生命周期\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#2spoc-理解用户进程的生命周期</a></p>\n<p></p>\n<p>题目&#xff1a;增加一个用户进程A&#xff0c;在ucore运行过程中通过cprintf函数来完整地展现出来进程A相关的动态执行和内部数据/状态变化的细节。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>", "anon": "no", "subject": "2016春季-第十四讲 课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-04-13T08:14:56Z"}, {"content": "<p>请向勇班的同学把“第十四讲 实验五 用户进程管理”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#lab5-spoc-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#lab5-spoc-思考题</a></p>\n<p><br />第十四讲的回答的截止时间是明天&#xff08;20160414&#xff09;晚20点前。<br /> <br />要求&#xff1a;每个依据自己对课程内容的掌握情况&#xff0c;选择做“基础题目”或“较难题目”。不需要两种选择都做。</p>\n<p></p>\n<p>1. 基础题目&#xff1a;有2个“个人思考题”&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除2后的余数&#xff0c;完成与余数相同的题目&#xff0c;独立回答。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#142-进程的内存布局\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#142-进程的内存布局</a></p>\n<p></p>\n<p>(0)-14.2(2):尝试在panic函数中获取并输出用户栈和内核栈的函数嵌套信息&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>(1)-14.2(3):尝试在panic函数中获取和输出页表有效逻辑地址空间范围和在内存中的逻辑地址空间范围&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>2. 较难题目&#xff1a;“小组练习与思考题”中的“(2)”。最多二个人一组&#xff0c;也可以独立回答。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#2spoc-理解用户进程的生命周期\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#2spoc-理解用户进程的生命周期</a></p>\n<p></p>\n<p>题目&#xff1a;增加一个用户进程A&#xff0c;在ucore运行过程中通过cprintf函数来完整地展现出来进程A相关的动态执行和内部数据/状态变化的细节。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>", "anon": "no", "subject": "2016春季-第十四讲 课堂思考题回答-向勇班", "uid": "hcrrjuyequh4bt", "created": "2016-04-13T06:48:20Z"}, {"content": "<p>请向勇班的同学把“第十四讲 实验五 用户进程管理”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#lab5-spoc-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#lab5-spoc-思考题</a></p>\n<p><br />第十四讲的回答的截止时间是今天&#xff08;20160413&#xff09;晚20点前。<br /> <br />要求&#xff1a;每个依据自己对课程内容的掌握情况&#xff0c;选择做“基础题目”或“较难题目”。不需要两种选择都做。</p>\n<p></p>\n<p>1. 基础题目&#xff1a;有2个“个人思考题”&#xff0c;最多二个人一组&#xff0c;也可以独立回答。依据小组成员学号中最小学号除2后的余数&#xff0c;完成与余数相同的题目&#xff0c;独立回答。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#142-进程的内存布局\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#142-进程的内存布局</a></p>\n<p></p>\n<p>(0)-14.2(2):尝试在panic函数中获取并输出用户栈和内核栈的函数嵌套信息&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>(1)-14.2(3):尝试在panic函数中获取和输出页表有效逻辑地址空间范围和在内存中的逻辑地址空间范围&#xff0c;然后在你希望的地方人为触发panic函数&#xff0c;并输出上述信息。</p>\n<p></p>\n<p>2. 较难题目&#xff1a;“小组练习与思考题”中的“(2)”。最多二个人一组&#xff0c;也可以独立回答。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#2spoc-理解用户进程的生命周期\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-4-lab5-spoc-discussion.md#2spoc-理解用户进程的生命周期</a></p>\n<p></p>\n<p>题目&#xff1a;增加一个用户进程A&#xff0c;在ucore运行过程中通过cprintf函数来完整地展现出来进程A相关的动态执行和内部数据/状态变化的细节。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>", "anon": "no", "subject": "2016春季-第十四讲 课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-04-13T03:25:25Z"}]}, "error": null}