{"aid": "imw5p6g14t17fy", "result": {"folders": ["lecture13", "课堂问答"], "unique_views": 107, "request_instructor_me": false, "change_log": [{"data": "imurtfr29ik1dh", "anon": "no", "when": "2016-04-10T16:14:33Z", "uid": "hdjonbiyfs62ie", "type": "create"}, {"data": "imva84z6ndzji", "anon": "no", "when": "2016-04-11T00:49:52Z", "uid": "hdjonbiyfs62ie", "type": "update"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:50:52Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:51:08Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:51:24Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:51:33Z", "uid": "i0nuu5yhgno5tv", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:51:39Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:51:59Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:52:11Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:52:26Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:52:38Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:52:54Z", "uid": "hdjonbiyfs62ie", "type": "followup"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:53:18Z", "uid": "i0f24oie8102cr", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:58:13Z", "uid": "i6ub4vwhQXd", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:59:16Z", "uid": "i0zaci5voig5h", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T00:59:43Z", "uid": "i0minzvpea57bu", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:01:16Z", "uid": "i0ayxqk6wry734", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:04:28Z", "uid": "i0brpl1lbyui6", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:04:33Z", "uid": "i0dlq4m0wjn5eo", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:05:24Z", "uid": "i0yuo4o74sx70w", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:10:34Z", "uid": "i0nuu5yhgno5tv", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:11:23Z", "uid": "ikvcvnzpzq7j7", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:12:03Z", "uid": "i0gl5kctugw3xi", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:16:30Z", "uid": "i242q8ug7vw40x", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:30:51Z", "uid": "i6uayuoumpw5ah", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:32:14Z", "uid": "i3qk2vs65x276j", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:33:00Z", "uid": "ie7xy71bn7b1s2", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:35:11Z", "uid": "i21zpwab2z775p", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:35:11Z", "uid": "i1jd60b7orl10p", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:36:59Z", "uid": "ikvcvr6di5i7ma", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T01:57:05Z", "uid": "i0d4mr9tga62ki", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T02:20:47Z", "uid": "i6uiksj895B", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T02:40:01Z", "uid": "i0nu5by9l7v7of", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T02:56:02Z", "uid": "ikvcvqz0jx17m1", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T03:02:18Z", "uid": "i6ugy67km5b", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T03:05:42Z", "uid": "i6w84pnmjCQ", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T03:12:24Z", "uid": "i18riqkwrl225m", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T04:07:09Z", "uid": "i0evrfcnckf5dt", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T04:16:14Z", "uid": "i0c9nvk0xzc2n3", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T04:29:11Z", "uid": "i0c1nsm3911wc", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T05:02:06Z", "uid": "i11dx198ive25r", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T06:15:28Z", "uid": "i1bzj2xilgm4uk", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T07:55:48Z", "uid": "i0nyfgp2bbqig", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T08:17:19Z", "uid": "ikvcvo2cckb7jb", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T08:37:57Z", "uid": "i0eqqq6jvng408", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T09:17:12Z", "uid": "ikvcvr0o2bs7m3", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T09:41:33Z", "uid": "ic226rac4j5jw", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T09:47:58Z", "uid": "i242q8ug7vw40x", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T10:06:48Z", "uid": "i0ccqbaxwdz75c", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T10:06:51Z", "uid": "i28skba6cd976f", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T10:28:04Z", "uid": "ierwkwbinsj2t8", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T10:29:28Z", "uid": "i2olyyl8swl1we", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T10:35:51Z", "uid": "i6ub5at2geM", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T10:37:16Z", "uid": "i6vjwdpfniF", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T10:46:56Z", "uid": "i6uaz437IKR", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T10:55:18Z", "uid": "i2om0jwie732m1", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T11:10:10Z", "uid": "i0gkdbms5ie20o", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T11:21:03Z", "uid": "ic226rq2vask0", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T11:41:31Z", "uid": "i11v1az5sf83l2", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T11:46:03Z", "uid": "im4yagyfl3chl", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T11:48:14Z", "uid": "ikx8y1dzPrM", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T11:48:20Z", "uid": "ikvcvonk6wj7k1", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T11:53:53Z", "uid": "i701mss708y", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T11:57:52Z", "uid": "ikvcvp62fcm7ka", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T11:59:10Z", "uid": "i0cb1385ni65l", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T12:33:59Z", "uid": "i1569mw0xp954u", "type": "feedback"}, {"to": "imurtfr0z7h1dg", "anon": "no", "when": "2016-04-11T12:39:52Z", "uid": "i0f7v0qgfm61s6", "type": "feedback"}, {"data": "imw5dda4v6j3b0", "anon": "no", "when": "2016-04-11T15:21:44Z", "uid": "hdjonbiyfs62ie", "type": "update"}], "upvote_ids": [], "id": "imurtfr0z7h1dg", "bookmarked": 54, "no_answer_followup": 9, "i_edits": [], "is_bookmarked": false, "children": [{"folders": [], "updated": "2016-04-11T00:50:52Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:50:52Z", "type": "followup", "d-bucket": "Yesterday", "id": "imva9f8wqew3wa", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-11T02:40:01Z", "uid": "i0nu5by9l7v7of", "created": "2016-04-11T02:40:01Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imve5sub39e1co", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>2013011409 王启圣</p>\n<p>proc_struct</p>"}, {"folders": [], "updated": "2016-04-11T03:12:24Z", "uid": "i18riqkwrl225m", "created": "2016-04-11T03:12:24Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvfbg1z1pkqa", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2013011297 杨青霖</p>\n<p>proc_struct</p>"}, {"folders": [], "updated": "2016-04-11T04:16:14Z", "uid": "i0c9nvk0xzc2n3", "created": "2016-04-11T04:16:14Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvhlix8n9o54p", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>proc_struct</p>"}, {"folders": [], "updated": "2016-04-11T11:21:03Z", "uid": "ic226rq2vask0", "created": "2016-04-11T11:21:03Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvwrurcg3f51", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2012080057 韩刘成</p>\n<p>proc_struct</p>"}, {"folders": [], "updated": "2016-04-11T11:59:10Z", "uid": "i0cb1385ni65l", "created": "2016-04-11T11:59:10Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvy4usfwc07mw", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2013011345 曹科垒</p>\n<p>proc_struct</p>"}], "subject": "<p>基础题目&#xff1a;</p>\n<p>(1) ucore的线程控制块数据结构是什么&#xff1f;</p>\n<p>选择“(1)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-11T00:51:08Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:51:08Z", "type": "followup", "d-bucket": "Yesterday", "id": "imva9s1ggzy428", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-11T00:51:33Z", "uid": "i0nuu5yhgno5tv", "created": "2016-04-11T00:51:33Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvaaau4fmq4c0", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>可以查看proc_struct里面的cr3&#xff0c;和mm_struct是否是一样的。<br />这两个实际上进程负责管理内存也就是页表的数据&#xff0c;如果这两个相同的话&#xff0c;那么线程肯定是在同一个进程的。</p>"}, {"folders": [], "updated": "2016-04-11T10:28:04Z", "uid": "ierwkwbinsj2t8", "created": "2016-04-11T10:28:04Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvuvpgx2vq3k7", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>看proc_struct当中cr3是否相同</p>"}, {"folders": [], "updated": "2016-04-11T11:41:31Z", "uid": "i11v1az5sf83l2", "created": "2016-04-11T11:41:31Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvxi60vx2v7no", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>看proc_struct当中cr3是否相同</p>"}], "subject": "<p>基础题目&#xff1a;</p>\n<p>(2) 如何知道ucore的两个线程同在一个进程&#xff1f;</p>\n<p>选择“(2)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-11T00:51:24Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:51:24Z", "type": "followup", "d-bucket": "Yesterday", "id": "imvaa3n7lj149s", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-11T00:59:16Z", "uid": "i0zaci5voig5h", "created": "2016-04-11T00:59:16Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvak8htgv56nk", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2013011411 朱新瑞</p>\n<p>(3) context和trapframe分别在什么时候用到&#xff1f;<br />查询context关键字&#xff0c;只在proc.h和proc.h中出现<br />context的声明是</p>\n<p>struct context {<br /> uint32_t eip;<br /> uint32_t esp;<br /> uint32_t ebx;<br /> uint32_t ecx;<br /> uint32_t edx;<br /> uint32_t esi;<br /> uint32_t edi;<br /> uint32_t ebp;<br />};</p>\n<p>即保存了执行中上下文信息&#xff0c;也就是寄存器值<br />而且提供了一个switch_to函数去交换context的值&#xff08;切换上下文&#xff09;<br />而使用是在proc_run当中&#xff0c;即要切换当前运行的进程时会用到context</p>\n<p>再查询trapframe关键字</p>\n<p>struct trapframe {<br /> struct pushregs tf_regs;<br /> uint16_t tf_gs;<br /> uint16_t tf_padding0;<br /> uint16_t tf_fs;<br /> uint16_t tf_padding1;<br /> uint16_t tf_es;<br /> uint16_t tf_padding2;<br /> uint16_t tf_ds;<br /> uint16_t tf_padding3;<br /> uint32_t tf_trapno;<br /> /* below here defined by x86 hardware */<br /> uint32_t tf_err;<br /> uintptr_t tf_eip;<br /> uint16_t tf_cs;<br /> uint16_t tf_padding4;<br /> uint32_t tf_eflags;<br /> /* below here only when crossing rings, such as from user to kernel */<br /> uintptr_t tf_esp;<br /> uint16_t tf_ss;<br /> uint16_t tf_padding5;<br />} __attribute__((packed));</p>\n<p>一部分是lab1我们学到的trapframe会保存了与中断相关的信息&#xff0c;并且能够通过一定的接口把它输出或赋值<br />另一部分也是在proc.c中&#xff0c;它在创建内核线程&#xff0c;复制线程&#xff0c;和进行do_fork()时会使用到</p>\n<p>还有一部分在kmonitor中&#xff0c;大概好像是debug监控内核运行时会用到</p>"}, {"folders": [], "updated": "2016-04-11T01:01:16Z", "uid": "i0ayxqk6wry734", "created": "2016-04-11T01:01:16Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvamsj04x72kv", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>先说使用情况更为广泛的trapframe, trapframe叫做异常帧&#xff0c;是保存在内核堆栈上的进程上下文信息。在中断、异常或者系统调用的时候&#xff0c;会由硬件和软件协同来保存这个数据结构&#xff0c;这个结构如下所示</p>\n<p>&#96;&#96;&#96;<br />struct trapframe {<br /> struct pushregs tf_regs;<br /> uint16_t tf_gs;<br /> uint16_t tf_padding0;<br /> uint16_t tf_fs;<br /> uint16_t tf_padding1;<br /> uint16_t tf_es;<br /> uint16_t tf_padding2;<br /> uint16_t tf_ds;<br /> uint16_t tf_padding3;<br /> uint32_t tf_trapno;<br /> /* below here defined by x86 hardware */<br /> uint32_t tf_err;<br /> uintptr_t tf_eip;<br /> uint16_t tf_cs;<br /> uint16_t tf_padding4;<br /> uint32_t tf_eflags;<br /> /* below here only when crossing rings, such as from user to kernel */<br /> uintptr_t tf_esp;<br /> uint16_t tf_ss;<br /> uint16_t tf_padding5;<br />} __attribute__((packed));<br />&#96;&#96;&#96;<br />其中&#xff0c;有一部分是由硬件直接保存的(error code及以下)&#xff0c;并且还会根据中断时所在的特权级选择性保存ss和esp&#xff0c;有一部分是通过软件来保存的&#xff08;主要为段寄存器和通用寄存器&#xff09;&#xff0c;总的来说&#xff0c;trapframe描述了一个进程在正常执行逻辑中的上下文信息&#xff0c;对进程是不透明的。<br />而context则不同&#xff0c;乍一看它的结构和trapframe中的tf_regs差不多</p>\n<p>&#96;&#96;&#96;<br />struct context {<br /> uint32_t eip;<br /> uint32_t esp;<br /> uint32_t ebx;<br /> uint32_t ecx;<br /> uint32_t edx;<br /> uint32_t esi;<br /> uint32_t edi;<br /> uint32_t ebp;<br />};<br />&#96;&#96;&#96;<br />但context保存的是进程在中断服务例程&#xff08;或者异常系统调用例程&#xff09;中执行的上下文信息&#xff0c;在lab4中&#xff0c;context保存的是在proc_run这个函数中执行的现场信息&#xff0c;这个函数里面有一个switch_to&#xff0c;在这里保存了context&#xff0c;这就意味着context对于进程是透明的&#xff0c;进程以为自己进入了服务例程之后就直接恢复了&#xff0c;其实可能并不是这样&#xff0c;在其中可能被调度过&#xff0c;调度时需要保存的就是context</p>"}, {"folders": [], "updated": "2016-04-11T01:35:11Z", "uid": "i21zpwab2z775p", "created": "2016-04-11T01:35:11Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvbuf00onf5li", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>马志明 2013011395</p>\n<p>context保存的进程的上下文&#xff0c;也就是进程执行当前的各个寄存器的值&#xff0c;在进程切换的时候会用到context。使用context保存寄存器的目的就在于在内核中能够进行上下文之间的切换。<br />trapframe是中断帧的指针&#xff0c;总是指向内核栈的某个位置&#xff0c;当发生中断、异常或者系统调用时&#xff0c;它会保存此进程或者线程在被中断前的状态&#xff0c;当内核需要跳回用户空间时&#xff0c;需要调整中断帧以恢复让进程基础执行的各寄存器值。</p>"}, {"folders": [], "updated": "2016-04-11T04:07:09Z", "uid": "i0evrfcnckf5dt", "created": "2016-04-11T04:07:09Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvh9uwculx5ey", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2013011307 何轩</p>\n<p>context:<br />context是进程的上下文&#xff0c;用于进程切换。在ucore中&#xff0c;进程切换时进入/kern/pprocess/proc_run,其中通过调用switch_to函数来使用context实现上下文的切换。switch_to函数的具体定义是在switch.S中。<br />trapframe:<br />trapframe是中断帧的指针&#xff0c;在proc.c中&#xff0c;从调用它的函数我们就可以知道分别在那些情况下会用到&#xff0c;分别是kern_thread&#xff0c;copy_thread,do_fork。即创建内核线程&#xff0c;复制线程&#xff0c;fork时会使用到。</p>"}, {"folders": [], "updated": "2016-04-11T06:15:28Z", "uid": "i1bzj2xilgm4uk", "created": "2016-04-11T06:15:28Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvluvc4kt91dt", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>context&#xff0c;看名称就是上下文的意思&#xff0c;作用也是用来保存进程的上下文&#xff0c;在proc_run中调用switch_to时会用到&#xff0c;这时就可以进行上下文的切换。</p>\n<p>而trapframe在lab1中有过接触&#xff0c;在lab1中是中断帧的指针&#xff0c;而在lab4中&#xff0c;在创建进程、复制线程、以及进行fork的时候会用到&#xff0c;用来保存一个进程运行时的一些相关信息。</p>"}, {"folders": [], "updated": "2016-04-11T09:41:33Z", "uid": "ic226rac4j5jw", "created": "2016-04-11T09:41:33Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvt7vp5o3b6z3", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>高博 2012012139</p>\n<p></p>\n<p>先说使用情况更为广泛的trapframe, trapframe叫做异常帧&#xff0c;是保存在内核堆栈上的进程上下文信息。在中断、异常或者系统调用的时候&#xff0c;会由硬件和软件协同来保存这个数据结构&#xff0c;这个结构如下所示</p>\n<p><br />struct trapframe {<br />struct pushregs tf_regs;<br />uint16_t tf_gs;<br />uint16_t tf_padding0;<br />uint16_t tf_fs;<br />uint16_t tf_padding1;<br />uint16_t tf_es;<br />uint16_t tf_padding2;<br />uint16_t tf_ds;<br />uint16_t tf_padding3;<br />uint32_t tf_trapno;<br />/* below here defined by x86 hardware */<br />uint32_t tf_err;<br />uintptr_t tf_eip;<br />uint16_t tf_cs;<br />uint16_t tf_padding4;<br />uint32_t tf_eflags;<br />/* below here only when crossing rings, such as from user to kernel */<br />uintptr_t tf_esp;<br />uint16_t tf_ss;<br />uint16_t tf_padding5;<br />} __attribute__((packed));<br /><br />其中&#xff0c;有一部分是由硬件直接保存的(error code及以下)&#xff0c;并且还会根据中断时所在的特权级选择性保存ss和esp&#xff0c;有一部分是通过软件来保存的&#xff08;主要为段寄存器和通用寄存器&#xff09;&#xff0c;总的来说&#xff0c;trapframe描述了一个进程在正常执行逻辑中的上下文信息&#xff0c;对进程是不透明的。</p>\n<p><br />而context则不同&#xff0c;乍一看它的结构和trapframe中的tf_regs差不多</p>\n<p><br />struct context {<br />uint32_t eip;<br />uint32_t esp;<br />uint32_t ebx;<br />uint32_t ecx;<br />uint32_t edx;<br />uint32_t esi;<br />uint32_t edi;<br />uint32_t ebp;<br />};<br /><br />而且提供了一个switch_to函数去交换context的值&#xff08;切换上下文&#xff09;<br />在proc_run当中&#xff0c;即要切换当前运行的进程时会用到context</p>"}, {"folders": [], "updated": "2016-04-11T10:35:51Z", "uid": "i6ub5at2geM", "created": "2016-04-11T10:35:51Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvv5pl2ut16fx", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p><div>\n<div>\n<div>\n<p>(3) context和trapframe分别在什么时候用到&#xff1f;<br />context出现在proc.h和proc.h中。根据context的定义&#xff0c;其中包含各个基础寄存器信息&#xff0c;栈信息以及运行相关寄存器。和课件中线程切换时需要保存的上下文信息对应&#xff1b;在switch_to中实现了上下文的切换&#xff1b;</p>\n<p>trapframe出现在proc.c中。在lab1中已经遇到了&#xff0c;在产生异常时&#xff0c;需要保存异常信息在trapframe结构中。lab4中在kern_thread&#xff0c;copy_thread,do_fork中用到&#xff0c;即用在创建内核线程&#xff0c;复制线程和创建子进程。</p>\n<p>2012080059 金嘉宇</p>\n</div>\n</div>\n</div>"}, {"folders": [], "updated": "2016-04-11T12:33:59Z", "uid": "i1569mw0xp954u", "created": "2016-04-11T12:33:59Z", "type": "feedback", "id": "imvzdmqj3976xr", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>2013011303 程凯</p>\n<p>context在进程&#xff08;线程&#xff09;切换时会用到&#xff1b;trapframe在发生中断/异常/系统调用时会用到。</p>"}, {"folders": [], "updated": "2016-04-11T12:39:52Z", "uid": "i0f7v0qgfm61s6", "created": "2016-04-11T12:39:52Z", "type": "feedback", "id": "imvzl7qjsy022i", "anon": "no", "bucket_name": "Today", "config": {}, "bucket_order": 2, "data": null, "children": [], "subject": "<p>context结构体定义如下&#xff1a;</p>\n<p>struct context {<br />uint32_t eip;<br />uint32_t esp;<br />uint32_t ebx;<br />uint32_t ecx;<br />uint32_t edx;<br />uint32_t esi;<br />uint32_t edi;<br />uint32_t ebp;<br />};</p>\n<p>作用是保存内核堆栈上的上下文信息&#xff0c;主要是各寄存器的值&#xff1b;在proc.c中的switch_to函数中会调用context结构。</p>\n<p></p>\n<p>trapframe定义如下</p>\n<p>struct trapframe {<br />struct pushregs tf_regs;<br />uint16_t tf_gs;<br />uint16_t tf_padding0;<br />uint16_t tf_fs;<br />uint16_t tf_padding1;<br />uint16_t tf_es;<br />uint16_t tf_padding2;<br />uint16_t tf_ds;<br />uint16_t tf_padding3;<br />uint32_t tf_trapno;<br />/* below here defined by x86 hardware */<br />uint32_t tf_err;<br />uintptr_t tf_eip;<br />uint16_t tf_cs;<br />uint16_t tf_padding4;<br />uint32_t tf_eflags;<br />/* below here only when crossing rings, such as from user to kernel */<br />uintptr_t tf_esp;<br />uint16_t tf_ss;<br />uint16_t tf_padding5;<br />} __attribute__((packed));</p>\n<p></p>\n<p>在发生中断(统称)/创建线程/复制线程/fork子线程时会用到。</p>"}], "subject": "<p>基础题目&#xff1a;</p>\n<p>(3) context和trapframe分别在什么时候用到&#xff1f;</p>\n<p>选择“(3)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-11T00:51:39Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:51:39Z", "type": "followup", "d-bucket": "Yesterday", "id": "imvaafubiyejc", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-11T00:53:18Z", "uid": "i0f24oie8102cr", "created": "2016-04-11T00:53:18Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvacjtoehj3mn", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>叶子鹏 2013011404</p>\n<p><a href=\"https://github.com/qq775193759/OS_ANSWER/blob/master/trap.md\" target=\"_blank\">入口地址</a></p>"}, {"folders": [], "updated": "2016-04-11T00:59:43Z", "uid": "i0minzvpea57bu", "created": "2016-04-11T00:59:43Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvaktaqsfx1ck", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>用户态进入中断时&#xff0c;由于涉及到从用户态进入内核态&#xff0c;需要从用户栈切换到内核栈&#xff0c;因此需要多保存ss&#xff08;堆栈段&#xff09;和esp&#xff08;栈顶&#xff09;两个寄存器&#xff0c;先在栈中压入这两个值。再压入error code&#xff0c;cs&#xff0c;eip&#xff0c;flags。</p>\n<p></p>\n<p>而内核态进入中断时&#xff0c;不需要设计栈的切换&#xff0c;因此只需要压入error code&#xff0c;cs&#xff0c;eip&#xff0c;flags。</p>\n<p></p>\n<p>在trapframe数据结构中&#xff1a;</p>\n<pre>struct trapframe {\n    struct pushregs tf_regs;\n    uint16_t tf_gs;\n    uint16_t tf_padding0;\n    uint16_t tf_fs;\n    uint16_t tf_padding1;\n    uint16_t tf_es;\n    uint16_t tf_padding2;\n    uint16_t tf_ds;\n    uint16_t tf_padding3;\n    uint32_t tf_trapno;\n    /* below here defined by x86 hardware */\n    uint32_t tf_err;\n    uintptr_t tf_eip;\n    uint16_t tf_cs;\n    uint16_t tf_padding4;\n    uint32_t tf_eflags;\n    /* below here only when crossing rings, such as from user to kernel */\n    uintptr_t tf_esp;\n    uint16_t tf_ss;\n    uint16_t tf_padding5;\n} __attribute__((packed));</pre>\n<p>注释的那一行“below here only hwn crossing rings”&#xff0c;就表示ss和esp只需要在切换特权级&#xff08;即从用户态到内核态&#xff09;时需要保存。</p>"}, {"folders": [], "updated": "2016-04-11T01:11:23Z", "uid": "ikvcvnzpzq7j7", "created": "2016-04-11T01:11:23Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvazt588f23cr", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>陆喆 2012011308</p>\n<p>用户态的中断处理需要栈切换&#xff1b;内核态不需要。</p>\n<p>对于trapframe来说&#xff0c;就是是否需要将tf_esp、tf_ss压栈的问题。</p>"}, {"folders": [], "updated": "2016-04-11T01:16:30Z", "uid": "i242q8ug7vw40x", "created": "2016-04-11T01:16:30Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvb6eagi1k4nf", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>2013011356 % 8 == 4</p>\n<p>感觉就中断而言, 操作系统并没有做特殊的处理, 因此中断处理的区别应该和异常处理相同. 对于用户态到核心态, 会有特权级的变换, 且会多压入ss和esp(因为有栈的变换), 再压入其他的东西, 这可以从trapframe的结构当中看出来. (其他人已经贴了... 我就不贴了)</p>\n<p></p>\n<p>只是提一句trapframe的构造方法是在trapentry.S中, 将寄存器的值压到栈中, 这时再 call trap, 而trap的参数是trapframe的指针, 指向当前最近被压入的寄存器, 而结构体成员的访问, 其实本质上是以struct地址为base, 再移动一个offset访问相应数据, 因此通过trapframe结构体的指针就可以访问到之前压入的值. 因此结构体当中会有一些16位的padding, 这时因为把16位的段寄存器压入栈中就空出了16位, 因此需要在struct当中把这部分空出来. </p>"}, {"folders": [], "updated": "2016-04-11T01:30:51Z", "uid": "i6uayuoumpw5ah", "created": "2016-04-11T01:30:51Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvbou5g7fo3c3", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>用户态中断时需要切换状态&#xff08;代码中的&#34;crossing rings&#34;, 从用户态进入内核态&#xff09;&#xff0c;所以需要把数据存入栈中&#xff0c;而内核态中断不需要。<br />在trapframe中的体现是tf_esp, tf_ss只在crossing rings的时候需要保存。</p>"}, {"folders": [], "updated": "2016-04-11T02:20:47Z", "uid": "i6uiksj895B", "created": "2016-04-11T02:20:47Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvdh2e25us6mu", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>赖国堃 2012011372</p>\n<p></p>\n<p>用户态切换至内核态需要&#xff0c;把上下文压入内核栈。需要特殊保存tf_esp,tf_ss。内核态切换回用户态不需要保存&#xff0c;所以要转移留出空白位置&#xff0c;</p>"}, {"folders": [], "updated": "2016-04-11T05:02:06Z", "uid": "i11dx198ive25r", "created": "2016-04-11T05:02:06Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvj8iu9x0641b", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>叶方轲 2013011340</p>\n<p>用户态中断有特权级的变化&#xff0c;需要切换至内核栈&#xff0c;所以要保存用户态的esp, ss到trapframe中的tf_esp, tf_ss&#xff1b;</p>\n<p>内核态中断没有特权级的变化&#xff0c;不需要切换栈&#xff0c;所以不用在trapframe中保存esp, ss。</p>\n<p></p>"}, {"folders": [], "updated": "2016-04-11T11:10:10Z", "uid": "i0gkdbms5ie20o", "created": "2016-04-11T11:10:10Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvwduxon592h5", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>乔奕 2013011324</p>\n<p></p>\n<p>不同点在于是否需要将tf_esp、tf_ss压栈。用户态需要&#xff0c;而内核态不需要。</p>"}, {"folders": [], "updated": "2016-04-11T11:48:20Z", "uid": "ikvcvonk6wj7k1", "created": "2016-04-11T11:48:20Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvxqxmlh2g5h7", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>林婕茵 2013011308</p>\n<p>用户态中断处理需要切换至内核栈&#xff0c;在trapframe中保存tf_esp和tf_ss&#xff0c;而内核态中断不需要。</p>\n<p></p>"}], "subject": "<p>基础题目&#xff1a;</p>\n<p>(4) 用户态或内核态下的中断处理有什么区别&#xff1f;在trapframe中有什么体现&#xff1f;</p>\n<p>选择“(4)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-11T00:51:59Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:51:59Z", "type": "followup", "d-bucket": "Yesterday", "id": "imvaav0wwak4nk", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-11T01:04:28Z", "uid": "i0brpl1lbyui6", "created": "2016-04-11T01:04:28Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvaqwux9rp6dj", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>// kernel_thread - create a kernel thread using &#34;fn&#34; function<br />// NOTE: the contents of temp trapframe tf will be copied to <br />//       proc-&gt;tf in do_fork--&gt;copy_thread function<br />int<br />kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {<br />    struct trapframe tf;<br />    memset(&amp;tf, 0, sizeof(struct trapframe));<br />    tf.tf_cs = KERNEL_CS;<br />    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;<br />    tf.tf_regs.reg_ebx = (uint32_t)fn;<br />    tf.tf_regs.reg_edx = (uint32_t)arg;<br />   <strong> tf.tf_eip = (uint32_t)kernel_thread_entry;</strong><br />    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);<br />}</p>\n<p>kernel thread调用之后&#xff0c;先把临时变量tf传递给do_fork函数&#xff0c;所以之后&#xff0c;会执行汇编码kernel_thread_entry&#xff08;见上述代码加重&#xff09;部分&#xff0c;这个函数是</p>\n<p>kernel_thread_entry:        # void kernel_thread(void)</p>\n<p>    pushl %edx              # push arg<br />    call *%ebx              # call fn</p>\n<p>    pushl %eax              # save the return value of fn(arg)<br />    call do_exit            # call do_exit to terminate current thread</p>\n<p>该函数“主要为内核线程的主体fn函数做了一个准备开始和结束运行的&#39;壳&#39;”&#xff08;实验指导书178页&#xff09;</p>"}, {"folders": [], "updated": "2016-04-11T01:04:33Z", "uid": "i0dlq4m0wjn5eo", "created": "2016-04-11T01:04:33Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvar0mm5cs3v1", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>内核线程执行的第一条指令可以在kern\\process\\entry.S中找到:</p>\n<pre>.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p>ucore是通过将trapframe中的eip指向这条指令来完成跳转的, 在kern\\process\\proc.c 中</p>\n<pre>int\nkernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {\n    struct trapframe tf;\n    memset(&amp;tf, 0, sizeof(struct trapframe));\n    tf.tf_cs = KERNEL_CS;\n    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;\n    tf.tf_regs.reg_ebx = (uint32_t)fn;\n    tf.tf_regs.reg_edx = (uint32_t)arg;<br />\n    tf.tf_eip = (uint32_t)kernel_thread_entry; //在这里完成了跳转<br />\n    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);\n}</pre>\n<p></p>"}, {"folders": [], "updated": "2016-04-11T01:12:03Z", "uid": "i0gl5kctugw3xi", "created": "2016-04-11T01:12:03Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvb0o6j3w9599", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>在proc_init()中完成初始化工作后&#xff0c;会在kern_init()的最后&#xff0c;调用cpu_idle()开始切换到内核线程&#xff08;1号&#xff09;的过程。</p>\n<p>cpu_idle检查当前进程的可调度标记&#xff0c;是1&#xff0c;于是调用schedule()函数切换进程。</p>\n<p>进一步调用proc_run()&#xff0c;进行上下文切换&#xff0c;在更新CR3等之后&#xff0c;调用switch_to函数&#xff0c;ret时回到了新线程的第一条指令。</p>\n<p></p>\n<p>ret时&#xff0c;返回地址&#xff08;kernel_thread_entry&#xff09;是在proc_init()中调用kern_thread()函数设置的&#xff0c;即上面回答中的entry.S中的代码。这也就是内核线程的第一段代码。尚且不涉及该线程的实际内容fn&#xff0c;但是已经进入新线程了。</p>\n<p>调用kern_thread()时&#xff0c;同时制定了内核线程的函数fn&#xff08;1号线程时即为hello_world&#xff09;。kernel_thread_entry会返回到fn。</p>\n<p></p>\n<p>【上述核心代码&#xff0c;郑兆衡同学已经贴出&#xff0c;这里不再重复】</p>"}, {"folders": [], "updated": "2016-04-11T01:57:05Z", "uid": "i0d4mr9tga62ki", "created": "2016-04-11T01:57:05Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvcmkraa5r4se", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>学号&#xff1a;2013012213</p>\n<p>在 /kern/process/proc.c 中</p>\n<pre>int\nkernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {\n    struct trapframe tf;\n    memset(&amp;tf, 0, sizeof(struct trapframe));\n    tf.tf_cs = KERNEL_CS;\n    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;\n    tf.tf_regs.reg_ebx = (uint32_t)fn;\n    tf.tf_regs.reg_edx = (uint32_t)arg;\n    tf.tf_eip = (uint32_t)kernel_thread_entry;\n    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);\n}</pre>\n<p>可以看出内核线程执行的第一条指令在 /kern/process/entry.S 中</p>\n<pre>.text\n.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p>来调用之前存到ebx中的fn函数</p>"}, {"folders": [], "updated": "2016-04-11T02:56:02Z", "uid": "ikvcvqz0jx17m1", "created": "2016-04-11T02:56:02Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imveqdpxkr9kg", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>俞寒轩 20120111333</p>\n<p></p>\n<p><strong>1 do_fork中的内核线程执行的第一条指令是什么</strong></p>\n<p>do_fork内核线程执行的第一条指令保存在trapframe的eip中&#xff1a;</p>\n<pre>tf.tf_eip = (uint32_t)kernel_thread_entry;</pre>\n<p>可见&#xff0c;其先回跳转到kernel_thread_entry执行。</p>\n<p>观察kernel_thread_entry&#xff1a;</p>\n<pre>.text<br />.globl kernel_thread_entry<br />kernel_thread_entry:        # void kernel_thread(void)<br /><br />    pushl %edx              # push arg<br />    call *%ebx              # call fn<br /><br />    pushl %eax              # save the return value of fn(arg)<br />    call do_exit            # call do_exit to terminate current thread</pre>\n<p>可知道第一条指令为pushl %edx</p>\n<p></p>\n<p></p>\n<p><strong>2 它是如何过渡到内核线程对应的函数的</strong></p>\n<p>这个pushl %edx指令将所需的参数压入栈后&#xff0c;就调用fn函数了&#xff08;内核线程对应函数&#xff09;。即此处作为一个中转站&#xff0c;执行内核线程时跳转到这个entry&#xff0c;然后它负责跳转到对应函数&#xff0c;并负责储存返回值与结束进程。相当于给一个有功能的函数&#xff0c;加入线程所需要的行为。</p>\n<p></p>"}, {"folders": [], "updated": "2016-04-11T03:02:18Z", "uid": "i6ugy67km5b", "created": "2016-04-11T03:02:18Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imveyghh8g0el", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>崔岩 2012011309</p>\n<p>/kern/process/proc.c:</p>\n<pre>int\nkernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {\n    struct trapframe tf;\n    memset(&amp;tf, 0, sizeof(struct trapframe));\n    tf.tf_cs = KERNEL_CS;\n    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;\n    tf.tf_regs.reg_ebx = (uint32_t)fn;\n    tf.tf_regs.reg_edx = (uint32_t)arg;\n    tf.tf_eip = (uint32_t)kernel_thread_entry;\n    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);\n}</pre>\n<p>将中断帧的指令寄存器设为kernel_thread_entry&#xff0c;这样在tf传递给do_fork后&#xff0c;会跳到kernel_thread_entry处&#xff0c;在/kern/process/entry.S中&#xff1a;</p>\n<pre>.text\n.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p>将参数压栈后就调用之前存入ebx寄存器中的fn函数。</p>"}, {"folders": [], "updated": "2016-04-11T04:29:11Z", "uid": "i0c1nsm3911wc", "created": "2016-04-11T04:29:11Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvi26tb8jt6mf", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2012011894</p>\n<p></p>\n<p>在 kern/process/proc.c 中&#xff0c;</p>\n<pre>int\nkernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {\n    struct trapframe tf;\n    memset(&amp;tf, 0, sizeof(struct trapframe));\n    tf.tf_cs = KERNEL_CS;\n    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;\n    tf.tf_regs.reg_ebx = (uint32_t)fn;\n    tf.tf_regs.reg_edx = (uint32_t)arg;\n    tf.tf_eip = (uint32_t)kernel_thread_entry;\n    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);\n}</pre>\n<p>设置 tf 的执行程序入口为kernel_thread_entry。即完成 fork 后&#xff0c;跳转到此处执行。</p>\n<p></p>\n<p>在 kern/process/entry.S 中&#xff0c;</p>\n<pre>.text\n.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p>首条执行的指令是 pushl %edx&#xff0c;压参数&#xff0c;然后 call *%ebx&#xff0c;即过渡到了内核线程对应的函数的fn。</p>"}, {"folders": [], "updated": "2016-04-11T10:29:28Z", "uid": "i2olyyl8swl1we", "created": "2016-04-11T10:29:28Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvuxijnfza4ct", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>首先在 /kern/process/proc.c 中kernel_thread函数中有一行&#xff1a;</p>\n<pre>    tf.tf_eip = (uint32_t)kernel_thread_entry;\n</pre>\n<p>紧接下来就是调用do_fock</p>\n<pre>return do_fork(clone_flags | CLONE_VM,0,&amp;tf);</pre>\n<p>然后在 kern/process/entry.S 中&#xff0c;可以看到&#xff1a;</p>\n<pre>.text\n.globl kernel_thread_entry\nkernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p>第一条指令是pushl %edx&#xff0c;接着会call fn&#xff0c;即过渡到内核线程对应的函数。</p>"}], "subject": "<p>基础题目&#xff1a;</p>\n<p>(5) do_fork中的内核线程执行的第一条指令是什么&#xff1f;它是如何过渡到内核线程对应的函数的&#xff1f;</p>\n<p>选择“(5)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-11T00:52:11Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:52:11Z", "type": "followup", "d-bucket": "Yesterday", "id": "imvab4dnmaj2yu", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-11T01:36:59Z", "uid": "ikvcvr6di5i7ma", "created": "2016-04-11T01:36:59Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvbwqe7z9e34r", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>在proc.c的kernel_thread函数中&#xff0c;</p>\n<pre>do_fork(clone_flags | CLONE_VM, 0, &amp;tf);</pre>\n<p>fork了一个内核进程。</p>\n<p>do_fork中继续调用copy_thread。在copy_thread中&#xff0c;将该进程的trap frame的栈顶指针设为0&#xff0c;进程本身的栈顶指针指向该进程的trap frame。</p>"}, {"folders": [], "updated": "2016-04-11T08:17:19Z", "uid": "ikvcvo2cckb7jb", "created": "2016-04-11T08:17:19Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvq7kdznxd2wp", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>参见<code>tf</code>和<code>context</code>中的<code>esp</code>初始化代码。</p>"}, {"folders": [], "updated": "2016-04-11T09:17:12Z", "uid": "ikvcvr0o2bs7m3", "created": "2016-04-11T09:17:12Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvsckg6j8jp", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>尚智伟 2012011366</p>\n<p></p>\n<p>通过do_fork建立的内核线程的堆栈初始化在proc.c中的copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf)完成</p>\n<p>相关代码为</p>\n<pre>    proc-&gt;tf-&gt;tf_esp = esp;\t//参数中指定为0\n    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);</pre>\n<p></p>"}, {"folders": [], "updated": "2016-04-11T10:55:18Z", "uid": "i2om0jwie732m1", "created": "2016-04-11T10:55:18Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvvuq86hzo6xf", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "郭栋 2013011334\n\nkernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {\n    struct trapframe tf;\n    memset(&amp;tf, 0, sizeof(struct trapframe));\n    tf.tf_cs = KERNEL_CS;\n    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;\n    tf.tf_regs.reg_ebx = (uint32_t)fn;\n    tf.tf_regs.reg_edx = (uint32_t)arg;\n    tf.tf_eip = (uint32_t)kernel_thread_entry;\n    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);\n}"}], "subject": "<p>基础题目&#xff1a;</p>\n<p>(6)内核线程的堆栈初始化在哪&#xff1f;</p>\n<p>选择“(6)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-11T00:52:26Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:52:26Z", "type": "followup", "d-bucket": "Yesterday", "id": "imvabfywwzv34k", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-11T00:58:13Z", "uid": "i6ub4vwhQXd", "created": "2016-04-11T00:58:13Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvaivyewx54yb", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>徐捷 2012011371</p>\n<p>当父进程调用fork的时候&#xff0c;会调用到ucore的do_fork()函数&#xff0c;这个函数位于kern/process/proc.c, 可以看到lab4_result的proc.c第337行</p>\n<pre>ret = proc-&gt;pid;</pre>\n<p>因此&#xff0c;父进程得到的返回值是子进程的pid。</p>\n<p>对于子进程的返回值&#xff0c;可以看do_fork()函数在proc.c的323行调用了copy_thread函数&#xff0c;copy_thread函数中有一句</p>\n<pre>proc-&gt;tf-&gt;tf_regs.reg_eax = 0</pre>\n<p>即设置了子进程被切换到时的返回值是0&#xff1b;</p>"}, {"folders": [], "updated": "2016-04-11T01:35:11Z", "uid": "i1jd60b7orl10p", "created": "2016-04-11T01:35:11Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvbuf15usf4zk", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>父进程返回子进程的pid</p>\n<p>子进程返回值为0&#xff1b;</p>\n<p>具体代码分别体现在/kern/process/proc.c中do_fork()函数中</p>\n<pre>ret = proc-&gt;pid;<br />fork_out:<br />    return ret;</pre>\n<p>copy_thread()函数中:</p>\n<pre>proc-&gt;tf-&gt;tf_regs.reg_eax = 0;</pre>\n<p></p>\n<p></p>"}, {"folders": [], "updated": "2016-04-11T07:55:48Z", "uid": "i0nyfgp2bbqig", "created": "2016-04-11T07:55:48Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvpfw77rs11ah", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>许孝先 2013011423 </p>\n<p>在do_fork()函数中</p>\n<p>父进程  ret = proc-&gt;pid;  返回子进程pid</p>\n<p>子进程  proc-&gt;tf-&gt;tf_regs.reg_eax = 0;  返回0</p>\n<p></p>"}, {"folders": [], "updated": "2016-04-11T10:06:48Z", "uid": "i0ccqbaxwdz75c", "created": "2016-04-11T10:06:48Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvu4cr1lqy48k", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>父进程调用do_fork()时&#xff0c;见kern/process/proc.c&#xff0c;有一句ret=proc-&gt;pid&#xff0c;因此父进程fork的返回值是子进程的pid&#xff1b;</p>\n<p>子进程在创建时对应do_fork()中的copy_thread(proc, stack, tf)语句&#xff0c;而在copy_thread()中有一句proc-&gt;tf-&gt;tf_regs.reg_eax = 0&#xff0c;从而子进程fork的返回值是0。</p>"}, {"folders": [], "updated": "2016-04-11T10:37:16Z", "uid": "i6vjwdpfniF", "created": "2016-04-11T10:37:16Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvv7jlozem655", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2012011383</p>\n<p>父 <br />ret = proc-&gt;pid;<br />子 <br />proc-&gt;tf-&gt;tf_regs.reg_eax = 0</p>"}, {"folders": [], "updated": "2016-04-11T11:48:14Z", "uid": "ikx8y1dzPrM", "created": "2016-04-11T11:48:14Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvxqst0ul42uo", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>krajna 2014010527 差点忘了...</p>\n<p>kern/process/proc.c中的do_fork()函数中设置ret=proc-&gt;pid,父进程的fork返回值为子进程的pid</p>\n<p></p>\n<p>在父进程fork子进程时&#xff0c;调用copy_thread()函数&#xff0c;其中有proc-&gt;tf-&gt;tf_regs.reg_eax=0&#xff0c;这里设置了子进程d0_fork()的返回值为0.</p>"}, {"folders": [], "updated": "2016-04-11T11:53:53Z", "uid": "i701mss708y", "created": "2016-04-11T11:53:53Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvxy2p36ctjv", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>陈伯乐 2012011302</p>\n<p></p>\n<p>在do_fork()中</p>\n<p>    对于父进程</p>\n<p>         ret = proc-&gt;pid;  返回子进程pid</p>\n<p>    对于子进程  </p>\n<p>         proc-&gt;tf-&gt;tf_regs.reg_eax = 0;  返回0</p>"}, {"folders": [], "updated": "2016-04-11T11:57:52Z", "uid": "ikvcvp62fcm7ka", "created": "2016-04-11T11:57:52Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvy36y6d2l70m", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>周恩泽 2012012617</p>\n<p>对于父进程&#xff0c;在do_fork()函数中有ret=proc-&gt;pid;一句&#xff0c;返回了子进程的pid。而对于子进程&#xff0c;在copy_thread()函数中proc-&gt;tf-&gt;tf_regs.reg_eax=0;一句设定了返回为0。</p>"}], "subject": "<p>基础题目&#xff1a;</p>\n<p>(7)fork()父子进程的返回值是不同的。这在源代码中的体现中哪&#xff1f;</p>\n<p>选择“(7)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-11T00:52:38Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:52:38Z", "type": "followup", "d-bucket": "Yesterday", "id": "imvabp12c3t5j0", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-11T01:05:24Z", "uid": "i0yuo4o74sx70w", "created": "2016-04-11T01:05:24Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvas422tbt75j", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>我们从kern_init开始追踪</p>\n<p></p>\n<p>1.创建initproc</p>\n<p></p>\n<p>在kern_init中调用proc_init(void) 函数    (proc.c)</p>\n<pre>int pid = kernel_thread(init_main, &#34;Hello world!!&#34;, 0);<br />initproc = find_proc(pid);<br />set_proc_name(initproc, &#34;init&#34;);</pre>\n<p>这里存储了pid和name&#xff0c;然后调用了kernel_thread()函数   (proc.c)</p>\n<pre>kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {\n    struct trapframe tf;\n    memset(&amp;tf, 0, sizeof(struct trapframe));\n    tf.tf_cs = KERNEL_CS;\n    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;\n    tf.tf_regs.reg_ebx = (uint32_t)fn;\n    tf.tf_regs.reg_edx = (uint32_t)arg;\n    tf.tf_eip = (uint32_t)kernel_thread_entry;\n    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);\n}</pre>\n<p>这个主要设置了initproc的trapframe。这里的fn传入的是init_main函数的入口地址&#xff0c;并且存在了tf的ebx里&#xff0c;把参数存在了tf的edx</p>\n<p>这里把tf的入口地址设在了kernel_thread_entry</p>\n<p>接着调用do_fork()函数  (proc.c)</p>\n<pre>copy_thread(proc, stack, tf);</pre>\n<p>do_fork里调用了copy_thread()函数 (proc.c)</p>\n<pre>copy_thread(struct proc_struct *proc, uintptr_t esp, struct trapframe *tf) {<br />    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack &#43; KSTACKSIZE) - 1;<br />    *(proc-&gt;tf) = *tf;<br />    proc-&gt;tf-&gt;tf_regs.reg_eax = 0;<br />    proc-&gt;tf-&gt;tf_esp = esp;<br />    proc-&gt;tf-&gt;tf_eflags |= FL_IF;<br />    proc-&gt;context.eip = (uintptr_t)forkret;<br />    proc-&gt;context.esp = (uintptr_t)(proc-&gt;tf);<br />}</pre>\n<p>这里继续设置initproc的tf和context。比较关键的是把context的入口地址设在了forkret</p>\n<p>至此&#xff0c;initproc的创建基本完成了</p>\n<p></p>\n<p>2.切换到initproc</p>\n<p></p>\n<p>这里切换的主要流程如下&#xff1a;</p>\n<p>-&gt; kern_init     (init.c)</p>\n<p>-&gt; cpu_idle()   (proc.c)</p>\n<p>-&gt; schedule()  (sched.c)</p>\n<p>-&gt; proc_run     (proc.c)</p>\n<p></p>\n<p>proc_run函数的主要代码</p>\n<pre>current = proc;\nload_esp0(next-&gt;kstack &#43; KSTACKSIZE);\nlcr3(next-&gt;cr3);\nswitch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context))</pre>\n<p>这样就从idelproc切换到了initproc</p>\n<p></p>\n<p>3.initproc的内部执行</p>\n<p></p>\n<p>之前已经提到initproc的context的入口地址设在了forkret</p>\n<p>我们来看看forkret  (trapentry.S)</p>\n<pre>forkrets:<br />    # set stack to this new process&#39;s trapframe<br />    movl 4(%esp), %esp<br />    jmp __trapret</pre>\n<p>相当于initproc先进行一个虚假的退出中断iret&#xff0c;目的是把tf的值压入寄存器</p>\n<p></p>\n<p>我们之前提到tf中的入口地址设在了kernel_thread_entry (entry.S)</p>\n<p></p>\n<pre>kernel_thread_entry:        # void kernel_thread(void)\n\n    pushl %edx              # push arg\n    call *%ebx              # call fn\n\n    pushl %eax              # save the return value of fn(arg)\n    call do_exit            # call do_exit to terminate current thread</pre>\n<p>这里 通过call %ebx 调用了之前存入的函数init_main&#xff0c;进而执行init_main打印“hello world”</p>\n<p></p>\n<p>4. initproc退出</p>\n<p></p>\n<p>上面 call do_exit 标志initproc的退出</p>\n<pre>do_exit(int error_code) {\n    panic(&#34;process exit!!.\\n&#34;);\n}</pre>\n<p></p>"}, {"folders": [], "updated": "2016-04-11T01:32:14Z", "uid": "i3qk2vs65x276j", "created": "2016-04-11T01:32:14Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvbqmr3ql130e", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>在执行之前</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/i3qk2vs65x276j/imvaijwftw37/1.png\" /></p>\n<p>在执行时&#xff0c;</p>\n<p>通过设置tf&#xff0c;将init_main()函数传入中断帧&#xff0c;最后执行init_main()</p>"}, {"folders": [], "updated": "2016-04-11T08:37:57Z", "uid": "i0eqqq6jvng408", "created": "2016-04-11T08:37:57Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvqy3lux456x7", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2013011376 龚拓宇</p>\n<p>init.c::kern_init()中调用proc.c::proc_init()<br />proc.c::proc_init()中调用proc.c::kernel_thread()来获取pid&#xff0c;并存储name<br />proc.c::kernel_thread()中调用proc.c::do_fork()<br />proc.c::do_fork()中调用proc.c::copy_thread()<br />至此&#xff0c;initproc创建完成</p>"}, {"folders": [], "updated": "2016-04-11T10:06:51Z", "uid": "i28skba6cd976f", "created": "2016-04-11T10:06:51Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvu4f8uc5f28j", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>在kern_init()中调用proc_init() 存储pid和name</p>\n<p>在proc_init()中调用kernel_thread()</p>\n<p>在kernel_thread()中调用do_fork()</p>\n<p>在do_fork()中调用copy_thread()</p>\n<p>initproc创建完成</p>\n<p></p>\n<p>2013011328 张殿炎</p>"}, {"folders": [], "updated": "2016-04-11T10:46:56Z", "uid": "i6uaz437IKR", "created": "2016-04-11T10:46:56Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvvjyvysk22f9", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>2012080056 金贤林</p>\n<p>kern_init()-&gt;proc_init()-&gt;kernel_thread()-&gt;do_fork()-&gt;copy_thread()</p>\n<p>至此&#xff0c;initproc创建完成。</p>"}, {"folders": [], "updated": "2016-04-11T11:46:03Z", "uid": "im4yagyfl3chl", "created": "2016-04-11T11:46:03Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvxnzuhyyp5jd", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>kern_init()里&#xff0c;proc_init() 调用kernel_thread函数创建了initproc。</p>\n<p>&#34;kern/process/proc.c:1074&#34;</p>\n<pre>int pid = kernel_thread(init_main, NULL, 0);</pre>\n<p> </p>\n<p>kernel_thread 里&#xff0c;Initproc的trapframe的tf_regs.reg_ebx设定为init_main&#xff0c;tf_eip设定为kernel_thread_entry。</p>\n<p>&#34;kern/process/proc.c:285&#34;:</p>\n<pre>kernel_thread(int (*fn)(void *), void *arg, uint32_t clone_flags) {<br />    struct trapframe tf;<br />    memset(&amp;tf, 0, sizeof(struct trapframe));<br />    tf.tf_cs = KERNEL_CS;<br />    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;<br />    tf.tf_regs.reg_ebx = (uint32_t)fn;<br />    tf.tf_regs.reg_edx = (uint32_t)arg;<br />    tf.tf_eip = (uint32_t)kernel_thread_entry;<br />    return do_fork(clone_flags | CLONE_VM, 0, &amp;tf);<br />} </pre>\n<p>然后运行idleproc的函数cpu_idle()&#xff0c;再用schedule()跳到内核线程initproc。</p>\n<p>&#34;kern/schedule/sched.c:81&#34;:</p>\n<pre>schedule(void) {<br />    bool intr_flag;<br />    struct proc_struct *next;<br />    local_intr_save(intr_flag);<br />    {<br />        current-&gt;need_resched = 0;<br />        if (current-&gt;state == PROC_RUNNABLE) {<br />            sched_class_enqueue(current);<br />        }<br />        if ((next = sched_class_pick_next()) != NULL) {<br />            sched_class_dequeue(next);<br />        }<br />        if (next == NULL) {<br />            next = idleproc;<br />        }<br />        next-&gt;runs &#43;&#43;;<br />        if (next != current) {<br />            proc_run(next);<br />        }<br />    }<br />    local_intr_restore(intr_flag);<br />}  </pre>\n<p>Schedule()里用sched_class_dequeue(next)在队列里找到initproc线程&#xff0c;再用proc_run(next)切换过去。</p>\n<p>&#34;kern/process/proc.c:231&#34;:</p>\n<pre>proc_run(struct proc_struct *proc) {<br />    if (proc != current) {<br />        bool intr_flag;<br />        struct proc_struct *prev = current, *next = proc;<br />        local_intr_save(intr_flag);<br />        {<br />            current = proc;<br />            load_esp0(next-&gt;kstack &#43; KSTACKSIZE);<br />            lcr3(next-&gt;cr3);<br />            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));<br />        }<br />        local_intr_restore(intr_flag);<br />    }<br />} </pre>\n<p>proc_run(next)里切换了内核栈&#xff08;&#xff1f;&#xff09;、页表&#xff08;cr3&#xff09;、调用switch_to切换了上下文。</p>\n<p>&#34;kern/process/switch.S&#34;:</p>\n<pre> switch_to:                      # switch_to(from, to)<br /> <br />    # save from&#39;s registers<br />    movl 4(%esp), %eax          # eax points to from<br />    popl 0(%eax)                # save eip !popl<br />    movl %esp, 4(%eax)<br />    movl %ebx, 8(%eax)<br />    movl %ecx, 12(%eax)<br />    movl %edx, 16(%eax)<br />    movl %esi, 20(%eax)<br />    movl %edi, 24(%eax)<br />    movl %ebp, 28(%eax)<br /> <br />    # restore to&#39;s registers<br />    movl 4(%esp), %eax          # not 8(%esp): popped return address already<br />                                # eax now points to to<br />    movl 28(%eax), %ebp<br />    movl 24(%eax), %edi<br />    movl 20(%eax), %esi<br />    movl 16(%eax), %edx<br />    movl 12(%eax), %ecx<br />    movl 8(%eax), %ebx<br />    movl 4(%eax), %esp<br /> <br />    pushl 0(%eax)               # push eip<br /> <br />    ret  </pre>\n<p>switch_to的最后将context里的eip&#xff08;forkret&#xff09;放到新的栈的顶部&#xff0c;然后ret返回到forkret&#xff0c;执行</p>\n<p>&#34;kern/process/proc.c:251&#34;:</p>\n<pre>forkrets(current-&gt;tf);</pre>\n<p> </p>\n<p>跳到forkrets&#xff1a;</p>\n<p>&#34;kern/trap/trapentry.S&#34;:</p>\n<pre>forkrets:<br />    # set stack to this new process&#39;s trapframe<br />    movl 4(%esp), %esp<br />    jmp __trapret </pre>\n<p>跳到__trapret&#xff1a;</p>\n<p>&#34;kern/trap/trapentry.S&#34;:</p>\n<pre>__trapret:<br />    # restore registers from stack<br />    popal<br /># restore %ds, %es, %fs and %gs<br />    popl %gs<br />    popl %fs<br />    popl %es<br />    popl %ds<br /># get rid of the trap number and error code<br />    addl $0x8, %esp<br />    iret </pre>\n<p>__trapret按照struct trapframe成员的顺序&#xff0c;一个一个的还原&#xff0c;跳过trap number和error code后&#xff0c;esp指向trapframe的eip&#xff08;指向kernel_thread_entry&#xff09;&#xff0c;iret从内核栈里弹出eip、cs、eflags到对应的寄存器&#xff0c;就返回到kernel_thread_entry。</p>\n<p>&#34;kern/process/entry.S&#34;:</p>\n<pre>kernel_thread_entry:        # void kernel_thread(void)<br />    pushl %edx              # push arg<br />    call *%ebx              # call fn<br /> <br />    pushl %eax              # save the return value of fn(arg)<br />    call do_exit            # call do_exit to terminate current thread </pre>\n<p>kernel_thread_entry函数Call ebx所指的函数&#xff08;就是init_main&#xff09;&#xff0c;跳到内核线程initproc的init_main函数开头&#xff0c;第一次被执行。</p>\n<p></p>\n<p></p>"}], "subject": "<p>基础题目&#xff1a;</p>\n<p>(8)内核线程initproc的第一次执行流程是什么样的&#xff1f;能跟踪出来吗&#xff1f;</p>\n<p>选择“(8)”的同学的回答结果写在此贴后面。</p>"}, {"folders": [], "updated": "2016-04-11T00:52:54Z", "no_upvotes": 0, "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:52:54Z", "type": "followup", "d-bucket": "Yesterday", "id": "imvac1iszc45jw", "anon": "no", "bucket_name": "Yesterday", "no_answer": 1, "config": {}, "bucket_order": 3, "data": null, "children": [{"folders": [], "updated": "2016-04-11T01:10:34Z", "uid": "i0nuu5yhgno5tv", "created": "2016-04-11T01:10:34Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvayr8pmekjz", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p>增加了函数&#xff0c;用三个debug的线程和原来的helloworld进行测试。</p>\n<pre>static int\ndebug_main(void *arg) {\n    cprintf(&#34;this is debug thread, pid = %d\\n&#34;, current-&gt;pid);\n    cprintf(&#34;init : \\&#34;%s\\&#34;.\\n&#34;, (const char *)arg);\n    cprintf(&#34;begin loop\\n&#34;);\n    int j = 2;\n    while(j --){\n        int ret = 0, i;\n        for (i = 0; i &lt; 100000000; i &#43;&#43;) {\n                ret &#43;= 1;\n        }\n        current-&gt;need_resched = 1;\n        cprintf(&#34;%s want to schedule\\n&#34;, arg);\n        schedule();\n    }\n    cprintf(&#34;exit\\n&#34;);\n    return 0;\n}\n  </pre>\n<p>在schedule.c里面加入</p>\n<pre>cprintf(&#34;switch %s to %s\\n&#34;, current-&gt;name, next-&gt; name);</pre>\n<p>结果&#xff0c;发现是一个后来先服务的调度。也就是先初始化的后执行。</p>\n<pre>switch idle to debug pid = 4<br />this is debug thread, pid = 4<br />init : &#34;debug pid = 4&#34;.<br />begin loop<br />100 ticks<br />100 ticks<br />debug pid = 4 want to schedule<br />switch debug pid = 4 to debug pid = 3<br />this is debug thread, pid = 3<br />init : &#34;debug pid = 3&#34;.<br />begin loop<br />100 ticks<br />100 ticks<br />debug pid = 3 want to schedule<br />switch debug pid = 3 to debug pid = 2<br />this is debug thread, pid = 2<br />init : &#34;debug pid = 2&#34;.<br />begin loop<br />100 ticks<br />100 ticks<br />debug pid = 2 want to schedule<br />switch debug pid = 2 to init<br />this is debug thread, pid = 1<br />init : &#34;Hello world!!&#34;.<br />begin loop<br />100 ticks<br />100 ticks<br />100 ticks<br />Hello world!! want to schedule<br />switch init to debug pid = 4<br />100 ticks<br />100 ticks<br />debug pid = 4 want to schedule<br />switch debug pid = 4 to debug pid = 3<br />100 ticks<br />100 ticks<br />100 ticks<br />debug pid = 3 want to schedule<br />switch debug pid = 3 to debug pid = 2<br />100 ticks<br />100 ticks<br />debug pid = 2 want to schedule<br />switch debug pid = 2 to init<br />100 ticks<br />100 ticks<br />Hello world!! want to schedule<br />switch init to debug pid = 4<br />exit<br />kernel panic at kern/process/proc.c:353:<br />    process exit!!.</pre>"}, {"folders": [], "updated": "2016-04-11T01:33:00Z", "uid": "ie7xy71bn7b1s2", "created": "2016-04-11T01:33:00Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvbrm93gxo2pq", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p><a href=\"https://github.com/gjc13/ucore_os_lab/tree/lab4-spoc\">https://github.com/gjc13/ucore_os_lab/tree/lab4-spoc</a></p>\n<p>直接在schedule函数中输出</p>"}, {"folders": [], "updated": "2016-04-11T03:05:42Z", "uid": "i6w84pnmjCQ", "created": "2016-04-11T03:05:42Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvf2tie1xl1z4", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>2012011355 王智默</p>\n<p>2012011379 高越</p>\n<p></p>\n<p>代码见:</p>\n<p><a href=\"http://172.16.13.236/wzm_andy/ucore_lab/tree/master/labcodes_answer/lab4_result/kern/process/proc.c\">http://172.16.13.236/wzm_andy/ucore_lab/tree/master/labcodes_answer/lab4_result/kern/process/proc.c</a></p>\n<p><a href=\"http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab4_result/kern/schedule/sched.c\">http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab4_result/kern/schedule/sched.c</a></p>\n<p></p>\n<p>报告见:</p>\n<p><a href=\"http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab4_result/lab4-spoc.md\">http://172.16.13.236/wzm_andy/ucore_lab/blob/master/labcodes_answer/lab4_result/lab4-spoc.md</a></p>\n<p></p>"}, {"folders": [], "updated": "2016-04-11T09:47:58Z", "uid": "i242q8ug7vw40x", "created": "2016-04-11T09:47:58Z", "type": "feedback", "d-bucket": "Yesterday", "id": "imvtg4sbj5229c", "anon": "no", "bucket_name": "Yesterday", "config": {}, "bucket_order": 3, "data": null, "children": [], "subject": "<p></p>\n<p>2013011356 董豪宇</p>\n<p>2013011302 李奕昕</p>\n<p>在proc.c中加入了如下代码, 用于创建第三个内核线程</p>\n<pre>static int\nobserver_main(void *arg) {\n    cprintf(&#34;in observer_main: thread start pid = %d\\n&#34;, current-&gt;pid);\n    int times = 10;\n    while (times --) {\n        cprintf(&#34;this is the %d times that observer_main will be scheduled\\n&#34;, 10 - times);\n        schedule();\n    }\n    cprintf(&#34;in observer_main: thread end pid = %d\\n&#34;, current-&gt;pid);\n    return 0;\n}</pre>\n<p>在proc_init函数中进行实际创建</p>\n<pre>local_intr_save(_int);\n    {\n        cprintf(&#34;---------------- ready to create a thread: observer_main -----------------\\n&#34;);\n    }\n    local_intr_restore(_int);\n    int observer_pid = kernel_thread(observer_main, NULL, 0);\n    local_intr_save(_int);\n    {\n        cprintf(&#34;----------------------- created successful -------------------------------\\n&#34;);\n    }\n    local_intr_restore(_int);</pre>\n<p>在schedule.c中加入表示调度方向的信息, 在此不列出. </p>\n<p>运行结果如下:</p>\n<pre>---------------- ready to create a thread: observer_main -----------------\n----------------------- created successful -------------------------------\nproc_init:: Created kernel thread init_main--&gt; pid: 1, name: init1\nproc_init:: Created kernel thread init_main--&gt; pid: 2, name: init2\n&#43;&#43; setup timer interrupts\n kernel_thread, pid = 1, name = init1\n kernel_thread, pid = 2, name = init2\nin observer_main: thread start pid = 3\nthis is the 1 times that observer_main will be scheduled\nin schedule: from pid 1 to pid 2\n kernel_thread, pid = 1, name = init1 , arg  init main1: Hello world!! \nin schedule: from pid 2 to pid 3\n kernel_thread, pid = 2, name = init2 , arg  init main2: Hello world!! \nin schedule: from pid 3 to pid 1\nthis is the 2 times that observer_main will be scheduled\nin schedule: from pid 1 to pid 2\n kernel_thread, pid = 1, name = init1 ,  en.., Bye, Bye. :)\n do_exit: proc pid 1 will exit\n do_exit: proc  parent c02ff008\nin schedule: from pid 2 to pid 3\n kernel_thread, pid = 2, name = init2 ,  en.., Bye, Bye. :)\n do_exit: proc pid 2 will exit\n do_exit: proc  parent c02ff008\nin schedule: from pid 3 to pid 1\nthis is the 3 times that observer_main will be scheduled\nin schedule: from pid 3 to pid 3\nthis is the 4 times that observer_main will be scheduled\nin schedule: from pid 3 to pid 3\nthis is the 5 times that observer_main will be scheduled</pre>\n<p>可以发现程序调度遵循FIFO, 而且由于在此时没有在时钟中断下考虑进程的调度问题, 因此必须程序手动调度schedule才会放弃当前的CPU的占用. </p>"}], "subject": "<p>较难题目&#xff1a;<br />练习3&#xff1a;在现有基础上再增加一个内核线程&#xff0c;并通过增加cprintf函数到ucore代码中 能够把内核线程的生命周期和调度动态执行过程完整地展现出来</p>\n<p>选择“(练习3)”的同学的回答结果写在此贴后面。</p>"}], "nr": 790, "bucket_order": 2, "config": {}, "status": "active", "tags": ["instructor-note", "lecture13", "课堂问答"], "num_favorites": 0, "bucket_name": "Today", "q_edits": [], "data": {"embed_links": []}, "request_instructor": 0, "created": "2016-04-10T16:14:33Z", "is_tag_good": false, "type": "note", "s_edits": [], "my_favorite": false, "default_anonymity": "no", "t": 1460388655585, "tag_good": [], "tag_good_arr": [], "history": [{"content": "<p>请向勇班的同学把“第十三讲 实验四 内核线程管理”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-3-lab4-spoc-discussion.md#lab4-spoc-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-3-lab4-spoc-discussion.md#lab4-spoc-思考题</a></p>\n<p><br />第十三讲的回答的截止时间是今天&#xff08;20160411&#xff09;晚20点前。<br /> <br />要求&#xff1a;每个依据自己对课程内容的掌握情况&#xff0c;选择做“基础题目”或“较难题目”。不需要两种选择都做。<br />1. 基础题目&#xff1a;有8个“个人思考题”&#xff0c;每个人只需要完成一个题目。依据自己的学号除8后的余数&#xff0c;完成与余数相同的题目&#xff0c;独立回答。<br />2. 较难题目&#xff1a;“小组练习与思考题”中的“<a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-3-lab4-spoc-discussion.md#练习3\" target=\"_blank\">练习3</a>”。最多二个人一组&#xff0c;也可以独立回答。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>\n<p></p>\n<p>选择“(1)”的同学<br />2013011409 王启圣</p>\n<p></p>\n<p>选择“(2)”的同学<br />Dichen Qian</p>\n<p></p>\n<p>选择“(3)”的同学<br />2013011411 朱新瑞<br />沈哲言 2013011371</p>\n<p></p>\n<p>选择“(4)”的同学<br />叶子鹏 2013011404</p>\n<p></p>\n<p>选择“(5)”的同学<br />杨明2013011412</p>\n<p></p>\n<p>选择“(6)”的同学<br />谢琛睿<br />尚智伟 2012011366</p>\n<p></p>\n<p>选择“(7)”的同学<br />徐捷 2012011371</p>\n<p></p>\n<p>选择“(8)”的同学<br />张浩天2013011416<br />霍健炜2016110024</p>\n<p></p>\n<p>选择“(练习3)”的同学<br />Dichen Qian<br />郭嘉丞<br />2012011355 王智默 2012011379 高越<br />2013011356 董豪宇 2013011302 李奕昕</p>", "anon": "no", "subject": "2016春季-第十三讲 课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-04-11T15:21:44Z"}, {"content": "<p>请向勇班的同学把“第十三讲 实验四 内核线程管理”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-3-lab4-spoc-discussion.md#lab4-spoc-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-3-lab4-spoc-discussion.md#lab4-spoc-思考题</a></p>\n<p><br />第十三讲的回答的截止时间是今天&#xff08;20160411&#xff09;晚20点前。<br /> <br />要求&#xff1a;每个依据自己对课程内容的掌握情况&#xff0c;选择做“基础题目”或“较难题目”。不需要两种选择都做。<br />1. 基础题目&#xff1a;有8个“个人思考题”&#xff0c;每个人只需要完成一个题目。依据自己的学号除8后的余数&#xff0c;完成与余数相同的题目&#xff0c;独立回答。<br />2. 较难题目&#xff1a;“小组练习与思考题”中的“<a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-3-lab4-spoc-discussion.md#练习3\" target=\"_blank\">练习3</a>”。最多二个人一组&#xff0c;也可以独立回答。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>", "anon": "no", "subject": "2016春季-第十三讲 课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-04-11T00:49:52Z"}, {"content": "<p>请向勇班的同学把“第十三讲 实验四 内核线程管理”中指定小题的回答结果写在此贴中对应题目后面。</p>\n<p></p>\n<p><a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-3-lab4-spoc-discussion.md#lab4-spoc-思考题\">https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-3-lab4-spoc-discussion.md#lab4-spoc-思考题</a></p>\n<p><br />第十三讲的回答的截止时间是今天&#xff08;20160411&#xff09;晚20点前。<br /> <br />要求&#xff1a;每个依据自己对课程内容的掌握情况&#xff0c;选择做“基础题目”或“较难题目”。不需要两种选择都做。<br />1. 基础题目&#xff1a;有8个“个人思考题”&#xff0c;每个人只需要完成一个题目。依据自己的学号除8后的余数&#xff0c;完成与余数相同的题目&#xff0c;独立回答。<br />2. 较难题目&#xff1a;“小组练习与思考题”中的“<a href=\"https://github.com/chyyuu/os_course_spoc_exercises/blob/master/all/05-3-lab4-spoc-discussion.md#练习3\" target=\"_blank\">练习3</a>”。最多二个人一组&#xff0c;也可以独立回答。</p>\n<p></p>\n<p>优胜者&#xff1a;</p>", "anon": "no", "subject": "2016春季-第十三讲 课堂思考题回答-向勇班", "uid": "hdjonbiyfs62ie", "created": "2016-04-10T16:14:33Z"}]}, "error": null}