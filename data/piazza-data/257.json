{"aid": "igkpgim21s74r", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 7, "request_instructor": 0, "history": [{"uid": "hdjonbiyfs62ie", "anon": "no", "created": "2015-04-08T06:50:24Z", "content": "<p>对上次课的进程管理系统进行完善&#xff0c;以支持进程等待。</p>\n<p></p>\n<p>题目&#xff1a;</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/05-2-spoc-discussion.md#spoc%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/xuyongjiande/os_exercises/blob/master/all/05-2-spoc-discussion.md#spoc%E5%B0%8F%E7%BB%84%E6%80%9D%E8%80%83%E9%A2%98</a></p>\n<p></p>\n<p>请参与课堂讨论的同学以小组为单位回复你们的结果。</p>", "subject": "第6周第一次操作系统课堂思考题回答"}], "s_edits": [], "tag_good_arr": [], "is_bookmarked": false, "my_favorite": false, "t": 1446635555642, "children": [{"uid": "i6t1w87gRBD", "no_answer": 1, "created": "2015-04-08T07:08:12Z", "id": "i88e9c7pd6b23q", "updated": "2015-04-08T07:08:12Z", "subject": "<p></p><pre><br />#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process switch behavior\nSCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;\n\n# io finished behavior\nIO_RUN_LATER = &#39;IO_RUN_LATER&#39;\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\nSTATE_WAIT = &#39;WAITING&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\nDO_IO = &#39;io&#39;\n\nclass scheduler:\n    def __init__(self, process_switch_behavior, io_done_behavior, io_length):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.process_switch_behavior = process_switch_behavior\n        self.io_done_behavior = io_done_behavior\n        self.io_length = io_length\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 3:\n            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is YIELD&#39;\n            print &#39;  and Z is the percent change that an instruction is IO&#39;\n            exit(1)\n\n        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0\n        assert(chance_yield&#43;chance_io&lt;1)\n\n        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)\n        for i in range(num_instructions):\n            randnum=random.random();\n            if randnum &lt; (1.0-chance_yield-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_IO)\n            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n\t\tif pid == -1:\n\t\t\tpid = self.curr_proc\n\t\tassert expected == self.proc_info[pid][PROC_STATE]\n\t\tself.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n\t\tassert expected == STATE_READY\n\t\tself.proc_info[curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n\t\tassert expected == STATE_RUNNING\n\t\tself.proc_info[pid][PROC_STATE] = STATE_DONE\n\t\tself.next_proc()\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n\t\tif pid == -1:\n\t\t\tpid = self.curr_proc\n\t\tl = len(self.proc_info[proc_id])\n\t\tif\n\t\tfor i in range (1, l &#43; 1):\n\t\t\tif self.proc_info[(pid&#43;i)%l][PROC_STATE] == STATE_READY:\n\t\t\t\tself.curr_proc = (pid&#43;i)%l\n\t\t\t\tself.move_to_running(STATE_READY)\n\t\t\t\tbreak\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def get_ios_in_flight(self, current_time):\n        num_in_flight = 0\n        for pid in range(len(self.proc_info)):\n            for t in self.io_finish_times[pid]:\n                if t &gt; current_time:\n                    num_in_flight &#43;= 1\n        return num_in_flight\n\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # track outstanding IOs, per process\n        self.io_finish_times = {}\n        for pid in range(len(self.proc_info)):\n            self.io_finish_times[pid] = []\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n        print &#39;%10s&#39; % &#39;CPU&#39;,\n        print &#39;%10s&#39; % &#39;IOs&#39;,\n        print &#39;&#39;\n\n        # init statistics\n        io_busy = 0\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # check for io finish\n            io_done = False\n            for pid in range(len(self.proc_info)):\n                if clock_tick in self.io_finish_times[pid]:\n                    # if IO finished, the should do something for related process\n       \t            #YOUR CODE\n\t\t\t\t\tself.move_to_ready(WAITING, pid)\n\t\t\t\t\tself.next_proc()\n\t\t\t\t\tio_done = True\n                    #pass #YOU should delete this\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #pop a instruction from proc_info[self.curr_proc][PROC_CODE]to instruction_to_execute\n                #YOUR CODE\n\t\t\t\tinstruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\t\t\t\t\n                #pass #YOU should delete this\n\n            # OUTPUT: print what everyone is up to\n            if io_done:\n                print &#39;%3d*&#39; % clock_tick,\n            else:\n                print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n            if instruction_to_execute == &#39;&#39;:\n                print &#39;%10s&#39; % &#39; &#39;,\n            else:\n                print &#39;%10s&#39; % 1,\n            num_outstanding = self.get_ios_in_flight(clock_tick)\n            if num_outstanding &gt; 0:\n                print &#39;%10s&#39; % str(num_outstanding),\n                io_busy &#43;= 1\n            else:\n                print &#39;%10s&#39; % &#39; &#39;,\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n\t\t\t\tself.move_to_ready(RUNNING)\n                #pass #YOU should delete this\n            # if this is an IO instruction, switch to waiting state\n            # and add an io completion in the future\n            elif instruction_to_execute == DO_IO:\n                #YOUR CODE\n                self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT\n                self.io_finish_times[self.curr_proc].append(clock_tick&#43;io_length&#43;1)\n                self.next_proc()\n                #pass #YOU should delete this\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (cpu_busy, io_busy, clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1:Z1,X2:Y2:Z2,... where X is the number of instructions that process should run, and Y/Z the chances (from 0 to 100) issue an YIELD/IO&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-L&#39;, &#39;--iolength&#39;, default=3, help=&#39;how long an IO takes&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;io_length&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprocess_switch_behavior = SCHED_SWITCH_ON_IO\nio_done_behavior = IO_RUN_LATER\nio_length=options.io_length\n\n\ns = scheduler(process_switch_behavior, io_done_behavior, io_length)\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint</pre>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 3, "bucket_name": "Yesterday", "no_upvotes": 0, "d-bucket": "Yesterday", "children": [], "type": "followup"}, {"uid": "i6t6y9snjx2", "no_answer": 1, "created": "2015-04-08T13:42:42Z", "id": "i88sco9b7eg6cd", "updated": "2015-04-08T13:42:42Z", "subject": "<p>计25 矣晓沅</p>\n<p>计23 李雪</p>\n<p></p>\n<p>#! /usr/bin/env python<br /><br />import sys<br />from optparse import OptionParser<br />import random<br /><br /># process switch behavior<br />SCHED_SWITCH_ON_IO = &#39;SWITCH_ON_IO&#39;<br /><br /># io finished behavior<br />IO_RUN_LATER = &#39;IO_RUN_LATER&#39;<br /><br /># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;<br />STATE_WAIT = &#39;WAITING&#39;<br /><br /># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;<br /><br /># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;<br />DO_IO = &#39;io&#39;<br /><br />class scheduler:<br />    def __init__(self, process_switch_behavior, io_done_behavior, io_length):<br />        # keep set of instructions for each of the processes<br />        self.proc_info = {}<br />        self.process_switch_behavior = process_switch_behavior<br />        self.io_done_behavior = io_done_behavior<br />        self.io_length = io_length<br />        return<br /><br />    def new_process(self):<br />        proc_id = len(self.proc_info)<br />        self.proc_info[proc_id] = {}<br />        self.proc_info[proc_id][PROC_PC] = 0<br />        self.proc_info[proc_id][PROC_ID] = proc_id<br />        self.proc_info[proc_id][PROC_CODE] = []<br />        self.proc_info[proc_id][PROC_STATE] = STATE_READY<br />        return proc_id<br /><br />    def load(self, program_description):<br />        proc_id = self.new_process()<br />        tmp = program_description.split(&#39;:&#39;)<br />        if len(tmp) != 3:<br />            print &#39;Bad description (%s): Must be number &lt;x:y:z&gt;&#39;<br />            print &#39;  where X is the number of instructions&#39;<br />            print &#39;  and Y is the percent change that an instruction is YIELD&#39;<br />            print &#39;  and Z is the percent change that an instruction is IO&#39;<br />            exit(1)<br /><br />        num_instructions, chance_yield, chance_io = int(tmp[0]), float(tmp[1])/100.0, float(tmp[2])/100.0<br />        assert(chance_yield&#43;chance_io&lt;1)<br /><br />        #print &#34;proc %d, num_instr %d, change_cpu %f&#34; % (proc_id,num_instructions, chance_cpu)<br />        for i in range(num_instructions):<br />            randnum=random.random();<br />            if randnum &lt; (1.0-chance_yield-chance_io):<br />                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br />            elif randnum &gt;= (1.0-chance_yield-chance_io) and randnum &lt; (1.0-chance_io):<br />                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br />            else:<br />                self.proc_info[proc_id][PROC_CODE].append(DO_IO)<br />            #print &#34;proc %d, instr idx %d, instr cxt %s&#34; % (proc_id, i, self.proc_info[proc_id][PROC_CODE][i])<br />        return<br /><br />    #change to READY STATE, the current proc&#39;s state should be expected<br />    #if pid==-1, then pid=self.curr_proc<br />    def move_to_ready(self, expected, pid=-1):<br />        #YOUR CODE<br />        if (pid == -1):<br />            pid = self.curr_proc<br />        if (self.proc_info[self.curr_proc][PROC_STATE] == expected):<br />            self.proc_info[pid][PROC_STATE] = STATE_READY<br />        return<br /><br />    #change to RUNNING STATE, the current proc&#39;s state should be expected<br />    def move_to_running(self, expected):<br />        #YOUR CODE<br />        if (self.proc_info[self.curr_proc][PROC_STATE] == expected):<br />            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING <br />        return<br /><br />    def move_to_wait(self, expected):<br />        #YOUR CODE<br />        if (self.proc_info[self.curr_proc][PROC_STATE] == expected):<br />            self.proc_info[self.curr_proc][PROC_STATE] = STATE_WAIT <br />        return<br />    #change to DONE STATE, the current proc&#39;s state should be expected<br />    def move_to_done(self, expected):<br />        #YOUR CODE<br />        if (self.proc_info[self.curr_proc][PROC_STATE] == expected):<br />            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br />        return<br /><br />    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br />    def next_proc(self, pid=-1):<br />        #YOUR CODE<br />        if (pid == -1):<br />            pid = self.curr_proc<br />        n = len(self.proc_info)<br />        for i in range(1, n&#43;1, 1):<br />            if self.proc_info[(pid&#43;i)%n][PROC_STATE] == STATE_READY:<br />                self.curr_proc = (pid&#43;i) % n<br />                self.move_to_running(STATE_READY)<br />                break<br />        return<br /><br />    def get_num_processes(self):<br />        return len(self.proc_info)<br /><br />    def get_num_instructions(self, pid):<br />        return len(self.proc_info[pid][PROC_CODE])<br /><br />    def get_instruction(self, pid, index):<br />        return self.proc_info[pid][PROC_CODE][index]<br /><br />    def get_num_active(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def get_num_runnable(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br />                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def get_ios_in_flight(self, current_time):<br />        num_in_flight = 0<br />        for pid in range(len(self.proc_info)):<br />            for t in self.io_finish_times[pid]:<br />                if t &gt; current_time:<br />                    num_in_flight &#43;= 1<br />        return num_in_flight<br /><br /><br />    def space(self, num_columns</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6utvrywozd2vd", "no_answer": 1, "created": "2015-04-08T15:19:11Z", "id": "i88vsqwau5t4p7", "updated": "2015-04-08T15:19:11Z", "subject": "<p>陈天昱 2012011348</p>\n<p>李心田 2012011338</p>\n<p></p>\n<p><a href=\"https://github.com/cty12/os_exercises/blob/master/src/05-2-spoc_coding/process-cpuio.py\" target=\"_blank\">https://github.com/cty12/os_exercises/blob/master/src/05-2-spoc_coding/process-cpuio.py</a></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [{"uid": "i6utvrywozd2vd", "created": "2015-04-08T15:30:04Z", "id": "i88w6qq9v7v3n9", "updated": "2015-04-08T15:30:04Z", "subject": "<p>抱歉交错地方了。</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i71i9b92nrr7n4", "no_answer": 1, "created": "2015-04-08T15:29:13Z", "id": "i88w5nea8xc2jc", "updated": "2015-04-08T15:29:13Z", "subject": "梁錫豪 2012011290\n\nhttps://github.com/liangxh/os_exercises/blob/master/all/05-2-spoc-discussion.md", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [], "type": "followup"}], "type": "note", "unique_views": 66, "created": "2015-04-08T06:50:24Z", "id": "i88dmgpxs85bf", "tags": ["instructor-note", "quiz12", "课堂问答"], "nr": 257, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {"is_announcement": 1}, "folders": ["课堂问答", "quiz12"], "bucket_order": 2, "change_log": [{"uid": "hdjonbiyfs62ie", "when": "2015-04-08T06:50:24Z", "data": "i88dmgpzrrd5bg", "anon": "no", "type": "create"}, {"uid": "i6t1w87gRBD", "when": "2015-04-08T07:08:12Z", "to": "i88dmgpxs85bf", "anon": "no", "type": "followup"}, {"uid": "i6t6y9snjx2", "when": "2015-04-08T13:42:42Z", "to": "i88dmgpxs85bf", "anon": "no", "type": "followup"}, {"uid": "i6utvrywozd2vd", "when": "2015-04-08T15:19:11Z", "to": "i88dmgpxs85bf", "anon": "no", "type": "followup"}, {"uid": "i71i9b92nrr7n4", "when": "2015-04-08T15:29:13Z", "to": "i88dmgpxs85bf", "anon": "no", "type": "followup"}, {"uid": "i6utvrywozd2vd", "when": "2015-04-08T15:30:04Z", "to": "i88dmgpxs85bf", "anon": "no", "type": "feedback"}], "bucket_name": "Today", "request_instructor_me": false, "no_answer_followup": 4, "num_favorites": 0, "tag_good": []}}