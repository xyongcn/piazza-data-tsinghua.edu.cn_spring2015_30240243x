{"aid": "igkpou5c6tu6y8", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 7, "request_instructor": 0, "history": [{"uid": "hdjonbiyfs62ie", "anon": "no", "created": "2015-04-22T06:55:29Z", "content": "<p>下面是要求同学实验三种调度算法&#xff0c;并给出性能统计信息。</p>\n<p><a href=\"https://github.com/xuyongjiande/os_exercises/blob/master/all/06-1-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98\">https://github.com/xuyongjiande/os_exercises/blob/master/all/06-1-spoc-discussion.md#%E5%B0%8F%E7%BB%84%E7%BB%83%E4%B9%A0%E4%B8%8E%E6%80%9D%E8%80%83%E9%A2%98</a></p>\n<p></p>\n<p>请参与课堂讨论的同学在此回复你的回复。</p>", "subject": "第15讲课堂练习回答"}], "s_edits": [], "tag_good_arr": [], "is_bookmarked": false, "my_favorite": false, "t": 1446635943839, "children": [{"uid": "i6t6y9snjx2", "no_answer": 1, "created": "2015-04-22T07:25:38Z", "id": "i8sf1p2ujm33o9", "updated": "2015-04-22T07:25:38Z", "subject": "<p>计25 矣晓沅 袁泰凌</p>\n<p>https://github.com/MtMoon/os_exercises/blob/master/all/scheduler.py</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6ub691ffHe", "no_answer": 1, "created": "2015-04-22T07:36:40Z", "id": "i8sffvipj1hgv", "updated": "2015-04-22T07:36:40Z", "subject": "<p>党唯真 2012011324</p>\n<pre>#! /usr/bin/env python\nimport sys\nfrom optparse import OptionParser\nimport random\nparser = OptionParser()\nparser.add_option(&#34;-s&#34;, &#34;--seed&#34;, default=0, help=&#34;the random seed&#34;, \naction=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;seed&#34;)\nparser.add_option(&#34;-j&#34;, &#34;--jobs&#34;, default=3, help=&#34;number of jobs in the system&#34;,\naction=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;jobs&#34;)\nparser.add_option(&#34;-l&#34;, &#34;--jlist&#34;, default=&#34;&#34;, help=&#34;instead of random jobs, provide a comma-separated list of run times&#34;,\naction=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;jlist&#34;)\nparser.add_option(&#34;-m&#34;, &#34;--maxlen&#34;, default=10, help=&#34;max length of job&#34;,\naction=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;maxlen&#34;)\nparser.add_option(&#34;-p&#34;, &#34;--policy&#34;, default=&#34;FIFO&#34;, help=&#34;sched policy to use: SJF, FIFO, RR&#34;,\naction=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;policy&#34;)\nparser.add_option(&#34;-q&#34;, &#34;--quantum&#34;, help=&#34;length of time slice for RR policy&#34;, default=1, \naction=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;quantum&#34;)\nparser.add_option(&#34;-c&#34;, help=&#34;compute answers for me&#34;, action=&#34;store_true&#34;, default=True, dest=&#34;solve&#34;)\n(options, args) = parser.parse_args()\nrandom.seed(options.seed)\nprint &#39;ARG policy&#39;, options.policy\nif options.jlist == &#39;&#39;:\nprint &#39;ARG jobs&#39;, options.jobs\nprint &#39;ARG maxlen&#39;, options.maxlen\nprint &#39;ARG seed&#39;, options.seed\nelse:\nprint &#39;ARG jlist&#39;, options.jlist\nprint &#39;&#39;\nprint &#39;Here is the job list, with the run time of each job: &#39;\nimport operator\njoblist = []\nif options.jlist == &#39;&#39;:\nfor jobnum in range(0,options.jobs):\nruntime = int(options.maxlen * random.random()) &#43; 1\njoblist.append([jobnum, runtime])\nprint &#39; Job&#39;, jobnum, &#39;( length = &#39; &#43; str(runtime) &#43; &#39; )&#39;\nelse:\njobnum = 0\nfor runtime in options.jlist.split(&#39;,&#39;):\njoblist.append([jobnum, float(runtime)])\njobnum &#43;= 1\nfor job in joblist:\nprint &#39; Job&#39;, job[0], &#39;( length = &#39; &#43; str(job[1]) &#43; &#39; )&#39;\nprint &#39;\\n&#39;\nif options.solve == True:\nprint &#39;** Solutions **\\n&#39;\nif options.policy == &#39;SJF&#39;:\n#YOUR CODE\nsystime = 0\njoblist.sort(key=operator.itemgetter(1))\nfor tmp in joblist:\nprint &#39;[ time %3d ] Run job %3d for %3.2f secs ( DONE at %3.2f )&#39; % (systime, tmp[0], tmp[1], systime &#43; tmp[1])\nsystime &#43;= tmp[1]\nprint &#39;\\nFinal statistics:&#39;\nt = 0.0\ncount = 0\nturnaroundSum = 0.0\nwaitSum = 0.0\nresponseSum = 0.0\nfor tmp in joblist:\njobnum = tmp[0]\nruntime = tmp[1]\n\nresponse = t\nturnaround = t &#43; runtime\nwait = t\nprint &#39; Job %3d -- Response: %3.2f Turnaround %3.2f Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\nresponseSum &#43;= response\nturnaroundSum &#43;= turnaround\nwaitSum &#43;= wait\nt &#43;= runtime\ncount = count &#43; 1\nprint &#39;\\n Average -- Response: %3.2f Turnaround %3.2f Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\n#pass\n\nif options.policy == &#39;FIFO&#39;:\nthetime = 0\nprint &#39;Execution trace:&#39;\n#YOUR CODE\nsystime = 0\nfor tmp in joblist:\nprint &#39;[ time %3d ] Run job %3d for %3.2f secs ( DONE at %3.2f )&#39; % (systime, tmp[0], tmp[1], systime &#43; tmp[1])\nsystime &#43;= tmp[1]\nprint &#39;\\nFinal statistics:&#39;\nt = 0.0\ncount = 0\nturnaroundSum = 0.0\nwaitSum = 0.0\nresponseSum = 0.0\nfor tmp in joblist:\njobnum = tmp[0]\nruntime = tmp[1]\n\nresponse = t\nturnaround = t &#43; runtime\nwait = t\nprint &#39; Job %3d -- Response: %3.2f Turnaround %3.2f Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\nresponseSum &#43;= response\nturnaroundSum &#43;= turnaround\nwaitSum &#43;= wait\nt &#43;= runtime\ncount = count &#43; 1\nprint &#39;\\n Average -- Response: %3.2f Turnaround %3.2f Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\nif options.policy == &#39;RR&#39;:\nprint &#39;Execution trace:&#39;\nturnaround = {}\nresponse = {}\nlastran = {}\nwait = {}\nquantum = float(options.quantum)\njobcount = len(joblist)\nfor i in range(0,jobcount):\nlastran[i] = 0.0\nwait[i] = 0.0\nturnaround[i] = 0.0\nresponse[i] = -1\nrunlist = []\nfor e in joblist:\nrunlist.append(e)\nthetime = 0.0\nwhile jobcount &gt; 0:\n# print &#39;%d jobs remaining&#39; % jobcount\njob = runlist.pop(0)\njobnum = job[0]\nruntime = float(job[1])\nif response[jobnum] == -1:\nresponse[jobnum] = thetime\ncurrwait = thetime - lastran[jobnum]\nwait[jobnum] &#43;= currwait\nranfor = 0\nif runtime &gt; quantum:\n#YOUR CODE\nruntime = runtime - quantum\nranfor = quantum\nprint &#39; [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\nrunlist.append([jobnum, runtime])\nelse:\n#YOUR CODE\nranfor = runtime\nprint &#39; [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\nturnaround[jobnum] = thetime &#43; ranfor\njobcount -= 1\nthetime &#43;= ranfor\nlastran[jobnum] = thetime\nprint &#39;\\nFinal statistics:&#39;\nturnaroundSum = 0.0\nwaitSum = 0.0\nresponseSum = 0.0\nfor i in range(0,len(joblist)):\nturnaroundSum &#43;= turnaround[i]\nresponseSum &#43;= response[i]\nwaitSum &#43;= wait[i]\nprint &#39; Job %3d -- Response: %3.2f Turnaround %3.2f Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])\ncount = len(joblist)\n\nprint &#39;\\n Average -- Response: %3.2f Turnaround %3.2f Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\nif options.policy != &#39;FIFO&#39; and options.policy != &#39;SJF&#39; and options.policy != &#39;RR&#39;: \nprint &#39;Error: Policy&#39;, options.policy, &#39;is not available.&#39;\nsys.exit(0)\nelse:\nprint &#39;Compute the turnaround time, response time, and wait time for each job.&#39;\nprint &#39;When you are done, run this program again, with the same arguments,&#39;\nprint &#39;but with -c, which will thus provide you with the answers. You can use&#39;\nprint &#39;-s &lt;somenumber&gt; or your own job list (-l 10,15,20 for example)&#39;\nprint &#39;to generate different problems for yourself.&#39;\nprint &#39;&#39;</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6t7nhkesez6wr", "no_answer": 1, "created": "2015-04-22T07:41:04Z", "id": "i8sflj8qfh57ku", "updated": "2015-04-22T07:41:04Z", "subject": "<p>陈辉 2012011328</p>\n<p>王昊 2012011341</p>\n<pre><tt>#! /usr/bin/env python<br /><br />import sys<br />from optparse import OptionParser<br />import random<br /><br />parser = OptionParser()<br />parser.add_option(&#34;-s&#34;, &#34;--seed&#34;, default=0, help=&#34;the random seed&#34;, <br />                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;seed&#34;)<br />parser.add_option(&#34;-j&#34;, &#34;--jobs&#34;, default=3, help=&#34;number of jobs in the system&#34;,<br />                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;jobs&#34;)<br />parser.add_option(&#34;-l&#34;, &#34;--jlist&#34;, default=&#34;&#34;, help=&#34;instead of random jobs, provide a comma-separated list of run times&#34;,<br />                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;jlist&#34;)<br />parser.add_option(&#34;-m&#34;, &#34;--maxlen&#34;, default=10, help=&#34;max length of job&#34;,<br />                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;maxlen&#34;)<br />parser.add_option(&#34;-p&#34;, &#34;--policy&#34;, default=&#34;FIFO&#34;, help=&#34;sched policy to use: SJF, FIFO, RR&#34;,<br />                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;policy&#34;)<br />parser.add_option(&#34;-q&#34;, &#34;--quantum&#34;, help=&#34;length of time slice for RR policy&#34;, default=1, <br />                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;quantum&#34;)<br />parser.add_option(&#34;-c&#34;, help=&#34;compute answers for me&#34;, action=&#34;store_true&#34;, default=True, dest=&#34;solve&#34;)<br /><br />(options, args) = parser.parse_args()<br /><br />random.seed(options.seed)<br /><br />print &#39;ARG policy&#39;, options.policy<br />if options.jlist == &#39;&#39;:<br />    print &#39;ARG jobs&#39;, options.jobs<br />    print &#39;ARG maxlen&#39;, options.maxlen<br />    print &#39;ARG seed&#39;, options.seed<br />else:<br />    print &#39;ARG jlist&#39;, options.jlist<br /><br />print &#39;&#39;<br /><br />print &#39;Here is the job list, with the run time of each job: &#39;<br /><br />import operator<br /><br />joblist = []<br />if options.jlist == &#39;&#39;:<br />    for jobnum in range(0,options.jobs):<br />        runtime = int(options.maxlen * random.random()) &#43; 1<br />        joblist.append([jobnum, runtime])<br />        print &#39;  Job&#39;, jobnum, &#39;( length = &#39; &#43; str(runtime) &#43; &#39; )&#39;<br />else:<br />    jobnum = 0<br />    for runtime in options.jlist.split(&#39;,&#39;):<br />        joblist.append([jobnum, float(runtime)])<br />        jobnum &#43;= 1<br />    for job in joblist:<br />        print &#39;  Job&#39;, job[0], &#39;( length = &#39; &#43; str(job[1]) &#43; &#39; )&#39;<br />print &#39;\\n&#39;<br /><br />if options.solve == True:<br />    print &#39;** Solutions **\\n&#39;<br />    if options.policy == &#39;SJF&#39;:<br />\t\t#YOUR CODE<br />\t\tprint &#39;SIF policy result :\\n&#39;<br />\t\tjoblist.sort(cmp=lambda x, y : cmp(x[1],y[1]))<br />\t\tfor i in joblist:<br />\t\t\tprint &#39;the jobnum is : &#39;, i[0], &#39; and its last time is : &#39;,i[1]<br />\t\tprint &#39;\\nFinal statistics:&#39;<br />\t\tt     = 0.0<br />\t\tcount = 0<br />\t\tturnaroundSum = 0.0<br />\t\twaitSum       = 0.0<br />\t\tresponseSum   = 0.0<br />\t\tfor tmp in joblist:<br />\t\t    jobnum  = tmp[0]<br />\t\t    runtime = tmp[1]<br />\t\t    <br />\t\t    response   = t<br />\t\t    turnaround = t &#43; runtime<br />\t\t    wait       = t<br />\t\t    print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)<br />\t\t    responseSum   &#43;= response<br />\t\t    turnaroundSum &#43;= turnaround<br />\t\t    waitSum       &#43;= wait<br />\t\t    t &#43;= runtime<br />\t\t    count = count &#43; 1<br />\t\tprint &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)<br />    if options.policy == &#39;FIFO&#39;:<br />        thetime = 0<br />        #print &#39;FIFO result:\\n&#39;<br />        print &#39;FIFO result:\\nExecution trace:&#39;<br />\t\t#YOUR CODE<br />      \tfor i in joblist:<br />\t\t    print &#39;the jobnum is : &#39;, i[0], &#39; and its last time is : &#39;,i[1]<br />        print &#39;\\nFinal statistics:&#39;<br />        t     = 0.0<br />        count = 0<br />        turnaroundSum = 0.0<br />        waitSum       = 0.0<br />        responseSum   = 0.0<br />        for tmp in joblist:<br />            jobnum  = tmp[0]<br />            runtime = tmp[1]<br />            <br />            response   = t<br />            turnaround = t &#43; runtime<br />            wait       = t<br />            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)<br />            responseSum   &#43;= response<br />            turnaroundSum &#43;= turnaround<br />            waitSum       &#43;= wait<br />            t &#43;= runtime<br />            count = count &#43; 1<br />        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)<br />                     <br />    if options.policy == &#39;RR&#39;:<br />        print &#39;Execution trace:&#39;<br />        turnaround = {}<br />        response = {}<br />        lastran = {}<br />        wait = {}<br />        quantum  = float(options.quantum)<br />        jobcount = len(joblist)<br />        for i in range(0,jobcount):<br />            lastran[i] = 0.0<br />            wait[i] = 0.0<br />            turnaround[i] = 0.0<br />            response[i] = -1<br /><br />        runlist = []<br />        for e in joblist:<br />            runlist.append(e)<br /><br />        thetime  = 0.0<br />        while jobcount &gt; 0:<br />            # print &#39;%d jobs remaining&#39; % jobcount<br />            job = runlist.pop(0)<br />            jobnum  = job[0]<br />            runtime = float(job[1])<br />            if response[jobnum] == -1:<br />                response[jobnum] = thetime<br />            currwait = thetime - lastran[jobnum]<br />            wait[jobnum] &#43;= currwait<br />            ranfor = 0<br />            if runtime &gt; quantum:<br />\t\t\t\t#YOUR CODE<br />                runtime = runtime - quantum<br />                ranfor = quantum<br />                print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)<br />                runlist.append([jobnum, runtime])<br />            else:<br />                #YOUR CODE<br />                ranfor = runtime<br />                print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)<br />                turnaround[jobnum] = thetime &#43; ranfor<br />                jobcount -= 1<br />            thetime &#43;= ranfor<br />            lastran[jobnum] = thetime<br /><br />        print &#39;\\nFinal statistics:&#39;<br />        turnaroundSum = 0.0<br />        waitSum       = 0.0<br />        responseSum   = 0.0<br />        for i in range(0,len(joblist)):<br />            turnaroundSum &#43;= turnaround[i]<br />            responseSum &#43;= response[i]<br />            waitSum &#43;= wait[i]<br />            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])<br />        count = len(joblist)<br />        <br />        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)<br /><br />    if options.policy != &#39;FIFO&#39; and options.policy != &#39;SJF&#39; and options.policy != &#39;RR&#39;: <br />        print &#39;Error: Policy&#39;, options.policy, &#39;is not available.&#39;<br />        sys.exit(0)<br />else:<br />    print &#39;Compute the turnaround time, response time, and wait time for each job.&#39;<br />    print &#39;When you are done, run this program again, with the same arguments,&#39;<br />    print &#39;but with -c, which will thus provide you with the answers. You can use&#39;<br />    print &#39;-s &lt;somenumber&gt; or your own job list (-l 10,15,20 for example)&#39;<br />    print &#39;to generate different problems for yourself.&#39;<br />    print &#39;&#39;<br /><br /></tt></pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i71i9b92nrr7n4", "no_answer": 1, "created": "2015-04-22T09:02:43Z", "id": "i8siijgdhti2a4", "updated": "2015-04-22T09:02:43Z", "subject": "<p>计22 梁锡豪 2012011290</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\nparser = OptionParser()\nparser.add_option(&#34;-s&#34;, &#34;--seed&#34;, default=0, help=&#34;the random seed&#34;, \n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;seed&#34;)\nparser.add_option(&#34;-j&#34;, &#34;--jobs&#34;, default=3, help=&#34;number of jobs in the system&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;jobs&#34;)\nparser.add_option(&#34;-l&#34;, &#34;--jlist&#34;, default=&#34;&#34;, help=&#34;instead of random jobs, provide a comma-separated list of run times&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;jlist&#34;)\nparser.add_option(&#34;-m&#34;, &#34;--maxlen&#34;, default=10, help=&#34;max length of job&#34;,\n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;maxlen&#34;)\nparser.add_option(&#34;-p&#34;, &#34;--policy&#34;, default=&#34;FIFO&#34;, help=&#34;sched policy to use: SJF, FIFO, RR&#34;,\n                  action=&#34;store&#34;, type=&#34;string&#34;, dest=&#34;policy&#34;)\nparser.add_option(&#34;-q&#34;, &#34;--quantum&#34;, help=&#34;length of time slice for RR policy&#34;, default=1, \n                  action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;quantum&#34;)\nparser.add_option(&#34;-c&#34;, help=&#34;compute answers for me&#34;, action=&#34;store_true&#34;, default=True, dest=&#34;solve&#34;)\n\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\nprint &#39;ARG policy&#39;, options.policy\nif options.jlist == &#39;&#39;:\n    print &#39;ARG jobs&#39;, options.jobs\n    print &#39;ARG maxlen&#39;, options.maxlen\n    print &#39;ARG seed&#39;, options.seed\nelse:\n    print &#39;ARG jlist&#39;, options.jlist\n\nprint &#39;&#39;\n\nprint &#39;Here is the job list, with the run time of each job: &#39;\n\nimport operator\n\njoblist = []\nif options.jlist == &#39;&#39;:\n    for jobnum in range(0,options.jobs):\n        runtime = int(options.maxlen * random.random()) &#43; 1\n        joblist.append([jobnum, runtime])\n        print &#39;  Job&#39;, jobnum, &#39;( length = &#39; &#43; str(runtime) &#43; &#39; )&#39;\nelse:\n    jobnum = 0\n    for runtime in options.jlist.split(&#39;,&#39;):\n        joblist.append([jobnum, float(runtime)])\n        jobnum &#43;= 1\n    for job in joblist:\n        print &#39;  Job&#39;, job[0], &#39;( length = &#39; &#43; str(job[1]) &#43; &#39; )&#39;\nprint &#39;\\n&#39;\n\nif options.solve == True:\n    print &#39;** Solutions **\\n&#39;\n    if options.policy == &#39;SJF&#39;:\n\tjoblist = sorted(joblist, key = lambda d:d[1])\n\ttime = 0\n        print &#39;Execution trace:&#39;\n        for i in range(len(joblist)):\n\t    print &#39;[ time %3d ] Run job %d for %0.2f secs ( DONE at %0.2f)&#39;%(time, joblist[i][1], joblist[i][1], time &#43; joblist[i][1])\n\t    time &#43;= joblist[i][1]\n\n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)        \n\n    \tpass\n    \t\n    if options.policy == &#39;FIFO&#39;:\n        time = 0\n        print &#39;Execution trace:&#39;\n        for i in range(len(joblist)):\n\t    print &#39;[ time %3d ] Run job %d for %0.2f secs ( DONE at %0.2f)&#39;%(time, joblist[i][0], joblist[i][1], time &#43; joblist[i][1])\n\t    time &#43;= joblist[i][1]\n         \n        print &#39;\\nFinal statistics:&#39;\n        t     = 0.0\n        count = 0\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for tmp in joblist:\n            jobnum  = tmp[0]\n            runtime = tmp[1]\n            \n            response   = t\n            turnaround = t &#43; runtime\n            wait       = t\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (jobnum, response, turnaround, wait)\n            responseSum   &#43;= response\n            turnaroundSum &#43;= turnaround\n            waitSum       &#43;= wait\n            t &#43;= runtime\n            count = count &#43; 1\n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n                     \n    if options.policy == &#39;RR&#39;:\n        print &#39;Execution trace:&#39;\n        turnaround = {}\n        response = {}\n        lastran = {}\n        wait = {}\n        quantum  = float(options.quantum)\n        jobcount = len(joblist)\n        for i in range(0,jobcount):\n            lastran[i] = 0.0\n            wait[i] = 0.0\n            turnaround[i] = 0.0\n            response[i] = -1\n\n        runlist = []\n        for e in joblist:\n            runlist.append(e)\n\n        thetime  = 0.0\n        while jobcount &gt; 0:\n            # print &#39;%d jobs remaining&#39; % jobcount\n            job = runlist.pop(0)\n            jobnum  = job[0]\n            runtime = float(job[1])\n            if response[jobnum] == -1:\n                response[jobnum] = thetime\n            currwait = thetime - lastran[jobnum]\n            wait[jobnum] &#43;= currwait\n            ranfor = 0\n            if runtime &gt; quantum:\n\t\t\t\t#YOUR CODE\n\t\tranfor = quantum\n\t\truntime -= quantum\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs&#39; % (thetime, jobnum, ranfor)\n                runlist.append([jobnum, runtime])\n            else:\n                #YOUR CODE\n\t\tranfor = quantum\n                print &#39;  [ time %3d ] Run job %3d for %.2f secs ( DONE at %.2f )&#39; % (thetime, jobnum, ranfor, thetime &#43; ranfor)\n                turnaround[jobnum] = thetime &#43; ranfor\n                jobcount -= 1\n            thetime &#43;= ranfor\n            lastran[jobnum] = thetime\n\n        print &#39;\\nFinal statistics:&#39;\n        turnaroundSum = 0.0\n        waitSum       = 0.0\n        responseSum   = 0.0\n        for i in range(0,len(joblist)):\n            turnaroundSum &#43;= turnaround[i]\n            responseSum &#43;= response[i]\n            waitSum &#43;= wait[i]\n            print &#39;  Job %3d -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f&#39; % (i, response[i], turnaround[i], wait[i])\n        count = len(joblist)\n        \n        print &#39;\\n  Average -- Response: %3.2f  Turnaround %3.2f  Wait %3.2f\\n&#39; % (responseSum/count, turnaroundSum/count, waitSum/count)\n\n    if options.policy != &#39;FIFO&#39; and options.policy != &#39;SJF&#39; and options.policy != &#39;RR&#39;: \n        print &#39;Error: Policy&#39;, options.policy, &#39;is not available.&#39;\n        sys.exit(0)\nelse:\n    print &#39;Compute the turnaround time, response time, and wait time for each job.&#39;\n    print &#39;When you are done, run this program again, with the same arguments,&#39;\n    print &#39;but with -c, which will thus provide you with the answers. You can use&#39;\n    print &#39;-s &lt;somenumber&gt; or your own job list (-l 10,15,20 for example)&#39;\n    print &#39;to generate different problems for yourself.&#39;\n    print &#39;&#39;\n\n </pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6uunp7jxDb", "no_answer": 1, "created": "2015-04-23T15:11:17Z", "id": "i8ub4dkx1ek4pa", "updated": "2015-04-23T15:11:17Z", "subject": "<p>计22 沈光耀</p>\n<p>https://github.com/sunlightsgy/ucore_lab/blob/master/related_info/lab6/scheduler-homework.py</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [], "type": "followup"}], "type": "note", "unique_views": 65, "created": "2015-04-22T06:55:29Z", "id": "i8sdywyhy8t7fp", "tags": ["instructor-note", "课堂问答"], "nr": 344, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {}, "folders": ["课堂问答"], "bucket_order": 2, "change_log": [{"uid": "hdjonbiyfs62ie", "when": "2015-04-22T06:55:29Z", "data": "i8sdywzccbz7fq", "anon": "no", "type": "create"}, {"uid": "i6t6y9snjx2", "when": "2015-04-22T07:25:38Z", "to": "i8sdywyhy8t7fp", "anon": "no", "type": "followup"}, {"uid": "i6ub691ffHe", "when": "2015-04-22T07:36:40Z", "to": "i8sdywyhy8t7fp", "anon": "no", "type": "followup"}, {"uid": "i6t7nhkesez6wr", "when": "2015-04-22T07:41:04Z", "to": "i8sdywyhy8t7fp", "anon": "no", "type": "followup"}, {"uid": "i71i9b92nrr7n4", "when": "2015-04-22T09:02:43Z", "to": "i8sdywyhy8t7fp", "anon": "no", "type": "followup"}, {"uid": "i6uunp7jxDb", "when": "2015-04-23T15:11:17Z", "to": "i8sdywyhy8t7fp", "anon": "no", "type": "followup"}], "bucket_name": "Today", "request_instructor_me": false, "no_answer_followup": 5, "num_favorites": 0, "tag_good": []}}