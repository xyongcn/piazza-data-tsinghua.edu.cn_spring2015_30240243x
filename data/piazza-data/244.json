{"aid": "igkpfrd8ob2bg", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 8, "request_instructor": 0, "history": [{"uid": "hdjonbiyfs62ie", "anon": "no", "created": "2015-04-07T05:56:33Z", "content": "<p>问题&#xff1a;</p>\n<p><a href=\"http://os.cs.tsinghua.edu.cn/oscourse/OS2015/lecture11#head-98d1fbe3a28ebdc3be9de8cba1727c49b7261bf6\">http://os.cs.tsinghua.edu.cn/oscourse/OS2015/lecture11#head-98d1fbe3a28ebdc3be9de8cba1727c49b7261bf6</a></p>\n<p></p>\n<p>进程切换过程中的几个关键代码分析<br />1&#xff09;时钟中断触发调度函数的启动<br />2&#xff09;当前进程的现场保存代码<br />3&#xff09;进程切换代码<br />4&#xff09;下一个运行进程的现场恢复</p>\n<p></p>\n<p>请回复你找到的相关代码位置&#xff0c;并解释。</p>", "subject": "第6周第一次操作系统课堂练习回答"}], "s_edits": [], "tag_good_arr": [], "is_bookmarked": false, "my_favorite": false, "t": 1446635520332, "children": [{"uid": "i6uunp7jxDb", "no_answer": 1, "created": "2015-04-07T06:14:04Z", "id": "i86wvvgke0r3y5", "updated": "2015-04-07T06:14:04Z", "subject": "<p>沈光耀 胡津铭</p>\n<p>1)proc.c line183</p>\n<pre>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));\n\n以及\n\nvoid\ncpu_idle(void) {\n while (1) {\n if (current-&gt;need_resched) {\n schedule();\n }\n }\n}</pre>\n<p>2)switch.S</p>\n<pre> movl 4(%esp), %eax # eax points to from\n popl 0(%eax) # save eip !popl\n movl %esp, 4(%eax)\n movl %ebx, 8(%eax)\n movl %ecx, 12(%eax)\n movl %edx, 16(%eax)\n movl %esi, 20(%eax)\n movl %edi, 24(%eax)\n movl %ebp, 28(%eax)</pre>\n<p>首先获得这个进程的地址&#xff0c;然后把相应的参数都压栈</p>\n<p>3)proc.c</p>\n<pre>void\nproc_run(struct proc_struct *proc) {\n if (proc != current) {\n bool intr_flag;\n struct proc_struct *prev = current, *next = proc;\n local_intr_save(intr_flag);\n {\n current = proc;\n load_esp0(next-&gt;kstack &#43; KSTACKSIZE);\n lcr3(next-&gt;cr3);\n switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));\n }\n local_intr_restore(intr_flag);\n }\n}</pre>\n<p>4)switch.S</p>\n<pre>movl 4(%esp), %eax # not 8(%esp): popped return address already\n # eax now points to to\n movl 28(%eax), %ebp\n movl 24(%eax), %edi\n movl 20(%eax), %esi\n movl 16(%eax), %edx\n movl 12(%eax), %ecx\n movl 8(%eax), %ebx\n movl 4(%eax), %esp\n pushl 0(%eax) # push eip</pre>\n<p>这段第一句是获得了下一个进程的地址&#xff0c;然后把所有的东西都恢复&#xff0c;并把eip压入</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "hxu22d7okof4c1", "no_answer": 1, "created": "2015-04-07T06:18:51Z", "id": "i86x21g1w524mc", "updated": "2015-04-07T06:18:51Z", "subject": "<p>- 矣晓沅 计25</p>\n<p>- 袁泰凌 计25</p>\n<p></p>\n<p>1. kern/process/proc.c</p>\n<pre>void\ncpu_idle(void) {\n while (1) {\n if (current-&gt;need_resched) {\n schedule();\n }\n }\n}</pre>\n<p>中断后进入内核态的这个函数&#xff0c;再次调用schedule切换。</p>\n<p></p>\n<p>2. kern/process/switch.S</p>\n<pre>.text\n.globl switch_to\nswitch_to: # switch_to(from, to)\n# save from&#39;s registers\n movl 4(%esp), %eax # eax points to from\n popl 0(%eax) # save eip !popl\n movl %esp, 4(%eax)\n movl %ebx, 8(%eax)\n movl %ecx, 12(%eax)\n movl %edx, 16(%eax)\n movl %esi, 20(%eax)\n movl %edi, 24(%eax)\n movl %ebp, 28(%eax)\n# restore to&#39;s registers\n movl 4(%esp), %eax # not 8(%esp): popped return address already\n # eax now points to to\n movl 28(%eax), %ebp\n movl 24(%eax), %edi\n movl 20(%eax), %esi\n movl 16(%eax), %edx\n movl 12(%eax), %ecx\n movl 8(%eax), %ebx\n movl 4(%eax), %esp\npushl 0(%eax) # push eip\nret</pre>\n<p>&#96;# restore to&#39;s registers&#96;之前的代码用于保存当前进程。</p>\n<p>对%esp的解释&#xff1a;调用处的代码是&#96;switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));&#96;&#xff0c;所以4(%esp)是&amp;(prev-&gt;context)&#xff0c;8(%esp)是&amp;(next-&gt;context)。</p>\n<p></p>\n<p>3. kern/process/proc.c</p>\n<pre>void\nproc_run(struct proc_struct *proc) {\n if (proc != current) {\n bool intr_flag;\n struct proc_struct *prev = current, *next = proc;\n local_intr_save(intr_flag);\n {\n current = proc;\n load_esp0(next-&gt;kstack &#43; KSTACKSIZE);\n lcr3(next-&gt;cr3);\n switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));\n }\n local_intr_restore(intr_flag);\n }\n}</pre>\n<p></p>\n<p>4. kern/process/switch.S从</p>\n<pre># restore to&#39;s registers</pre>\n<p>这一行开始&#xff0c;后面的代码用于现场恢复</p>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6roqnlkmtw", "no_answer": 1, "created": "2015-04-07T06:31:29Z", "id": "i86xi9xdnhw11a", "updated": "2015-04-07T06:31:29Z", "subject": "<p>进程切换保存现场的代码在proc.c中</p>\n<p>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</p>\n<p></p>\n<p>在switch.S中</p>\n<p>movl 4(%esp), %eax          # eax points to from    </p>\n<p>获得了前一个进程的context</p>\n<p>之后popl 0(%eax)                # save eip !popl</p>\n<p>则原先在8(%esp)的next-&gt;context现在变成4(%esp)</p>\n<p>之后一连串move指令保存前一个进程的上下文</p>\n<p></p>\n<p>之后movl 4(%esp), %eax就是新进程的context</p>\n<p>通过一系列move指令回复了寄存器</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6rtbanwzcm5t6", "no_answer": 1, "created": "2015-04-07T06:33:28Z", "id": "i86xktjzls1ph", "updated": "2015-04-07T06:33:28Z", "subject": "<p>陈振寰 李心成</p>\n<p>1.</p>\n<p>首先在trap.c里285行的trap函数会判断current-&gt;need_resched</p>\n<pre>...<br />        trap_dispatch(tf);<br />    <br />        current-&gt;tf = otf;<br />        if (!in_kernel) {<br />            if (current-&gt;flags &amp; PF_EXITING) {<br />                do_exit(-E_KILLED);<br />            }<br />            if (current-&gt;need_resched) {<br />                schedule();<br />            }<br />        }<br />...<br /><br /></pre>\n<p>而这个值的修改在trap.c 244行&#xff0c;时钟中断调用run_timer_list()再调用sched_class_proc_tick()里修改。</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [{"uid": "i6rtbanwzcm5t6", "created": "2015-04-07T06:47:05Z", "id": "i86y2c95fbf1ac", "updated": "2015-04-07T06:47:05Z", "subject": "<p>2. &#xff08;第一题及以下回答都基于lab8answer&#xff09;</p>\n<p>在proc.c中231行。</p>\n<p>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</p>\n<p>在switch.S中&#xff0c;esp为函数栈底指针&#xff0c;4(%esp)是&amp;(prev-&gt;context)&#xff0c;再之后popl 0(%eax)&#xff0c;使得4(%esp)是&amp;(next-&gt;context)</p>\n<p>通过这两个参数进一步保存所有上下文。</p>\n<p>3. 进程切换及在proc.c中222行的proc_run函数</p>\n<p>4. 在switch.S的#restore to&#39;s registers之后进行寄存器的还原</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i71i9b92nrr7n4", "no_answer": 1, "created": "2015-04-07T07:01:15Z", "id": "i86ykjvv7g04h4", "updated": "2015-04-07T07:01:15Z", "subject": "計22 梁錫豪 2012011290\n\n(1) trap.c\nvoid trap(){\n        ...\n        trap_dispatch(tf);\n    \n        current-&gt;tf = otf;\n        if (!in_kernel) {\n            if (current-&gt;flags &amp; PF_EXITING) {\n                do_exit(-E_KILLED);\n            }\n            if (current-&gt;need_resched) {\n                schedule(); // 时钟中断触发调度函数的启动\n            }\n        }\n        ...\n}\n\n(2) switch.S\n# 当前进程的现场保存代码\n    # save from&#39;s registers\n    movl 4(%esp), %eax          # eax points to from\n    popl 0(%eax)                # save eip !popl\n    movl %esp, 4(%eax)\n    movl %ebx, 8(%eax)\n    movl %ecx, 12(%eax)\n    movl %edx, 16(%eax)\n    movl %esi, 20(%eax)\n    movl %edi, 24(%eax)\n    movl %ebp, 28(%eax)\n\n(3) proc.c \n// 进程切换代码\nvoid\nproc_run(struct proc_struct *proc) {\n    if (proc != current) {\n        bool intr_flag;\n        struct proc_struct *prev = current, *next = proc;\n        local_intr_save(intr_flag);\n        {\n            current = proc;\n            load_esp0(next-&gt;kstack &#43; KSTACKSIZE);\n            lcr3(next-&gt;cr3);\n            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); // 正式进行切换\n        }\n        local_intr_restore(intr_flag);\n    }\n}\n\n(4) switch.S\n    #下一个运行进程的现场恢复\n    # restore to&#39;s registers\n    movl 4(%esp), %eax          # not 8(%esp): popped return address already\n                                # eax now points to to\n    movl 28(%eax), %ebp\n    movl 24(%eax), %edi\n    movl 20(%eax), %esi\n    movl 16(%eax), %edx\n    movl 12(%eax), %ecx\n    movl 8(%eax), %ebx\n    movl 4(%eax), %esp", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 2, "bucket_name": "Today", "no_upvotes": 0, "children": [], "type": "followup"}], "type": "note", "unique_views": 82, "created": "2015-04-07T05:56:33Z", "id": "i86w9cldcup38t", "tags": ["instructor-note", "课堂问答"], "nr": 244, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {}, "folders": ["课堂问答"], "bucket_order": 2, "change_log": [{"uid": "hdjonbiyfs62ie", "when": "2015-04-07T05:56:33Z", "data": "i86w9clfurg38u", "anon": "no", "type": "create"}, {"uid": "i6uunp7jxDb", "when": "2015-04-07T06:14:04Z", "to": "i86w9cldcup38t", "anon": "no", "type": "followup"}, {"uid": "hxu22d7okof4c1", "when": "2015-04-07T06:18:51Z", "to": "i86w9cldcup38t", "anon": "no", "type": "followup"}, {"uid": "i6roqnlkmtw", "when": "2015-04-07T06:31:29Z", "to": "i86w9cldcup38t", "anon": "no", "type": "followup"}, {"uid": "i6rtbanwzcm5t6", "when": "2015-04-07T06:33:28Z", "to": "i86w9cldcup38t", "anon": "no", "type": "followup"}, {"uid": "i6rtbanwzcm5t6", "when": "2015-04-07T06:47:05Z", "to": "i86w9cldcup38t", "anon": "no", "type": "feedback"}, {"uid": "i71i9b92nrr7n4", "when": "2015-04-07T07:01:15Z", "to": "i86w9cldcup38t", "anon": "no", "type": "followup"}], "bucket_name": "Today", "request_instructor_me": false, "no_answer_followup": 5, "num_favorites": 0, "tag_good": []}}