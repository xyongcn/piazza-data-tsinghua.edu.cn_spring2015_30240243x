{"aid": "igkpbeav1ms46b", "error": null, "result": {"default_anonymity": "no", "status": "active", "i_edits": [], "q_edits": [], "bookmarked": 15, "request_instructor": 0, "history": [{"uid": "hdjonbiyfs62ie", "anon": "no", "created": "2015-03-30T06:15:03Z", "content": "<p>请参加课堂讨论的同学在回复中回答下面问题&#xff1a;</p>\n<p> </p>\n<p>1&#xff09;FIFO算法的页面队列对应的数据结构是什么&#xff1f;</p>\n<p>2&#xff09;FIFO算法的入队操作代码在哪&#xff1f;</p>\n<p>3&#xff09;FIFO算法的出队操作代码在哪&#xff1f;</p>\n<p>4&#xff09;你所在小组的置换算法实现结果&#xff1b;</p>", "subject": "第9讲的课堂思考题回答"}], "s_edits": [], "tag_good_arr": [], "is_bookmarked": false, "my_favorite": false, "t": 1446635316775, "children": [{"uid": "i6rtbanwzcm5t6", "no_answer": 0, "created": "2015-03-30T06:21:16Z", "id": "i7vhmbwz7wx77v", "updated": "2015-03-30T06:21:16Z", "subject": "<p>1. 对应memory这个队列</p>\n<p>2. 174行&#xff0c;memory.append(n)</p>\n<p>3. 112行&#xff0c;victim = memory.pop(0)</p>\n<p>陈振寰&#xff0c;李心成</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "hxu22d7okof4c1", "no_answer": 0, "created": "2015-03-30T06:24:14Z", "id": "i7vhq4y0qb734b", "updated": "2015-03-30T06:24:14Z", "subject": "<p>计25 矣晓沅</p>\n<p>计25 袁泰凌</p>\n<pre>1)\n队列memory\n\n2)\n174:\n            memory.append(n)\n\n3)\n112:\n                if policy == &#39;FIFO&#39; or policy == &#39;LRU&#39;:\n                    victim = memory.pop(0)\n</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [{"uid": "i6t6y9snjx2", "created": "2015-03-30T06:32:19Z", "id": "i7vi0jj8hke4fn", "updated": "2015-03-30T06:32:19Z", "subject": "<p>LRU 算法</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;stack&gt;\nusing namespace std;\n\n//LRU算法&#xff0c;采用活动页面栈方式实现\n\n\n//访问页面栈\nclass PageStack {\n    public:\n        PageStack(int memsize);\n        ~PageStack();\n        void visit(int pagenum); //访问某一页&#xff0c;按页号进行\n        void showMemory(); //查看内存状态\n\n    private:\n        int* Memory;\n        int MemSize;\n        int currentpagenum;\n        int push(int pagenum);\n};\n\nPageStack::PageStack(int memsize) {\n    Memory = new int[memsize];\n    currentpagenum = 0;\n    MemSize = memsize;\n}\n\nPageStack::~PageStack() {\n    delete Memory;\n\n}\n\nvoid PageStack::showMemory() {\n    for (int i=currentpagenum-1; i&gt;=0; i--) {\n        cout &lt;&lt; &#34;|&#34; &lt;&lt; Memory[i] &lt;&lt; &#34;|&#34; &lt;&lt; endl;\n    }\n    cout &lt;&lt; &#34;_________________________&#34; &lt;&lt; endl;\n}\n\nint PageStack::push(int pagenum) {\n    if (currentpagenum&lt;MemSize) {\n        Memory[currentpagenum&#43;&#43;] = pagenum;\n    } else { //删除栈底元素\n        for (int i=0; i&lt;MemSize-1; i&#43;&#43;) {\n            Memory[i] = Memory[i&#43;1];\n        }\n        Memory[MemSize-1] = pagenum;\n\n    }\n}\n\nvoid PageStack::visit(int pagenum) {\n    //先查找栈中是否有该元素\n    //为简单起见&#xff0c;直接线性查找\n    bool has = 0;\n    int index = 0;\n    for (int i=0; i&lt;currentpagenum; i&#43;&#43;) {\n        if (Memory[i] == pagenum) {\n            has = 1;\n            index = i;\n            break;\n        }\n    }\n\n    if (has) { //若page存在&#xff0c;则放到栈顶\n        int visitpage = Memory[index];\n        for (int i=index; i&lt;currentpagenum-1; i&#43;&#43;) {\n            Memory[i] = Memory[i&#43;1];\n        }\n        Memory[currentpagenum-1] = pagenum;\n\n    } else { //否则&#xff0c;直接push\n        cout &lt;&lt; &#34;page fault&#34; &lt;&lt; endl;\n        push(pagenum);\n    }\n}\n</code></pre>\n<p><code> </code></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i6uunp7jxDb", "no_answer": 0, "created": "2015-03-30T06:28:00Z", "id": "i7vhuz5wbzh28r", "updated": "2015-03-30T06:28:00Z", "subject": "<p>沈光耀&#xff0c;胡津铭</p>\n<p>1.memory[]</p>\n<p>2.</p>\n<pre>174 memory.append(n)</pre>\n<p>3.</p>\n<pre>112 victim = memory.pop(0)</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [{"uid": "i6rgda76fc66q4", "created": "2015-03-30T06:29:12Z", "id": "i7vhwiu4ejm5jk", "updated": "2015-03-30T06:29:12Z", "subject": "<p></p><pre>#include &lt;iostream&gt;\n#include &lt;list&gt;\nint main(int, char**) {\n    constexpr int working_set_window = 4;\n\n    // &lt; page number, time &gt;\n    std::list&lt; std::pair&lt;int, int&gt; &gt; working_set; \n    int time = 1;\n\n    working_set.push_back({1, 0});\n    working_set.push_back({4, -1});\n    working_set.push_back({5, -2});\n\n    while (1) {\n        int page_num;\n        std::cin &gt;&gt; page_num;\n\n        bool already_exist = 0;\n        for (auto ite = working_set.begin(); ite != working_set.end(); &#43;&#43;ite) \n            if (time - ite-&gt;second &gt;= working_set_window &amp;&amp; ite-&gt;first != page_num) \n                working_set.erase(ite);\n            else if (ite-&gt;first == page_num)\n                ite-&gt;second = time, already_exist = 1;\n        \n        if (!already_exist) {\n            std::cout &lt;&lt; &#34;Page miss. &#34; &lt;&lt; std::endl;\n            working_set.push_back({page_num, time});\n        } else {\n            std::cout &lt;&lt; &#34;Page hit. &#34; &lt;&lt; std::endl;\n        }\n        for (const auto i: working_set)\n            std::cout &lt;&lt; &#34;(&#34; &lt;&lt; i.first &lt;&lt; &#34;, &#34; &lt;&lt; i.second &lt;&lt; &#34;) &#34;;\n        std::cout &lt;&lt; std::endl;\n        &#43;&#43;time;\n    }\n\n}</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "children": [], "type": "feedback"}], "type": "followup"}, {"uid": "i6roqnlkmtw", "no_answer": 0, "created": "2015-03-30T06:31:26Z", "id": "i7vhze1tp2a5gk", "updated": "2015-03-30T06:31:26Z", "subject": "<p>队列memory</p>\n<p>memory.append(n)</p>\n<p>victim = memory.pop(0)</p>\n<p>李天润 刘鹤</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6ub691ffHe", "no_answer": 0, "created": "2015-03-30T06:31:55Z", "id": "i7vi00rghs25lg", "updated": "2015-03-30T06:31:55Z", "subject": "<p>2012011324 党唯真 </p>\n<p>2012011341 王昊</p>\n<p>1、memory队列</p>\n<p>2、174行处 memory.append(n)</p>\n<p>3、112行处 victim = memory.pop(0)</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6t1w87gRBD", "no_answer": 0, "created": "2015-03-30T06:50:29Z", "id": "i7vinwkkgpw5vd", "updated": "2015-03-30T06:50:29Z", "subject": "<p>2012011324 党唯真 </p>\n<p>2012011341 王昊</p>\n<p>工作集算法&#xff08;C&#43;&#43;&#xff0c;一个没多少扩展性的面向过程的实现orz&#xff09;&#xff1a;</p>\n<pre>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstdio&gt;\nusing namespace std;\n\nint main()\n{\n\tint cache[100], tag[100];\n\tfor (int i = 0; i &lt; 100; cache[i&#43;&#43;] = -1);\n\tint  window = 4, page, size = 0;\n\tbool hit;\n\twhile (1)\n\t{\n\t\thit = 0;\n\t\tcin &gt;&gt; page;\n\t\tif (page &lt; 0)\n\t\t\tbreak; \n\t\tfor (int i = 0; i &lt; size; i&#43;&#43;)\n\t\t{\n\t\t\ttag[i]&#43;&#43;;\n\t\t\tif (cache[i] == page)\n\t\t\t{\n\t\t\t\tprintf(&#34;page hit\\n&#34;);\n\t\t\t\ttag[i] = 0;\n\t\t\t\thit = 1;\n\t\t\t}\n\t\t\telse if (tag[i] &gt;= window)\n\t\t\t{\n\t\t\t\tcache[i] = cache[size-1];\n\t\t\t\ttag[i] = tag[size-1];\n\t\t\t\tsize--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tif (hit == 0)\n\t\t{\n\t\t\tprintf(&#34;page miss\\n&#34;);\n\t\t\tcache[size] = page;\n\t\t\ttag[size] = 0;\n\t\t\tsize&#43;&#43;;\n\t\t}\n\t\tfor (int i = 0; i &lt; size; i&#43;&#43;)\n\t\t{\n\t\t\tprintf(&#34;{%d, %d}, &#34;, cache[i], tag[i]);\n\t\t} \n\t\tprintf(&#34;\\n&#34;); \n\t}\n\t \n\treturn 0;\n}</pre>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i71i9b92nrr7n4", "no_answer": 0, "created": "2015-03-30T06:57:06Z", "id": "i7viwed4wrpok", "updated": "2015-03-30T06:57:06Z", "subject": "<p>1. memory</p>\n<p>2. line 174: memory.append(n)</p>\n<p>3. line 112: victim = memory.pop(0)</p>\n<p></p>\n<p>2012011290　梁錫豪</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6roqnlkmtw", "no_answer": 0, "created": "2015-03-30T07:00:08Z", "id": "i7vj0azpx4y6gk", "updated": "2015-03-30T07:00:08Z", "subject": "<p>李天润 刘鹤</p>\n<p>LRU算法</p>\n<p>c&#43;&#43;实现</p>\n<p></p>\n<p>#include &lt;iostream&gt;<br />#include &lt;list&gt;<br />int main(int, char**) {<br /> constexpr int working_set_window = 4;</p>\n<p>// &lt; page number, time &gt;<br /> std::list&lt; std::pair&lt;int, int&gt; &gt; working_set; <br /> int time = 1;</p>\n<p>working_set.push_back({1, 0});<br /> working_set.push_back({4, -1});<br /> working_set.push_back({5, -2});</p>\n<p>while (1) {<br /> int page_num;<br /> std::cin &gt;&gt; page_num;</p>\n<p>bool already_exist = 0;<br /> for (auto ite = working_set.begin(); ite != working_set.end(); &#43;&#43;ite) {<br /> if(ite-&gt;first == page_num){<br /> already_exist = 1;<br /> ite-&gt;second = time;<br /> }<br /> }</p>\n<p>if (!already_exist) {<br /> std::cout &lt;&lt; &#34;Page miss. &#34; &lt;&lt; std::endl;<br /> int last = 12345678;<br /> int which = -1;<br /> for (auto ite = working_set.begin(); ite != working_set.end(); &#43;&#43;ite)<br /> if(ite-&gt;second &lt; last){<br /> last = ite-&gt;second;<br /> which = ite-&gt;first;<br /> }<br /> for(auto ite = working_set.begin(); ite != working_set.end(); &#43;&#43;ite)<br /> if(ite-&gt;first == which){<br /> ite-&gt;first = page_num;<br /> ite-&gt;second = time;<br /> }<br /> } else {<br /> std::cout &lt;&lt; &#34;Page hit. &#34; &lt;&lt; std::endl;<br /> }<br /> for (const auto i: working_set)<br /> std::cout &lt;&lt; &#34;(&#34; &lt;&lt; i.first &lt;&lt; &#34;, &#34; &lt;&lt; i.second &lt;&lt; &#34;) &#34;;<br /> std::cout &lt;&lt; std::endl;<br /> &#43;&#43;time;<br /> }</p>\n<p>}</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i7oaxkxhxjo3ui", "no_answer": 0, "created": "2015-03-30T07:04:19Z", "id": "i7vj5p013aj3zg", "updated": "2015-03-30T07:04:19Z", "subject": "<p>罗鸿胤 2012011319</p>\n<p>杨元 2012011331</p>\n<p>周圣凯 2012011342</p>\n<p></p>\n<p>访问页的序列为b(t)&#xff0c;物理页帧的集合为S(t)&#xff0c;更大的物理页帧的集合为S&#39;(t)<br />讨论以下四种情况&#xff1a;<br />1. b(t)属于S(t)&#xff0c;b(t)属于S&#39;(t)<br />2. b(t)不属于S(t)&#xff0c;b(t)属于S&#39;(t)<br />3. b(t)不属于S(t)&#xff0c;b(t)不属于S&#39;(t)<br />4. b(t)属于S(t)&#xff0c;b(t)不属于S&#39;(t)<br />前三种情况下&#xff0c;在物理页帧为S&#39;(t)时&#xff0c;缺页率不会高于S(t)<br />若第四种情况发生&#xff0c;则&#xff1a;<br />b(t)在S(t)中&#xff0c;则知b(t)最近被使用过且在S(t)中并没有被换出&#xff0c;然而其在S&#39;(t)中被换出&#xff0c;与LRU算法矛盾</p>\n<p></p>\n<p>缺页率置换算法&#xff1a;</p>\n<pre><code>def test(timeSize,memSize,readList,length):\n    memory = [0] * memSize\n    in_memory = {}\n    page_fault = 0\n    point = 1\n    recent_used = {}\n    for i in range(len(readList)):\n        recent_used[readList[i]] = 1\n        in_memory[readList[i]] = 1\n        if readList[i] not in in_memory:\n            if point - page_fault &gt; timeSize:\n                for key in in_memory.items():\n                    if key not in recent_used:\n                        del(in_memory[key])\n            recent_used = {readList[i] : 1}\n    point &#43;= 1\n    return in_memory</code></pre>\n<p></p>\n<p>工作集置换算法&#xff1a;</p>\n<pre>class ReplacementWS(object):\n    def __init__(self, size):\n        self.size = size\n        self._q = []\n        self._ws = {}\n\n    def access(self, id):\n        &#39;&#39;&#39;\n        return value:\n        (fault, page(s) swapped out)\n        &#39;&#39;&#39;\n        fault = False\n        out = []\n        self._q.append(id)\n        if id not in self._ws:\n            self._ws[id] = 1\n            fault = True\n        else:\n            self._ws[id] &#43;= 1\n        while len(self._q)&gt;self.size:\n            pop = self._q.pop(0)\n            self._ws[pop] -= 1\n            if self._ws[pop] == 0:\n                self._ws.pop(pop)\n                out.append(pop)\n        return (fault, out)\n\n    def working_set(self):\n        return self._ws.keys()</pre>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6uayov5SAo", "no_answer": 0, "created": "2015-03-30T07:13:33Z", "id": "i7vjhjvq9xq4w2", "updated": "2015-03-30T07:13:33Z", "subject": "<p>2012080061 李载隆</p>\n<p></p>\n<p>1. memory[]</p>\n<p>2. 174行&#xff0c;memory.append(n)</p>\n<p>3. 112行&#xff0c;victim = memory.pop(0)</p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}, {"uid": "i6uehzyhtye4i2", "no_answer": 0, "created": "2015-03-30T11:31:37Z", "id": "i7vspfikgqa24k", "updated": "2015-03-30T11:31:37Z", "subject": "<p>2012011299 史佳欣</p>\n<p>2012011322 林子钏</p>\n<p>1、memory</p>\n<p>2、memory.append(n)</p>\n<p>3、victim = memory.pop(0)</p>\n<p></p>", "anon": "no", "folders": [], "config": {}, "data": {"embed_links": null}, "bucket_order": 4, "bucket_name": "This week", "no_upvotes": 0, "children": [], "type": "followup"}], "type": "note", "unique_views": 84, "created": "2015-03-30T06:15:03Z", "id": "i7vhec277x74wq", "tags": ["instructor-note", "课堂问答"], "nr": 204, "data": {"embed_links": []}, "upvote_ids": [], "is_tag_good": false, "config": {}, "folders": ["课堂问答"], "bucket_order": 2, "change_log": [{"uid": "hdjonbiyfs62ie", "when": "2015-03-30T06:15:03Z", "data": "i7vhec2d9h84ws", "anon": "no", "type": "create"}, {"uid": "i6rtbanwzcm5t6", "when": "2015-03-30T06:21:16Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "hxu22d7okof4c1", "when": "2015-03-30T06:24:14Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "i6uunp7jxDb", "when": "2015-03-30T06:28:00Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "i6rgda76fc66q4", "when": "2015-03-30T06:29:12Z", "to": "i7vhec277x74wq", "anon": "no", "type": "feedback"}, {"uid": "i6roqnlkmtw", "when": "2015-03-30T06:31:26Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "i6ub691ffHe", "when": "2015-03-30T06:31:55Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "i6t6y9snjx2", "when": "2015-03-30T06:32:19Z", "to": "i7vhec277x74wq", "anon": "no", "type": "feedback"}, {"uid": "i6t1w87gRBD", "when": "2015-03-30T06:50:29Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "i71i9b92nrr7n4", "when": "2015-03-30T06:57:06Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "i6roqnlkmtw", "when": "2015-03-30T07:00:08Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "i7oaxkxhxjo3ui", "when": "2015-03-30T07:04:19Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "i6uayov5SAo", "when": "2015-03-30T07:13:33Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}, {"uid": "i6uehzyhtye4i2", "when": "2015-03-30T11:31:37Z", "to": "i7vhec277x74wq", "anon": "no", "type": "followup"}], "bucket_name": "Today", "request_instructor_me": false, "no_answer_followup": 0, "num_favorites": 0, "tag_good": []}}