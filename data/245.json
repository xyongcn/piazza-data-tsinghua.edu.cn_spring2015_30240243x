{"error": null, "result": {"nr": 245, "upvote_ids": [], "change_log": [{"type": "create", "when": "2015-04-07T05:57:13Z", "uid": "hcrrjuyequh4bt", "data": "i86wa7wow1t3es", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T05:58:01Z", "uid": "i6uji18l8j51ob", "anon": "no"}, {"type": "update", "when": "2015-04-07T05:58:51Z", "uid": "hcrrjuyequh4bt", "data": "i86wcb0c9m34a0", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T06:26:39Z", "uid": "i6uuk6b68du319", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T06:35:44Z", "uid": "i6tz0qianu33p3", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T06:38:18Z", "uid": "i6uehzyhtye4i2", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T06:48:23Z", "uid": "i71i9b92nrr7n4", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T06:53:18Z", "uid": "i6uunp7jxDb", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T06:58:47Z", "uid": "i6vgn93glrq25f", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T06:59:13Z", "uid": "i6tezdpdQbq", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T07:00:50Z", "uid": "i6vi7mt1I4G", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T07:01:04Z", "uid": "i6urr6is7yo3jv", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T07:05:35Z", "uid": "i7oaxkxhxjo3ui", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T07:06:52Z", "uid": "i7bfq2txxyw689", "anon": "no"}, {"type": "feedback", "to": "i86wa7wl2e83er", "when": "2015-04-07T07:08:48Z", "uid": "i6ub691ffHe", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T07:16:54Z", "uid": "i7bfvegt8am5ir", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T07:20:04Z", "uid": "i71ev8heKQi", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T07:46:01Z", "uid": "i6urm1j1ynv6sm", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T08:04:21Z", "uid": "i6utvrywozd2vd", "anon": "no"}, {"type": "feedback", "to": "i86wa7wl2e83er", "when": "2015-04-07T08:19:50Z", "uid": "i6urm1j1ynv6sm", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T10:28:10Z", "uid": "i7bg4v1keqE", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T10:33:33Z", "uid": "i7bg4v1keqE", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T10:49:20Z", "uid": "i6xgf2t8N7w", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T10:58:30Z", "uid": "i6ut6cjo5lj4aa", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T11:15:30Z", "uid": "i6tawpo5Fm8", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T11:47:00Z", "uid": "i6uswob7jl4242", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T12:51:27Z", "uid": "i6unpz8nUza", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-07T16:32:12Z", "uid": "i6ublqcaxvu6el", "anon": "no"}, {"type": "followup", "to": "i86wa7wl2e83er", "when": "2015-04-08T14:02:39Z", "uid": "i71i9kso8Gp", "anon": "no"}, {"type": "update", "when": "2015-04-16T02:57:53Z", "uid": "hcrrjuyequh4bt", "data": "i8jku8ve1faxc", "anon": "no"}], "q_edits": [], "i_edits": [], "unique_views": 90, "bookmarked": 28, "config": {}, "history": [{"subject": "lec11 &#xff08;第六周第一次课&#xff09;spoc 练习完成登记处", "content": "<p>lec 11 进程&#xff0f;线程概念 spoc exercise</p>\n<p>请完成后follow</p>\n<p></p>\n<p>优胜者&#xff1a;</p>\n<p>裴中煜 2012010685</p>\n<p>李若愚 2012011353</p>", "created": "2015-04-16T02:57:53Z", "uid": "hcrrjuyequh4bt", "anon": "no"}, {"subject": "lec11 &#xff08;第六周第一次课&#xff09;spoc 练习完成登记处", "content": "<p>lec 11 进程&#xff0f;线程概念 spoc exercise</p>\n<p>请完成后follow</p>", "created": "2015-04-07T05:58:51Z", "uid": "hcrrjuyequh4bt", "anon": "no"}, {"subject": "lec10 &#xff08;第六周第一次课&#xff09;spoc 练习完成登记处", "content": "<p>lec 10 进程&#xff0f;线程概念 spoc exercise</p>\n<p>请完成后follow</p>", "created": "2015-04-07T05:57:13Z", "uid": "hcrrjuyequh4bt", "anon": "no"}], "data": {"embed_links": []}, "request_instructor_me": false, "folders": ["exam"], "type": "note", "tag_good": [], "tag_good_arr": [], "created": "2015-04-07T05:57:13Z", "t": 1433500262303, "id": "i86wa7wl2e83er", "status": "active", "default_anonymity": "no", "my_favorite": false, "bucket_order": 2, "is_bookmarked": false, "is_tag_good": false, "bucket_name": "Today", "no_answer_followup": 23, "children": [{"no_upvotes": 0, "uid": "i6uji18l8j51ob", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T05:58:01Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>裴中煜 2012010685</p>\n<p>李若愚 2012011353</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        assert expected == STATE_RUNNING\n        self.proc_info[pid][PROC_STATE] = STATE_READY \n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert expected == STATE_READY\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert expected == STATE_RUNNING\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        n = len(self.proc_info)\n        for i in range(1,n&#43;1):\n            if self.proc_info[(pid&#43;i)%n][PROC_STATE] == STATE_READY:\n                self.curr_proc = (pid&#43;i)%n\n                break\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                self.proc_info[self.curr_proc][PROC_PC] &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;\n</pre>", "children": [], "type": "followup", "no_answer": 0, "created": "2015-04-07T05:58:01Z", "id": "i86wb8a327g41e"}, {"no_upvotes": 0, "uid": "i6uuk6b68du319", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T06:26:39Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>2012011369 王轩</p>\n<p>2012011367 石伟男</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_READY \n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        num_proc = len(self.proc_info)\n        for i in range(1, num_proc &#43; 1, 1):\n            if self.proc_info[(pid &#43; i) % num_proc][PROC_STATE] == STATE_READY:\n                self.curr_proc = (pid &#43; i) % num_proc\n                self.move_to_running(STATE_READY)\n                break\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n                del self.proc_info[self.curr_proc][PROC_CODE][0]\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d&#39; % clock_tick, \n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T06:26:39Z", "id": "i86xc28jotx6zn"}, {"no_upvotes": 0, "uid": "i6tz0qianu33p3", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T06:35:44Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>周圣凯 2012011342</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        self.queue = []\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        self.queue.append(proc_id)\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        assert(pid in self.proc_info)\n        assert(self.proc_info[pid][PROC_STATE] == expected)\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert(self.proc_info[self.curr_proc][PROC_STATE] == expected)\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert(self.proc_info[self.curr_proc][PROC_STATE] == expected)\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        p = self.queue.pop(0)\n        if self.proc_info[p][PROC_STATE] == STATE_READY:\n            self.queue.append(p)\n        if len(self.queue):\n            self.curr_proc = self.queue[0]\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.get_instruction(self.curr_proc, 0)\n                self.proc_info[self.curr_proc][PROC_CODE] = self.proc_info[self.curr_proc][PROC_CODE][1:]\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T06:35:44Z", "id": "i86xnr21h1v4bl"}, {"no_upvotes": 0, "uid": "i6uehzyhtye4i2", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T06:38:18Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>2012011299 史佳欣</p>\n<p>2012011322 林子钏</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid==-1:\n            pid = self.curr_proc\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert self.proc_info[self.curr_proc][PROC_STATE] == expected\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid==-1:\n            pid = self.curr_proc\n        for i in range(1, self.get_num_processes()&#43;1):\n            nextpid = (pid&#43;i)%self.get_num_processes()\n            if self.proc_info[nextpid][PROC_STATE] == STATE_READY:\n                self.curr_proc = nextpid\n                self.move_to_running(STATE_READY)\n                break\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T06:38:18Z", "id": "i86xr1w3ccz3t4"}, {"no_upvotes": 0, "uid": "i71i9b92nrr7n4", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T06:48:23Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "計22 梁錫豪 2012011290\n\n#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #2012011290\n\tif pid == -1:\n\t\tpid = self.curr_proc\n\tassert self.proc_info[self.curr_proc][PROC_STATE] == expected\n\tself.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #2012011290\n\tassert self.proc_info[self.curr_proc][PROC_STATE] == expected\n\tself.proc_info[pid][PROC_STATE] = READY_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #2012011290\n\tassert self.proc_info[self.curr_proc][PROC_STATE] == expected\n\tself.proc_info[pid][PROC_STATE] = READY_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #2012011290\n\tif pid == -1:\n\t\tpid = self.curr_proc\n\tproc_num = self.get_num_processes();\n\tfor i in range(1, proc_num &#43; 1):\n\t\tidx = (pid &#43; i) % proc_num\n\t\tif self.proc_info[idx][PROC_STATE] == STATE_READY:\n\t\t\tself.curr_proc = idx\n\t\t\tbreak\n\tself.move_to_running(STATE_READY)\n\treturn\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #2012011290\n\t\tinstruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n\t\tdel self.proc_info[self.curr_proc][PROC_CODE][0]\n\t\tself.proc_info[self.curr_proc][PROC_PC] &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #2012011290\n\t\tself.move_to_ready(STATE_RUNNING)\n\t\tself.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T06:48:23Z", "id": "i86y40ii8v66kr"}, {"no_upvotes": 0, "uid": "i6uunp7jxDb", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T06:53:18Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>沈光耀 胡津铭</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        if STATE_RUNNING == expected:\n            self.proc_info[pid][PROC_STATE] = STATE_READY\n        else:\n            print &#39;not expected, can\\&#39;t ready&#39;\n\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if STATE_READY == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        else:\n            print &#39;not ready, can\\&#39;t running&#39;\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if STATE_RUNNING == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        else:\n            print &#39;not running, can\\&#39;t done&#39;\n\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        n = len(self.proc_info)\n        for i in range(1,n&#43;1):\n            if self.proc_info[(pid&#43;i)%n][PROC_STATE] == STATE_READY:\n                self.curr_proc = (pid &#43; i) % n\n                break\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n        \n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            #print self.proc_info[self.curr_proc][PROC_CODE]\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n                del self.proc_info[self.curr_proc][PROC_CODE][0]\n                self.proc_info[self.curr_proc][PROC_PC] &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T06:53:18Z", "id": "i86yabx1why17v"}, {"no_upvotes": 0, "uid": "i6vgn93glrq25f", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T06:58:47Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>潘寅旭</p>\n<pre>Produce a trace of what would happen when you run these processes:\nProcess 0\n  yld\n  yld\n  cpu\n  cpu\n  yld\n\nProcess 1\n  cpu\n  yld\n  cpu\n  cpu\n  yld\n\nImportant behaviors:\n  System will switch when the current process is FINISHED or ISSUES AN YIELD\nTime     PID: 0     PID: 1 \n  1     RUN:yld      READY \n  2     RUN:yld      READY \n  3     RUN:cpu      READY \n  4     RUN:cpu      READY \n  5     RUN:yld      READY \n  6        DONE    RUN:cpu \n  7        DONE    RUN:yld \n  8        DONE    RUN:cpu \n  9        DONE    RUN:cpu \n 10        DONE    RUN:yld\n#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid==-1:\n            pid=self.curr_proc;\n        if self.proc_info[pid][PROC_STATE]==expected:\n            self.proc_info[pid][PROC_STATE]=STATE_READY;\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE]==expected:\n            self.proc_info[self.curr_proc][PROC_STATE]=STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE]==expected:\n            self.proc_info[self.curr_proc][PROC_STATE]=STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid==-1:\n            pid=self.curr_proc;\n        n=len(self.proc_info)\n        for i in range(1,n&#43;1):\n            if self.proc_info[(pid&#43;i)%n][PROC_STATE]==STATE_READY:\n                self.curr_proc=(pid&#43;i)%n\n        if self.proc_info[self.curr_proc][PROC_STATE]==STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute=self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                self.proc_info[self.curr_proc][PROC_PC]&#43;=1\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T06:58:47Z", "id": "i86yhdjbayj58k"}, {"no_upvotes": 0, "uid": "i6tezdpdQbq", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T06:59:13Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>周昊 2012011326</p>\n<p>小华 2012011327</p>\n<p>李日灵 2012011332</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        if self.proc_info[pid][PROC_STATE] == expected:\n            self.proc_info[pid][PROC_STATE] = STATE_READY\n\n        else:\n            assert(1 == 0)\n        #YOUR CODE\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        else:\n            assert(1 == 0)\n        #YOUR CODE\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        else:\n            assert(1 == 0)\n        #YOUR CODE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        if pid == -1:\n            pid = self.curr_proc\n        n = self.get_num_processes()\n        for i in range(1, n):\n            if self.proc_info[(pid&#43;i)%n][PROC_STATE] == STATE_READY:\n                self.curr_proc = (pid&#43;i)%n\n                break\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        #YOUR CODE\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                   instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                self.move_to_ready(STATE_RUNNING, self.curr_proc)\n                self.next_proc()\n                #YOUR CODE\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T06:59:13Z", "id": "i86yhy04axk3dg"}, {"no_upvotes": 0, "uid": "i6vi7mt1I4G", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T07:00:50Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>袁源2012011294 黄杰2012011272</p>\n<pre>&lt;code&gt;#! /usr/bin/env python \n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n        def __init__(self):\n                # keep set of instructions for each of the processes\n                self.proc_info = {}\n                return\n\n        def new_process(self):\n                proc_id = len(self.proc_info)\n                self.proc_info[proc_id] = {}\n                self.proc_info[proc_id][PROC_PC] = 0\n                self.proc_info[proc_id][PROC_ID] = proc_id\n                self.proc_info[proc_id][PROC_CODE] = []\n                self.proc_info[proc_id][PROC_STATE] = STATE_READY\n                return proc_id\n\n        def load(self, program_description):\n                proc_id = self.new_process()\n                tmp = program_description.split(&#39;:&#39;)\n                if len(tmp) != 2:\n                        print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n                        print &#39;  where X is the number of instructions&#39;\n                        print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n                        exit(1)\n\n                num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n                for i in range(num_instructions):\n                        if random.random() &lt; chance_cpu:\n                                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n                        else:\n                                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n                return\n\n        #change to READY STATE, the current proc&#39;s state should be expected\n        #if pid==-1, then pid=self.curr_proc\n        def move_to_ready(self, expected, pid=-1):\n                #YOUR CODE\n                if pid==-1:\n                    pid = self.curr_proc\n                assert expected == STATE_RUNNING\n                self.proc_info[pid][PROC_STATE] = STATE_READY\n                return\n\n        #change to RUNNING STATE, the current proc&#39;s state should be expected\n        def move_to_running(self, expected):\n                #YOUR CODE\n                pid = self.curr_proc\n                assert expected == STATE_READY\n                self.proc_info[pid][PROC_STATE] = STATE_RUNNING\n                return\n\n        #change to DONE STATE, the current proc&#39;s state should be expected\n        def move_to_done(self, expected):\n                #YOUR CODE\n\n                pid = self.curr_proc\n                assert expected == STATE_RUNNING\n                self.proc_info[pid][PROC_STATE] = STATE_DONE\n                return\n\n        #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n        def next_proc(self, pid=-1):\n                #YOUR CODE\n                if pid==-1:\n                    pid = self.curr_proc\n                next_id = self.curr_proc\n                for proc_id in self.proc_info:\n                    if self.proc_info[proc_id][PROC_STATE] == STATE_READY and \\\n                                    proc_id != next_id :\n                        next_id = proc_id\n                        break\n                self.curr_proc = next_id\n                return\n\n        def get_num_processes(self):\n                return len(self.proc_info)\n\n        def get_num_instructions(self, pid):\n                return len(self.proc_info[pid][PROC_CODE])\n\n        def get_instruction(self, pid, index):\n                return self.proc_info[pid][PROC_CODE][index]\n\n        def get_num_active(self):\n                num_active = 0\n                for pid in range(len(self.proc_info)):\n                        if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                                num_active &#43;= 1\n                return num_active\n\n        def get_num_runnable(self):\n                num_active = 0\n                for pid in range(len(self.proc_info)):\n                        if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                                     self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                                num_active &#43;= 1\n                return num_active\n\n        def space(self, num_columns):\n                for i in range(num_columns):\n                        print &#39;%10s&#39; % &#39; &#39;,\n\n        def check_if_done(self):\n\n                if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n                        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                                self.move_to_done(STATE_RUNNING)\n                                self.next_proc()\n                return\n\n        def run(self):\n                clock_tick = 0\n\n                if len(self.proc_info) == 0:\n                        return\n\n                # make first one active\n                self.curr_proc = 0\n                self.move_to_running(STATE_READY)\n\n                # OUTPUT: heade&#96;[rs for each column\n                print &#39;%s&#39; % &#39;Time&#39;,\n                for pid in range(len(self.proc_info)):\n                        print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n                print &#39;&#39;\n\n                # init statistics\n                cpu_busy = 0\n\n                while self.get_num_active() &gt; 0:\n                        clock_tick &#43;= 1\n\n                        # if current proc is RUNNING and has an instruction, execute it\n                        # statistics clock_tick\n                        instruction_to_execute = &#39;&#39;\n                        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                                     len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                                #YOUR CODE\n                                pid = self.curr_proc\n                                if self.proc_info[pid][PROC_PC] &lt; len(self.proc_info[self.curr_proc][PROC_CODE]):\n                                    instruction_to_execute = self.get_instruction(self.curr_proc, self.proc_info[pid][PROC_PC])\n                                    self.proc_info[pid][PROC_PC] &#43;= 1\n                                if self.proc_info[pid][PROC_PC] &gt;= len(self.proc_info[self.curr_proc][PROC_CODE]):\n                                    self.move_to_done(STATE_RUNNING)\n\n\n\n                        # OUTPUT: print what everyone is up to\n                        print &#39;%3d &#39; % clock_tick,\n                        for pid in range(len(self.proc_info)):\n                                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                                        print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                                else:\n                                        print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n                        print &#39;&#39;\n                        # if this is an YIELD instruction, switch to ready state\n                        # and add an io completion in the future\n\n                        if instruction_to_execute == DO_YIELD:\n                            #YOUR CODE\n                            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                                self.move_to_ready(STATE_RUNNING)\n                            self.next_proc()\n                            if self.curr_proc != -1:\n                                self.move_to_running(STATE_READY)\n                        # ENDCASE: check if currently running thing is out of instructions\n                        self.check_if_done()\n                return (clock_tick)\n\n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                                    help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                                    action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n        s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n        print &#39;Process %d&#39; % pid\n        for inst in range(s.get_num_instructions(pid)):\n                print &#39;  %s&#39; % s.get_instruction(pid, inst)\n        print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n        print &#39;&#39;\n        print &#39;Stats: Total Time %d&#39; % clock_tick\n        print &#39;&#39;\n&lt;/code&gt;</pre>\n<p><code> </code></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T07:00:50Z", "id": "i86yk0fjdpa43j"}, {"no_upvotes": 0, "uid": "i6urr6is7yo3jv", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T07:01:04Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>鲁逸沁 2012011314</p>\n<p>谢晓晖 2012011315</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n\tdef __init__(self):\n\t\t# keep set of instructions for each of the processes\n\t\tself.proc_info = {}\n\t\treturn\n\n\tdef new_process(self):\n\t\tproc_id = len(self.proc_info)\n\t\tself.proc_info[proc_id] = {}\n\t\tself.proc_info[proc_id][PROC_PC] = 0\n\t\tself.proc_info[proc_id][PROC_ID] = proc_id\n\t\tself.proc_info[proc_id][PROC_CODE] = []\n\t\tself.proc_info[proc_id][PROC_STATE] = STATE_READY\n\t\treturn proc_id\n\n\tdef load(self, program_description):\n\t\tproc_id = self.new_process()\n\t\ttmp = program_description.split(&#39;:&#39;)\n\t\tif len(tmp) != 2:\n\t\t\tprint &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n\t\t\tprint &#39;  where X is the number of instructions&#39;\n\t\t\tprint &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n\t\t\texit(1)\n\n\t\tnum_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n\t\tfor i in range(num_instructions):\n\t\t\tif random.random() &lt; chance_cpu:\n\t\t\t\tself.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n\t\t\telse:\n\t\t\t\tself.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n\t\treturn\n\n\t#change to READY STATE, the current proc&#39;s state should be expected\n\t#if pid==-1, then pid=self.curr_proc\n\tdef move_to_ready(self, expected, pid=-1):\n\t\t# 1\n\t\tif pid == -1 :\n\t\t\tpid = self.curr_proc\n\t\tself.proc_info[pid][PROC_STATE] = STATE_READY\n\t\t# 1\n\t\treturn\n\n\t#change to RUNNING STATE, the current proc&#39;s state should be expected\n\tdef move_to_running(self, expected):\n\t\t# 2\n\t\tself.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n\t\t# 2\n\t\treturn\n\n\t#change to DONE STATE, the current proc&#39;s state should be expected\n\tdef move_to_done(self, expected):\n\t\t# 3\n\t\tself.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n\t\t# 3\n\t\treturn\n\n\t#choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n\tdef next_proc(self, pid=-1):\n\t\t# 4\n\t\tif self.get_num_active() == 0:\n\t\t\treturn\n\t\tif pid == -1:\n\t\t\tpid = self.curr_proc\n\t\twhile True:\n\t\t\tpid = pid &#43; 1\n\t\t\tif pid &gt;= len(self.proc_info):\n\t\t\t\tpid = 0\n\t\t\tif self.proc_info[pid][PROC_STATE] == STATE_READY:\n\t\t\t\tself.curr_proc = pid\n\t\t\t\tself.move_to_running(STATE_READY)\n\t\t\t\tbreak\n\t\t# 4\n\t\treturn\n\n\tdef get_num_processes(self):\n\t\treturn len(self.proc_info)\n\n\tdef get_num_instructions(self, pid):\n\t\treturn len(self.proc_info[pid][PROC_CODE])\n\n\tdef get_instruction(self, pid, index):\n\t\treturn self.proc_info[pid][PROC_CODE][index]\n\n\tdef get_num_active(self):\n\t\tnum_active = 0\n\t\tfor pid in range(len(self.proc_info)):\n\t\t\tif self.proc_info[pid][PROC_STATE] != STATE_DONE:\n\t\t\t\tnum_active &#43;= 1\n\t\treturn num_active\n\n\tdef get_num_runnable(self):\n\t\tnum_active = 0\n\t\tfor pid in range(len(self.proc_info)):\n\t\t\tif self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n\t\t\t\t   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n\t\t\t\tnum_active &#43;= 1\n\t\treturn num_active\n\n\tdef space(self, num_columns):\n\t\tfor i in range(num_columns):\n\t\t\tprint &#39;%10s&#39; % &#39; &#39;,\n\n\tdef check_if_done(self):\n\t\tif len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n\t\t\tif self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n\t\t\t\tself.move_to_done(STATE_RUNNING)\n\t\t\t\tself.next_proc()\n\t\treturn\n\n\tdef run(self):\n\t\tclock_tick = 0\n\n\t\tif len(self.proc_info) == 0:\n\t\t\treturn\n\n\t\t# make first one active\n\t\tself.curr_proc = 0\n\t\tself.move_to_running(STATE_READY)\n\n\t\t# OUTPUT: heade&#96;[rs for each column\n\t\tprint &#39;%s&#39; % &#39;Time&#39;, \n\t\tfor pid in range(len(self.proc_info)):\n\t\t\tprint &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n\t\tprint &#39;&#39;\n\n\t\t# init statistics\n\t\tcpu_busy = 0\n\n\t\twhile self.get_num_active() &gt; 0:\n\t\t\tclock_tick &#43;= 1\n\t\t\t\n\t\t\t#print self.curr_proc\n\t\t\t#print self.proc_info[0][PROC_STATE]\n\t\t\t#print self.proc_info[1][PROC_STATE]\n\t\t\t\n\t\t\t# if current proc is RUNNING and has an instruction, execute it\n\t\t\t# statistics clock_tick\n\t\t\tinstruction_to_execute = &#39;&#39;\n\t\t\tif self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n\t\t\t\t   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n\t\t\t\t# 5\n\t\t\t\tinstruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\t\t\t\t# 5\n\n\t\t\t# OUTPUT: print what everyone is up to\n\t\t\tprint &#39;%3d &#39; % clock_tick,\n\t\t\tfor pid in range(len(self.proc_info)):\n\t\t\t\tif pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n\t\t\t\t\tprint &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n\t\t\t\telse:\n\t\t\t\t\tprint &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n\t\t\tprint &#39;&#39;\n\n\t\t\t# if this is an YIELD instruction, switch to ready state\n\t\t\t# and add an io completion in the future\n\t\t\tif instruction_to_execute == DO_YIELD:\n\t\t\t\t# 6\n\t\t\t\tself.move_to_ready(STATE_RUNNING)\n\t\t\t\tself.next_proc()\n\t\t\t\t# 6\n\n\t\t\t# ENDCASE: check if currently running thing is out of instructions\n\t\t\tself.check_if_done()\n\t\treturn (clock_tick)\n\t\t\n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n\t\t\t\t  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n\t\t\t\t  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n\ts.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n\tprint &#39;Process %d&#39; % pid\n\tfor inst in range(s.get_num_instructions(pid)):\n\t\tprint &#39;  %s&#39; % s.get_instruction(pid, inst)\n\tprint &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n\tprint &#39;&#39;\n\tprint &#39;Stats: Total Time %d&#39; % clock_tick\n\tprint &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T07:01:04Z", "id": "i86ykbulz4o5ur"}, {"no_upvotes": 0, "uid": "i7oaxkxhxjo3ui", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T07:05:35Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>罗鸿胤 2012011319</p>\n<p>杨元 2012011331</p>\n<p></p>\n<pre><code>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if expected != STATE_RUNNING:\n            print &#34;Expected error&#34;\n            return\n        if pid == -1:\n            pid = self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if expected != STATE_READY:\n            print &#34;Expected error&#34;\n            return\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if expected != STATE_RUNNING:\n            print &#34;Expected error&#34;\n            return\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        if self.curr_proc &lt; len(self.proc_info) - 1:\n            self.curr_proc &#43;= 1\n        else:\n            if self.curr_proc == len(self.proc_info) - 1:\n                self.curr_proc = 0\n        if self.proc_info[self.curr_proc][PROC_STATE] != STATE_DONE:\n            self.move_to_running(self.proc_info[self.curr_proc][PROC_STATE])\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n\n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            #if self.curr_proc == 1:\n            #    print self.proc_info[self.curr_proc][PROC_CODE]\n            #    return\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]\n                self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n\n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</code></pre>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T07:05:35Z", "id": "i86yq4nok4y5tj"}, {"no_upvotes": 0, "uid": "i7bfq2txxyw689", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T07:06:52Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>覃  伟    2012011278</p>\n<p>徐天宇  2012011275</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport os\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        temp = self.curr_proc\n        if pid!=-1:\n            temp = pid\n        if self.proc_info[temp][PROC_STATE]==expected:\n            self.proc_info[temp][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid != -1:\n            self.curr_proc = pid\n        roundTime=0\n        self.curr_proc = (self.curr_proc&#43;1)%len(self.proc_info)\n        while self.proc_info[self.curr_proc][PROC_STATE] != STATE_READY:\n            self.curr_proc = (self.curr_proc&#43;1)%len(self.proc_info)\n            roundTime&#43;=1\n            if roundTime==len(self.proc_info):\n                break\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                self.proc_info[self.curr_proc][PROC_PC] &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n                # print &#39;%3d &#39; % self.curr_proc\n\t\t\t\t\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n            # os.system(&#34;pause&#34;)\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [{"uid": "i6ub691ffHe", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T07:08:48Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>2012011324 党唯真</p>\n<p>2012011341 王昊</p>\n<p>import sys<br />from optparse import OptionParser<br />import random</p>\n<p># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;</p>\n<p># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;</p>\n<p># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;</p>\n<p><br />class scheduler:<br /> def __init__(self):<br /> # keep set of instructions for each of the processes<br /> self.proc_info = {}<br /> return</p>\n<p>def new_process(self):<br /> proc_id = len(self.proc_info)<br /> self.proc_info[proc_id] = {}<br /> self.proc_info[proc_id][PROC_PC] = 0<br /> self.proc_info[proc_id][PROC_ID] = proc_id<br /> self.proc_info[proc_id][PROC_CODE] = []<br /> self.proc_info[proc_id][PROC_STATE] = STATE_READY<br /> return proc_id</p>\n<p>def load(self, program_description):<br /> proc_id = self.new_process()<br /> tmp = program_description.split(&#39;:&#39;)<br /> if len(tmp) != 2:<br /> print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;<br /> print &#39; where X is the number of instructions&#39;<br /> print &#39; and Y is the percent change that an instruction is CPU not YIELD&#39;<br /> exit(1)</p>\n<p>num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0<br /> for i in range(num_instructions):<br /> if random.random() &lt; chance_cpu:<br /> self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br /> else:<br /> self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br /> return</p>\n<p>#change to READY STATE, the current proc&#39;s state should be expected<br /> #if pid==-1, then pid=self.curr_proc<br /> def move_to_ready(self, expected, pid=-1):<br /> #YOUR CODE <br /> if pid == -1:<br /> pid = self.curr_proc<br /> assert expected == STATE_RUNNING<br /> self.proc_info[pid][PROC_STATE] = STATE_READY<br /> return</p>\n<p>#change to RUNNING STATE, the current proc&#39;s state should be expected<br /> def move_to_running(self, expected):<br /> #YOUR CODE<br /> assert expected == STATE_READY<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br /> return</p>\n<p>#change to DONE STATE, the current proc&#39;s state should be expected<br /> def move_to_done(self, expected):<br /> #YOUR CODE<br /> assert expected == STATE_RUNNING<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br /> return</p>\n<p>#choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br /> def next_proc(self, pid=-1):<br /> #YOUR CODE<br /> if pid == -1:<br /> pid = self.curr_proc<br /> for i in range (1, len(self.proc_info) &#43; 1):<br /> if(self.proc_info[(pid &#43; i) % len(self.proc_info)][PROC_STATE] == STATE_READY):<br /> self.curr_proc = (pid &#43; i) % len(self.proc_info)<br /> self.move_to_running(STATE_READY)<br /> break<br /> return</p>\n<p>def get_num_processes(self):<br /> return len(self.proc_info)</p>\n<p>def get_num_instructions(self, pid):<br /> return len(self.proc_info[pid][PROC_CODE])</p>\n<p>def get_instruction(self, pid, index):<br /> return self.proc_info[pid][PROC_CODE][index]</p>\n<p>def get_num_active(self):<br /> num_active = 0<br /> for pid in range(len(self.proc_info)):<br /> if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br /> num_active &#43;= 1<br /> return num_active</p>\n<p>def get_num_runnable(self):<br /> num_active = 0<br /> for pid in range(len(self.proc_info)):<br /> if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br /> self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br /> num_active &#43;= 1<br /> return num_active</p>\n<p>def space(self, num_columns):<br /> for i in range(num_columns):<br /> print &#39;%10s&#39; % &#39; &#39;,</p>\n<p>def check_if_done(self):<br /> if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:<br /> self.move_to_done(STATE_RUNNING)<br /> self.next_proc()<br /> return</p>\n<p>def run(self):<br /> clock_tick = 0</p>\n<p>if len(self.proc_info) == 0:<br /> return</p>\n<p># make first one active<br /> self.curr_proc = 0<br /> self.move_to_running(STATE_READY)</p>\n<p># OUTPUT: heade&#96;[rs for each column<br /> print &#39;%s&#39; % &#39;Time&#39;, <br /> for pid in range(len(self.proc_info)):<br /> print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),</p>\n<p>print &#39;&#39;</p>\n<p># init statistics<br /> cpu_busy = 0</p>\n<p>while self.get_num_active() &gt; 0:<br /> clock_tick &#43;= 1<br /> <br /> # if current proc is RUNNING and has an instruction, execute it<br /> # statistics clock_tick<br /> instruction_to_execute = &#39;&#39;<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br /> len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br /> #YOUR CODE<br /> instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)<br /> self.proc_info[self.curr_proc][PROC_PC] &#43;= 1<br /> # OUTPUT: print what everyone is up to<br /> print &#39;%3d &#39; % clock_tick,<br /> for pid in range(len(self.proc_info)):<br /> if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:<br /> print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),<br /> else:<br /> print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),</p>\n<p>print &#39;&#39;</p>\n<p># if this is an YIELD instruction, switch to ready state<br /> # and add an io completion in the future<br /> if instruction_to_execute == DO_YIELD:<br /> #YOUR CODE<br /> self.move_to_ready(STATE_RUNNING)<br /> self.next_proc()<br /> # ENDCASE: check if currently running thing is out of instructions<br /> self.check_if_done()<br /> return (clock_tick)<br /> <br />#<br /># PARSE ARGUMENTS<br />#</p>\n<p>parser = OptionParser()<br />parser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)<br />parser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,<br /> help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,<br /> action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)<br />parser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)<br />(options, args) = parser.parse_args()</p>\n<p>random.seed(options.seed)</p>\n<p>s = scheduler()</p>\n<p># example process description (10:100,10:100)<br />for p in options.process_list.split(&#39;,&#39;):<br /> s.load(p)</p>\n<p><br />print &#39;Produce a trace of what would happen when you run these processes:&#39;<br />for pid in range(s.get_num_processes()):<br /> print &#39;Process %d&#39; % pid<br /> for inst in range(s.get_num_instructions(pid)):<br /> print &#39; %s&#39; % s.get_instruction(pid, inst)<br /> print &#39;&#39;<br />print &#39;Important behaviors:&#39;<br />print &#39; System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;</p>\n<p>(clock_tick) = s.run()</p>\n<p>if options.print_stats:<br /> print &#39;&#39;<br /> print &#39;Stats: Total Time %d&#39; % clock_tick<br /> print &#39;&#39;</p>", "children": [], "type": "feedback", "created": "2015-04-07T07:08:48Z", "id": "i86yu9tlqbn774"}], "type": "followup", "no_answer": 1, "created": "2015-04-07T07:06:52Z", "id": "i86yrsfkfkc6k7"}, {"no_upvotes": 0, "uid": "i7bfvegt8am5ir", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T07:16:54Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>韩慧阳 2012011276</p>\n<p>杨博文 2012011288</p>\n<div style=\"font-family:&#34;Arial&#34;;font-size:14px;color:#000000\">\n<div>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc;\n        proc = self.proc_info[pid];\n        if proc[PROC_STATE] == expected:\n            proc[PROC_STATE] = STATE_READY;\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        pid = self.curr_proc;\n        proc = self.proc_info[pid];\n        if proc[PROC_STATE] == expected:\n            proc[PROC_STATE] = STATE_RUNNING;\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        pid = self.curr_proc;\n        proc = self.proc_info[pid];\n        if proc[PROC_STATE] == expected:\n            proc[PROC_STATE] = STATE_DONE;\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if self.get_num_runnable()==0:\n            return\n        if len(self.proc_info)&lt;=1:\n            #print &#39;only one&#39;\n            pid = self.curr_proc;\n        else:\n            if pid == -1:\n                pid = self.curr_proc;\n            pid = (pid&#43;1) % len(self.proc_info);\n            while (self.proc_info[pid][PROC_STATE] == STATE_DONE):\n                print str(pid)&#43;&#39; done!&#39;;\n                pid = (pid&#43;1) % len(self.proc_info);\n            self.curr_proc = pid;\n            #print &#39;switch &#39;&#43;str(pid)&#43;&#39;:&#39;&#43;self.proc_info[pid][PROC_STATE];\n        if (self.proc_info[pid][PROC_STATE]==STATE_READY):          \n            self.move_to_running(STATE_READY);\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            #print &#39;PID: &#39; &#43; str(self.curr_proc)&#43;&#39; ins: &#39;&#43;str(len(self.proc_info[self.curr_proc][PROC_CODE]));\n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop();#remove instruction to be excuted.\n                if len(self.proc_info[self.curr_proc][PROC_CODE])==0:\n                    self.move_to_done(STATE_RUNNING);\n                #print self.proc_info[self.curr_proc][PROC_CODE];\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING);\n                self.next_proc();\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done();\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n</div>\n</div>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T07:16:54Z", "id": "i86z4ojgl1z1yb"}, {"no_upvotes": 0, "uid": "i71ev8heKQi", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T07:20:04Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>应杰夫 2012011293</p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        assert expected == STATE_RUNNING\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert expected == STATE_READY\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert expexted == STATE_RUNNING\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        n = len(self.proc_info)\n        for i in range(1, n&#43;1):\n            if self.proc_info[(pid&#43;i)%n][PROC_STATE] == STATE_READY:\n                self.curr_proc = (pid&#43;i)%n\n                break\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                   instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                self.move_to_ready(STATE_RUNNING, self.curr_proc)\n                self.next_proc()\n                #YOUR CODE\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T07:20:04Z", "id": "i86z8rghtua3b9"}, {"no_upvotes": 0, "uid": "i6urm1j1ynv6sm", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T07:46:01Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>陆喆 2012011308</p>\n<p></p>\n<pre>#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        if self.proc_info[self.curr_proc][PROC_STATE] == expected:\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        size = len(self.proc_info)\n        pid &#43;= 1\n        while pid &lt; size:\n            if (self.proc_info[pid][PROC_STATE] != STATE_DONE):\n                self.curr_proc = pid\n                self.move_to_running(STATE_READY)\n                return\n            pid &#43;= 1\n        pid = 0\n        while pid != self.curr_proc:\n            if (self.proc_info[pid][PROC_STATE] != STATE_DONE):\n                self.curr_proc = pid\n                self.move_to_running(STATE_READY)\n                return\n            pid &#43;= 1\n        self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                # print &#39;&#39;\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n                # print &#39;&#39;\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [{"uid": "i6urm1j1ynv6sm", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T08:19:50Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>我错了&#xff0c;我实现的貌似不是FIFO&#xff0c;是循环……&gt;_&lt;</p>\n<p>不过只需要改一下next_proc()&#xff0c;每次都从第一个开始找就可以了。</p>", "children": [], "type": "feedback", "created": "2015-04-07T08:19:50Z", "id": "i871dm9r7h22xm"}], "type": "followup", "no_answer": 1, "created": "2015-04-07T07:46:01Z", "id": "i87064n1l8e2qb"}, {"no_upvotes": 0, "uid": "i6utvrywozd2vd", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T08:04:21Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>陈天昱 李心田 杨皓&#xff08;同组的没来所以一起讨论&#xff09;</p>\n<p></p>\n<p><a href=\"https://github.com/cty12/os_exercises/blob/master/src/05-1-spoc-coding/process-concept-homework.py\" target=\"_blank\">https://github.com/cty12/os_exercises/blob/master/src/05-1-spoc-coding/process-concept-homework.py</a></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T08:04:21Z", "id": "i870tp1b7x13iv"}, {"no_upvotes": 0, "uid": "i7bg4v1keqE", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T10:28:10Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>杜鹃 2012011354</p>\n<p>王妍 2012011352</p>\n<p></p>\n<pre>#! /usr/bin/env python<br /><br />import sys<br />from optparse import OptionParser<br />import random<br /><br /># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;<br /><br /># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;<br /><br /># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;<br /><br /><br />class scheduler:<br />    def __init__(self):<br />        # keep set of instructions for each of the processes<br />        self.proc_info = {}<br />        return<br /><br />    def new_process(self):<br />        proc_id = len(self.proc_info)<br />        self.proc_info[proc_id] = {}<br />        self.proc_info[proc_id][PROC_PC] = 0<br />        self.proc_info[proc_id][PROC_ID] = proc_id<br />        self.proc_info[proc_id][PROC_CODE] = []<br />        self.proc_info[proc_id][PROC_STATE] = STATE_READY<br />        return proc_id<br /><br />    def load(self, program_description):<br />        proc_id = self.new_process()<br />        tmp = program_description.split(&#39;:&#39;)<br />        if len(tmp) != 2:<br />            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;<br />            print &#39;  where X is the number of instructions&#39;<br />            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;<br />            exit(1)<br /><br />        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0<br />        for i in range(num_instructions):<br />            if random.random() &lt; chance_cpu:<br />                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br />            else:<br />                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br />        return<br /><br />    #change to READY STATE, the current proc&#39;s state should be expected<br />    #if pid==-1, then pid=self.curr_proc<br />    def move_to_ready(self, expected, pid=-1):<br />        assert ( expected != STATE_DONE )<br />        if pid == -1:<br />            pid = self.curr_proc<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_READY<br />        self.next_proc()<br />        self.move_to_running(STATE_READY)<br />        <br />        return<br /><br />    #change to RUNNING STATE, the current proc&#39;s state should be expected<br />    def move_to_running(self, expected):<br />        #YOUR CODE<br />        #assert ( expected != STATE_DONE )<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br />        return<br /><br />    #change to DONE STATE, the current proc&#39;s state should be expected<br />    def move_to_done(self, expected):<br />        #YOUR CODE<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br />        if  self.get_num_active() != 0 :<br />            self.next_proc() <br />            self.move_to_running(STATE_READY)<br /><br />        <br />        return<br /><br />    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br />    def next_proc(self, pid=-1):<br />        #YOUR CODE<br />        if pid == -1:<br />            pid = self.curr_proc<br />        self.curr_proc = (self.curr_proc &#43; 1 ) % len(self.proc_info)<br />        self.check_if_done();<br />        <br />        return<br /><br />    def get_num_processes(self):<br />        return len(self.proc_info)<br /><br />    def get_num_instructions(self, pid):<br />        return len(self.proc_info[pid][PROC_CODE])<br /><br />    def get_instruction(self, pid, index):<br />        return self.proc_info[pid][PROC_CODE][index]<br /><br />    def get_num_active(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def get_num_runnable(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br />                self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def space(self, num_columns):<br />        for i in range(num_columns):<br />            print &#39;%10s&#39; % &#39; &#39;,<br /><br />    def check_if_done(self):<br />        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:<br />                self.move_to_done(STATE_RUNNING)<br />            return<br /><br />    def run(self):<br />        clock_tick = 0<br /><br />        if len(self.proc_info) == 0:<br />            return<br /><br />        # make first one active<br />        self.curr_proc = 0<br />        self.move_to_running(STATE_READY)<br /><br />        # OUTPUT: heade&#96;[rs for each column<br />        print &#39;%s&#39; % &#39;Time&#39;,<br />        for pid in range(len(self.proc_info)):<br />            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),<br /><br />        print &#39;&#39;<br /><br />        # init statistics<br />        cpu_busy = 0<br /><br />        <br />        while self.get_num_active() &gt; 0:<br />            clock_tick &#43;= 1<br /><br />            # if current proc is RUNNING and has an instruction, execute it<br />            # statistics clock_tick<br />            instruction_to_execute = &#39;&#39;<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br />                len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br />                instruction_to_execute = self.proc_info[self</pre>", "children": [], "type": "followup", "no_answer": 0, "created": "2015-04-07T10:28:10Z", "id": "i875ynazrda3zz"}, {"no_upvotes": 0, "uid": "i7bg4v1keqE", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T10:33:33Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>杜鹃 2012011354</p>\n<p>王妍 2012011352</p>\n<p></p>\n<p></p>\n<p>https://github.com/yanwang9411/os_exercises/blob/master/all/process.py</p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T10:33:33Z", "id": "i8765kz8mc76gs"}, {"no_upvotes": 0, "uid": "i6xgf2t8N7w", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T10:49:20Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "战裕隆 2012011388\n杨俊 2012011400\nhttps://github.com/zhanyl12/os_exercises/blob/master/05-1-spoc-discussion.md", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T10:49:20Z", "id": "i876pvn6t861uj"}, {"no_upvotes": 0, "uid": "i6ut6cjo5lj4aa", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T10:58:30Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>韦福超2012011392 &#xff08; 又迟交了&#xff09;</p>\n<p>王振2012011397 </p>\n<pre><code>#!/usr/bin/env python\n    import sys\n    from optparse import OptionParser\n    import random\n\n    # process states\n    STATE_RUNNING = &#39;RUNNING&#39;\n    STATE_READY = &#39;READY&#39;\n    STATE_DONE = &#39;DONE&#39;\n\n    # members of process structure\n    PROC_CODE = &#39;code_&#39;\n    PROC_PC = &#39;pc_&#39;\n    PROC_ID = &#39;pid_&#39;\n    PROC_STATE = &#39;proc_state_&#39;\n\n    # things a process can do\n    DO_COMPUTE = &#39;cpu&#39;\n    DO_YIELD = &#39;yld&#39;\n\n\n    class scheduler:\n\n        def __init__(self):\n            # keep set of instructions for each of the processes\n            self.proc_info = {}\n            return\n\n        def new_process(self):\n            proc_id = len(self.proc_info)\n            self.proc_info[proc_id] = {}\n            self.proc_info[proc_id][PROC_PC] = 0\n            self.proc_info[proc_id][PROC_ID] = proc_id\n            self.proc_info[proc_id][PROC_CODE] = []\n            self.proc_info[proc_id][PROC_STATE] = STATE_READY\n            return proc_id\n\n        def load(self, program_description):\n            proc_id = self.new_process()\n            tmp = program_description.split(&#39;:&#39;)\n            if len(tmp) != 2:\n                print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n                print &#39;  where X is the number of instructions&#39;\n                print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n                exit(1)\n\n            num_instructions, chance_cpu = int(tmp[0]), float(tmp[1]) / 100.0\n            for i in range(num_instructions):\n                if random.random() &lt; chance_cpu:\n                    self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n                else:\n                    self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n            return\n\n        # change to READY STATE, the current proc&#39;s state should be expected\n        # if pid==-1, then pid=self.curr_proc\n        def move_to_ready(self, expected, pid=-1):\n            # YOUR CODE\n            assert expected != STATE_DONE\n            if pid == -1:\n                pid = self.curr_proc\n            self.proc_info[pid][PROC_STATE] = STATE_READY\n            return\n\n        # change to RUNNING STATE, the current proc&#39;s state should be expected\n        def move_to_running(self, expected):\n            # YOUR CODE\n            assert expected == STATE_READY\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n            return\n\n        # change to DONE STATE, the current proc&#39;s state should be expected\n        def move_to_done(self, expected):\n            # YOUR CODE\n            assert expected == STATE_RUNNING\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n            return\n\n        # choose next proc using FIFO/FCFS scheduling, If pid==-1, then\n        # pid=self.curr_proc\n        def next_proc(self, pid=-1):\n            # YOUR CODE\n            if pid == -1:\n                pid = self.curr_proc\n            pidx = pid &#43; 1\n            while pidx &lt; len(self.proc_info):\n                if self.proc_info[pidx][PROC_STATE] == STATE_READY:\n                    self.curr_proc = pidx\n                    self.move_to_running(STATE_READY)\n                    return\n                pidx &#43;= 1\n            pidx = 0\n            while pidx &lt;= pid:\n                if self.proc_info[pidx][PROC_STATE] == STATE_READY:\n                    self.curr_proc = pidx\n                    self.move_to_running(STATE_READY)\n                    return\n                pidx &#43;= 1\n\n        def get_num_processes(self):\n            return len(self.proc_info)\n\n        def get_num_instructions(self, pid):\n            return len(self.proc_info[pid][PROC_CODE])\n\n        def get_instruction(self, pid, index):\n            return self.proc_info[pid][PROC_CODE][index]\n\n        def get_num_active(self):\n            num_active = 0\n            for pid in range(len(self.proc_info)):\n                if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                    num_active &#43;= 1\n            return num_active\n\n        def get_num_runnable(self):\n            num_active = 0\n            for pid in range(len(self.proc_info)):\n                if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                        self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                    num_active &#43;= 1\n            return num_active\n\n        def space(self, num_columns):\n            for i in range(num_columns):\n                print &#39;%10s&#39; % &#39; &#39;,\n\n        def check_if_done(self):\n            if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n                if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                    self.move_to_done(STATE_RUNNING)\n                    self.next_proc()\n            return\n\n        def run(self):\n            clock_tick = 0\n\n            if len(self.proc_info) == 0:\n                return\n\n            # make first one active\n            self.curr_proc = 0\n            self.move_to_running(STATE_READY)\n\n            # OUTPUT: heade&#96;[rs for each column\n            print &#39;%s&#39; % &#39;Time&#39;,\n            for pid in range(len(self.proc_info)):\n                print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n            print &#39;&#39;\n\n            # init statistics\n            cpu_busy = 0\n\n            while self.get_num_active() &gt; 0:\n                clock_tick &#43;= 1\n                # if current proc is RUNNING and has an instruction, execute it\n                # statistics clock_tick\n                instruction_to_execute = &#39;&#39;\n                if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                        len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                    # YOUR CODE\n                    instruction_to_execute = self.proc_info[\n                        self.curr_proc][PROC_CODE].pop(0)\n\n                    # OUTPUT: print what everyone is up to\n                print &#39;%3d &#39; % clock_tick,\n                for pid in range(len(self.proc_info)):\n                    if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                        print &#39;%10s&#39; % (&#39;RUN:&#39; &#43; instruction_to_execute),\n                    else:\n                        print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n                print &#39;&#39;\n\n                # if this is an YIELD instruction, switch to ready state\n                # and add an io completion in the future\n                if instruction_to_execute == DO_YIELD:\n                    # YOUR CODE\n                    self.move_to_ready(STATE_RUNNING)\n                    self.next_proc()\n                    # ENDCASE: check if currently running thing is out of\n                    # instructions\n                self.check_if_done()\n            return (clock_tick)\n\n    #\n    # PARSE ARGUMENTS\n    #\n\n    parser = OptionParser()\n    parser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0,\n                      help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\n    parser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                      help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                      action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\n    parser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;,\n                      action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n    (options, args) = parser.parse_args()\n\n    random.seed(options.seed)\n\n    s = scheduler()\n\n    # example process description (10:100,10:100)\n    for p in options.process_list.split(&#39;,&#39;):\n        s.load(p)\n\n\n    print &#39;Produce a trace of what would happen when you run these processes:&#39;\n    for pid in range(s.get_num_processes()):\n        print &#39;Process %d&#39; % pid\n        for inst in range(s.get_num_instructions(pid)):\n            print &#39;  %s&#39; % s.get_instruction(pid, inst)\n        print &#39;&#39;\n    print &#39;Important behaviors:&#39;\n    print &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n    (clock_tick) = s.run()\n\n    if options.print_stats:\n        print &#39;&#39;\n        print &#39;Stats: Total Time %d&#39; % clock_tick\n        print &#39;&#39;</code></pre>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T10:58:30Z", "id": "i8771o2y3uu267"}, {"no_upvotes": 0, "uid": "i6tawpo5Fm8", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T11:15:30Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "张梦豪 2012011401 \n#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE \n        if pid == -1:\n            pid = self.curr_proc\n        assert expected == STATE_RUNNING\n        self.proc_info[pid][PROC_STATE] = STATE_READY \n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE \n        assert expected == STATE_READY\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE \n        assert expected == STATE_RUNNING\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE \n        if pid == -1:\n            pid = self.curr_proc\n        n = len(self.proc_info)\n        for i in range(1,n&#43;1):\n            if self.proc_info[(pid&#43;i)%n][PROC_STATE] == STATE_READY:\n                self.curr_proc = (pid&#43;i)%n\n                break\n        if self.proc_info[self.curr_proc][PROC_STATE] == STATE_READY:\n            self.move_to_running(STATE_READY)\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE \n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n                self.proc_info[self.curr_proc][PROC_PC] &#43;= 1\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE \n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T11:15:30Z", "id": "i877niqtr895fp"}, {"no_upvotes": 0, "uid": "i6uswob7jl4242", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T11:47:00Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p></p><pre>马晓彬 2012011402<br />#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        assert expected == STATE_RUNNING\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert(STATE_READY == expected)\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert expected == STATE_RUNNING\n        #print &#39;done&#39;\n        #print self.proc_info[self.curr_proc][PROC_STATE]\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        num_process = len(self.proc_info)\n\n        for i in range(0,num_process-1) :\n          if self.proc_info[i][PROC_STATE] == STATE_READY and i != self.curr_proc:\n            self.curr_proc = i\n            \n        if self.proc_info[self.curr_proc][PROC_STATE] != STATE_DONE :\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        #print self.curr_proc\n        #print self.proc_info[self.curr_proc][PROC_STATE]\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                #print 6666666666\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n                self.move_to_ready(STATE_RUNNING)\n                self.next_proc()\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n            #raw_input()\n            #if self.get_num_active() &gt;0 :\n              #  print self.get_num_active()\n\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T11:47:00Z", "id": "i878s1agwoa5c7"}, {"no_upvotes": 0, "uid": "i6unpz8nUza", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T12:51:27Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>李国豪 2012011303</p>\n<p>金嘉宇 2012080059</p>\n<pre>#! /usr/bin/env python<br /><br />import sys<br />from optparse import OptionParser<br />import random<br /><br /># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;<br /><br /># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;<br /><br /># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;<br /><br />class scheduler:<br />    def __init__(self):<br />        # keep set of instructions for each of the processes<br />        self.proc_info = {}<br />        return<br /><br />    def new_process(self):<br />        proc_id = len(self.proc_info)<br />        self.proc_info[proc_id] = {}<br />        self.proc_info[proc_id][PROC_PC] = 0<br />        self.proc_info[proc_id][PROC_ID] = proc_id<br />        self.proc_info[proc_id][PROC_CODE] = []<br />        self.proc_info[proc_id][PROC_STATE] = STATE_READY<br />        return proc_id<br /><br />    def load(self, program_description):<br />        proc_id = self.new_process()<br />        tmp = program_description.split(&#39;:&#39;)<br />        if len(tmp) != 2:<br />            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;<br />            print &#39;  where X is the number of instructions&#39;<br />            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;<br />            exit(1)<br /><br />        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0<br />        for i in range(num_instructions):<br />            if random.random() &lt; chance_cpu:<br />                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br />            else:<br />                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br />        return<br /><br />    #change to READY STATE, the current proc&#39;s state should be expected<br />    #if pid==-1, then pid=self.curr_proc<br />    def move_to_ready(self, expected, pid=-1):<br />        #YOUR CODE<br />        if expected == STATE_DONE:<br />            assert False<br />        if pid == -1:<br />            pid = self.curr_proc<br />        self.proc_info[pid][PROC_STATE] = STATE_READY<br />        return<br /><br />    #change to RUNNING STATE, the current proc&#39;s state should be expected<br />    def move_to_running(self, expected):<br />        #YOUR CODE<br />        if expected == STATE_DONE:<br />            assert False<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br />        return<br /><br />    #change to DONE STATE, the current proc&#39;s state should be expected<br />    def move_to_done(self, expected):<br />        #YOUR CODE<br />        if expected == STATE_DONE:<br />            assert False<br />        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br />        return<br /><br />    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br />    def next_proc(self, pid=-1):<br />        #YOUR CODE<br />        curr_id = self.curr_proc<br />        next_id = (curr_id &#43; 1) % len(self.proc_info)<br />        self.proc_info[next_id][PROC_ID] = next_id<br />        self.curr_proc = next_id<br />        if self.proc_info[next_id][PROC_STATE] == STATE_READY:<br />            self.proc_info[next_id][PROC_STATE] = STATE_RUNNING<br />        return<br /><br />    def get_num_processes(self):<br />        return len(self.proc_info)<br /><br />    def get_num_instructions(self, pid):<br />        return len(self.proc_info[pid][PROC_CODE])<br /><br />    def get_instruction(self, pid, index):<br />        return self.proc_info[pid][PROC_CODE][index]<br /><br />    def get_num_active(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def get_num_runnable(self):<br />        num_active = 0<br />        for pid in range(len(self.proc_info)):<br />            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br />                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br />                num_active &#43;= 1<br />        return num_active<br /><br />    def space(self, num_columns):<br />        for i in range(num_columns):<br />            print &#39;%10s&#39; % &#39; &#39;,<br /><br />    def check_if_done(self):<br />        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:<br />                self.move_to_done(STATE_RUNNING)<br />                self.next_proc()<br />        return<br /><br />    def run(self):<br />        clock_tick = 0<br /><br />        if len(self.proc_info) == 0:<br />            return<br /><br />        # make first one active<br />        self.curr_proc = 0<br />        self.move_to_running(STATE_READY)<br /><br />        # OUTPUT: heade&#96;[rs for each column<br />        print &#39;%s&#39; % &#39;Time&#39;, <br />        for pid in range(len(self.proc_info)):<br />            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),<br /><br />        print &#39;&#39;<br /><br />        # init statistics<br />        cpu_busy = 0<br /><br />        while self.get_num_active() &gt; 0:<br /><br />            clock_tick &#43;= 1<br />            <br />            # if current proc is RUNNING and has an instruction, execute it<br />            # statistics clock_tick<br />            instruction_to_execute = &#39;&#39;<br />            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br />                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br />                #YOUR CODE<br />                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE][0]<br />                self.proc_info[self.curr_proc][PROC_CODE] = self.proc_info[self.curr_proc][PROC_CODE][1:]<br /><br />            # OUTPUT: print what everyone is up to<br />            print &#39;%3d &#39; % clock_tick,<br />            for pid in range(len(self.proc_info)):<br />                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:<br />                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),<br />                else:<br />                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),<br /><br />            print &#39;&#39;<br /><br />            # if this is an YIELD instruction, switch to ready state<br />            # and add an io completion in the future<br />            if instruction_to_execute == DO_YIELD:<br />                #YOUR CODE<br />                self.move_to_ready(self.proc_info[self.curr_proc][PROC_STATE])<br />                self.next_proc()<br />            <br />            # ENDCASE: check if currently running thing is out of instructions<br />            self.check_if_done()<br />        return (clock_tick)<br />        <br />#<br /># PARSE ARGUMENTS<br />#<br /><br />parser = OptionParser()<br />parser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)<br />parser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,<br />                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,<br />                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)<br />parser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)<br />(options, args) = parser.parse_args()<br /><br />random.seed(options.seed)<br /><br />s = scheduler()<br /><br /># example process description (10:100,10:100)<br />for p in options.process_list.split(&#39;,&#39;):<br />    s.load(p)<br /><br /><br />print &#39;Produce a trace of what would happen when you run these processes:&#39;<br />for pid in range(s.get_num_processes()):<br />    print &#39;Process %d&#39; % pid<br />    for inst in range(s.get_num_instructions(pid)):<br />        print &#39;  %s&#39; % s.get_instruction(pid, inst)<br />    print &#39;&#39;<br />print &#39;Important behaviors:&#39;<br />print &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;<br /><br />(clock_tick) = s.run()<br /><br />if options.print_stats:<br />    print &#39;&#39;<br />    print &#39;Stats: Total Time %d&#39; % clock_tick<br />    print &#39;&#39;</pre>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T12:51:27Z", "id": "i87b2wmiocc377"}, {"no_upvotes": 0, "uid": "i6ublqcaxvu6el", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-07T16:32:12Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p></p><pre># 刘鹤 2012011300<br />#! /usr/bin/env python\n\nimport sys\nfrom optparse import OptionParser\nimport random\n\n# process states\nSTATE_RUNNING = &#39;RUNNING&#39;\nSTATE_READY = &#39;READY&#39;\nSTATE_DONE = &#39;DONE&#39;\n\n# members of process structure\nPROC_CODE = &#39;code_&#39;\nPROC_PC = &#39;pc_&#39;\nPROC_ID = &#39;pid_&#39;\nPROC_STATE = &#39;proc_state_&#39;\n\n# things a process can do\nDO_COMPUTE = &#39;cpu&#39;\nDO_YIELD = &#39;yld&#39;\n\n\nclass scheduler:\n    def __init__(self):\n        # keep set of instructions for each of the processes\n        self.proc_info = {}\n        return\n\n    def new_process(self):\n        proc_id = len(self.proc_info)\n        self.proc_info[proc_id] = {}\n        self.proc_info[proc_id][PROC_PC] = 0\n        self.proc_info[proc_id][PROC_ID] = proc_id\n        self.proc_info[proc_id][PROC_CODE] = []\n        self.proc_info[proc_id][PROC_STATE] = STATE_READY\n        return proc_id\n\n    def load(self, program_description):\n        proc_id = self.new_process()\n        tmp = program_description.split(&#39;:&#39;)\n        if len(tmp) != 2:\n            print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;\n            print &#39;  where X is the number of instructions&#39;\n            print &#39;  and Y is the percent change that an instruction is CPU not YIELD&#39;\n            exit(1)\n\n        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0\n        for i in range(num_instructions):\n            if random.random() &lt; chance_cpu:\n                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)\n            else:\n                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)\n        return\n\n    #change to READY STATE, the current proc&#39;s state should be expected\n    #if pid==-1, then pid=self.curr_proc\n    def move_to_ready(self, expected, pid=-1):\n        #YOUR CODE\n        assert expected != STATE_DONE\n        if pid == -1:\n            pid = self.curr_proc\n        self.proc_info[pid][PROC_STATE] = STATE_READY\n        return\n\n    #change to RUNNING STATE, the current proc&#39;s state should be expected\n    def move_to_running(self, expected):\n        #YOUR CODE\n        assert expected == STATE_READY\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    #change to DONE STATE, the current proc&#39;s state should be expected\n    def move_to_done(self, expected):\n        #YOUR CODE\n        assert expected == STATE_RUNNING\n        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE\n        return\n\n    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc\n    def next_proc(self, pid=-1):\n        #YOUR CODE\n        if pid == -1:\n            pid = self.curr_proc\n        num_process = len(self.proc_info)\n\n        for i in range(0,num_process-1) :\n          if self.proc_info[i][PROC_STATE] == STATE_READY and i != self.curr_proc:\n            self.curr_proc = i\n            \n        if self.proc_info[self.curr_proc][PROC_STATE] != STATE_DONE :\n            self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING\n        return\n\n    def get_num_processes(self):\n        return len(self.proc_info)\n\n    def get_num_instructions(self, pid):\n        return len(self.proc_info[pid][PROC_CODE])\n\n    def get_instruction(self, pid, index):\n        return self.proc_info[pid][PROC_CODE][index]\n\n    def get_num_active(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] != STATE_DONE:\n                num_active &#43;= 1\n        return num_active\n\n    def get_num_runnable(self):\n        num_active = 0\n        for pid in range(len(self.proc_info)):\n            if self.proc_info[pid][PROC_STATE] == STATE_READY or \\\n                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:\n                num_active &#43;= 1\n        return num_active\n\n    def space(self, num_columns):\n        for i in range(num_columns):\n            print &#39;%10s&#39; % &#39; &#39;,\n\n    def check_if_done(self):\n        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:\n                self.move_to_done(STATE_RUNNING)\n                self.next_proc()\n        return\n\n    def run(self):\n        clock_tick = 0\n\n        if len(self.proc_info) == 0:\n            return\n\n        # make first one active\n        self.curr_proc = 0\n        self.move_to_running(STATE_READY)\n\n        # OUTPUT: heade&#96;[rs for each column\n        print &#39;%s&#39; % &#39;Time&#39;, \n        for pid in range(len(self.proc_info)):\n            print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),\n\n        print &#39;&#39;\n\n        # init statistics\n        cpu_busy = 0\n\n        while self.get_num_active() &gt; 0:\n            clock_tick &#43;= 1\n            \n            # if current proc is RUNNING and has an instruction, execute it\n            # statistics clock_tick\n            instruction_to_execute = &#39;&#39;\n            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\\n                   len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:\n                #YOUR CODE\n\n            # OUTPUT: print what everyone is up to\n            print &#39;%3d &#39; % clock_tick,\n            for pid in range(len(self.proc_info)):\n                if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:\n                    print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),\n                else:\n                    print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),\n\n            print &#39;&#39;\n\n            # if this is an YIELD instruction, switch to ready state\n            # and add an io completion in the future\n            if instruction_to_execute == DO_YIELD:\n                #YOUR CODE\n\n            # ENDCASE: check if currently running thing is out of instructions\n            self.check_if_done()\n        return (clock_tick)\n        \n#\n# PARSE ARGUMENTS\n#\n\nparser = OptionParser()\nparser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)\nparser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,\n                  help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,\n                  action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)\nparser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)\n(options, args) = parser.parse_args()\n\nrandom.seed(options.seed)\n\ns = scheduler()\n\n# example process description (10:100,10:100)\nfor p in options.process_list.split(&#39;,&#39;):\n    s.load(p)\n\n\nprint &#39;Produce a trace of what would happen when you run these processes:&#39;\nfor pid in range(s.get_num_processes()):\n    print &#39;Process %d&#39; % pid\n    for inst in range(s.get_num_instructions(pid)):\n        print &#39;  %s&#39; % s.get_instruction(pid, inst)\n    print &#39;&#39;\nprint &#39;Important behaviors:&#39;\nprint &#39;  System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;\n\n(clock_tick) = s.run()\n\nif options.print_stats:\n    print &#39;&#39;\n    print &#39;Stats: Total Time %d&#39; % clock_tick\n    print &#39;&#39;</pre>\n<p></p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-07T16:32:12Z", "id": "i87iyt6nka33kb"}, {"no_upvotes": 0, "uid": "i71i9kso8Gp", "bucket_name": "Last week", "bucket_order": 5, "updated": "2015-04-08T14:02:39Z", "config": {}, "anon": "no", "data": {"embed_links": null}, "folders": [], "subject": "<p>#! /usr/bin/env python</p>\n<p>import sys<br />from optparse import OptionParser<br />import random</p>\n<p># process states<br />STATE_RUNNING = &#39;RUNNING&#39;<br />STATE_READY = &#39;READY&#39;<br />STATE_DONE = &#39;DONE&#39;</p>\n<p># members of process structure<br />PROC_CODE = &#39;code_&#39;<br />PROC_PC = &#39;pc_&#39;<br />PROC_ID = &#39;pid_&#39;<br />PROC_STATE = &#39;proc_state_&#39;</p>\n<p># things a process can do<br />DO_COMPUTE = &#39;cpu&#39;<br />DO_YIELD = &#39;yld&#39;</p>\n<p><br />class scheduler:<br /> def __init__(self):<br /> # keep set of instructions for each of the processes<br /> self.proc_info = {}<br /> return</p>\n<p>def new_process(self):<br /> proc_id = len(self.proc_info)<br /> self.proc_info[proc_id] = {}<br /> self.proc_info[proc_id][PROC_PC] = 0<br /> self.proc_info[proc_id][PROC_ID] = proc_id<br /> self.proc_info[proc_id][PROC_CODE] = []<br /> self.proc_info[proc_id][PROC_STATE] = STATE_READY<br /> return proc_id</p>\n<p>def load(self, program_description):<br /> proc_id = self.new_process()<br /> tmp = program_description.split(&#39;:&#39;)<br /> if len(tmp) != 2:<br /> print &#39;Bad description (%s): Must be number &lt;x:y&gt;&#39;<br /> print &#39; where X is the number of instructions&#39;<br /> print &#39; and Y is the percent change that an instruction is CPU not YIELD&#39;<br /> exit(1)</p>\n<p>num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0<br /> for i in range(num_instructions):<br /> if random.random() &lt; chance_cpu:<br /> self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)<br /> else:<br /> self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)<br /> return</p>\n<p>#change to READY STATE, the current proc&#39;s state should be expected<br /> #if pid==-1, then pid=self.curr_proc<br /> def move_to_ready(self, expected, pid=-1):<br /> #YOUR CODE<br /> assert expected == STATE_RUNNING;<br /> if pid==-1:<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_READY<br /> return<br /> self.proc_info[pid][PROC_STATE] = STATE_READY<br /> return</p>\n<p>#change to RUNNING STATE, the current proc&#39;s state should be expected<br /> def move_to_running(self, expected):<br /> #YOUR CODE<br /> assert expected == STATE_READY<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING<br /> return</p>\n<p>#change to DONE STATE, the current proc&#39;s state should be expected<br /> def move_to_done(self, expected):<br /> #YOUR CODE<br /> assert expected == STATE_RUNNING<br /> self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE<br /> return</p>\n<p>#choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc<br /> def next_proc(self, pid=-1):<br /> if pid==-1:<br /> pid=self.curr_proc<br /> l=len(self.proc_info)<br /> for i in range(pid&#43;1,l):<br /> if self.proc_info[i][PROC_STATE]==STATE_READY:<br /> self.curr_proc=i<br /> self.move_to_running(STATE_READY)<br /> return <br /> for i in range(0,pid&#43;1):<br /> if self.proc_info[i][PROC_STATE]==STATE_READY:<br /> self.curr_proc = i<br /> self.move_to_running(STATE_READY)<br /> return <br /> return</p>\n<p>def get_num_processes(self):<br /> return len(self.proc_info)</p>\n<p>def get_num_instructions(self, pid):<br /> return len(self.proc_info[pid][PROC_CODE])</p>\n<p>def get_instruction(self, pid, index):<br /> return self.proc_info[pid][PROC_CODE][index]</p>\n<p>def get_num_active(self):<br /> num_active = 0<br /> for pid in range(len(self.proc_info)):<br /> if self.proc_info[pid][PROC_STATE] != STATE_DONE:<br /> num_active &#43;= 1<br /> return num_active</p>\n<p>def get_num_runnable(self):<br /> num_active = 0<br /> for pid in range(len(self.proc_info)):<br /> if self.proc_info[pid][PROC_STATE] == STATE_READY or \\<br /> self.proc_info[pid][PROC_STATE] == STATE_RUNNING:<br /> num_active &#43;= 1<br /> return num_active</p>\n<p>def space(self, num_columns):<br /> for i in range(num_columns):<br /> print &#39;%10s&#39; % &#39; &#39;,</p>\n<p>def check_if_done(self):<br /> if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:<br /> self.move_to_done(STATE_RUNNING)<br /> self.next_proc()<br /> return</p>\n<p>def run(self):<br /> clock_tick = 0</p>\n<p>if len(self.proc_info) == 0:<br /> return</p>\n<p># make first one active<br /> self.curr_proc = 0<br /> self.move_to_running(STATE_READY)</p>\n<p># OUTPUT: heade&#96;[rs for each column<br /> print &#39;%s&#39; % &#39;Time&#39;, <br /> for pid in range(len(self.proc_info)):<br /> print &#39;%10s&#39; % (&#39;PID:%2d&#39; % (pid)),</p>\n<p>print &#39;&#39;</p>\n<p># init statistics<br /> cpu_busy = 0</p>\n<p>while self.get_num_active() &gt; 0:<br /> clock_tick &#43;= 1<br /> <br /> # if current proc is RUNNING and has an instruction, execute it<br /> # statistics clock_tick<br /> instruction_to_execute = &#39;&#39;<br /> if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \\<br /> len(self.proc_info[self.curr_proc][PROC_CODE]) &gt; 0:<br /> #YOUR CODE<br /> instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)<br /> self.proc_info[self.curr_proc][PROC_PC] &#43;= 1</p>\n<p># OUTPUT: print what everyone is up to<br /> print &#39;%3d &#39; % clock_tick,<br /> for pid in range(len(self.proc_info)):<br /> if pid == self.curr_proc and instruction_to_execute != &#39;&#39;:<br /> print &#39;%10s&#39; % (&#39;RUN:&#39;&#43;instruction_to_execute),<br /> else:<br /> print &#39;%10s&#39; % (self.proc_info[pid][PROC_STATE]),</p>\n<p>print &#39;&#39;</p>\n<p># if this is an YIELD instruction, switch to ready state<br /> # and add an io completion in the future<br /> if instruction_to_execute == DO_YIELD:<br /> #YOUR CODE<br /> self.move_to_ready(STATE_RUNNING)<br /> self.next_proc()<br /> # ENDCASE: check if currently running thing is out of instructions<br /> self.check_if_done()<br /> return (clock_tick)<br /> <br />#<br /># PARSE ARGUMENTS<br />#</p>\n<p>parser = OptionParser()<br />parser.add_option(&#39;-s&#39;, &#39;--seed&#39;, default=0, help=&#39;the random seed&#39;, action=&#39;store&#39;, type=&#39;int&#39;, dest=&#39;seed&#39;)<br />parser.add_option(&#39;-l&#39;, &#39;--processlist&#39;, default=&#39;&#39;,<br /> help=&#39;a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD&#39;,<br /> action=&#39;store&#39;, type=&#39;string&#39;, dest=&#39;process_list&#39;)<br />parser.add_option(&#39;-p&#39;, &#39;--printstats&#39;, help=&#39;print statistics at end; only useful with -c flag (otherwise stats are not printed)&#39;, action=&#39;store_true&#39;, default=False, dest=&#39;print_stats&#39;)<br />(options, args) = parser.parse_args()</p>\n<p>random.seed(options.seed)</p>\n<p>s = scheduler()</p>\n<p># example process description (10:100,10:100)<br />for p in options.process_list.split(&#39;,&#39;):<br /> s.load(p)</p>\n<p><br />print &#39;Produce a trace of what would happen when you run these processes:&#39;<br />for pid in range(s.get_num_processes()):<br /> print &#39;Process %d&#39; % pid<br /> for inst in range(s.get_num_instructions(pid)):<br /> print &#39; %s&#39; % s.get_instruction(pid, inst)<br /> print &#39;&#39;<br />print &#39;Important behaviors:&#39;<br />print &#39; System will switch when the current process is FINISHED or ISSUES AN YIELD&#39;</p>\n<p>(clock_tick) = s.run()</p>\n<p>if options.print_stats:<br /> print &#39;&#39;<br /> print &#39;Stats: Total Time %d&#39; % clock_tick<br /> print &#39;&#39;</p>", "children": [], "type": "followup", "no_answer": 1, "created": "2015-04-08T14:02:39Z", "id": "i88t2by1qpb6rf"}], "request_instructor": 0, "tags": ["exam", "instructor-note"], "s_edits": [], "num_favorites": 0}, "aid": "iajh1lenxfe3md"}